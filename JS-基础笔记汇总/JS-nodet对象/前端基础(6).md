# 				       		前端基础



------

 引言：此知识来源于启嘉网金老师的前端基础课程（记录后的帮己手册,当遇到新问题和得到经验时会及时在内容中更新）

------



# 一、HTML+CSS 2.0



## 阶段 1：入门概述



### 一、概述



#### 1、什么是HTML

```html
HTML 是个缩写形式，其全称为 Hyper Text Markup Language，翻译成中文的含义为超文本标记语言。HTML 不是一门编程语言，而是一门标记语言，因为 HTML 是由一系列的元素组成，这些元素可以包含文本、超链接等不同内容。

例：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>HTML基本结构</title>
</head>

<body>
  <h1>这是最基本的HTML结构</h1>
</body>

</html>

```

细究：概念分成**超文本**和**标记语言**两部分进行分别学习。



#### 2、什么是超文本

```
通过浏览器运行后缀名为.html或.htm文本，浏览器运行并显示这个文本的内容
```



#### 3、什么是标记语言

```
标记语言中的标记指的就是 HTML 中的元素（Element），而 HTML 就是由这样的一系列元素组成的，所以被称为标记语言。

HTML 的元素是给定的。无论是 HTML 元素的数量，还是 HTML 元素的作用都是固定不变的。换句话讲，我们学习 HTML 简单来说就是学习 HTML 元素的含义、作用以及用法等内容。
```



#### 4、HTML版本

```
在 HTML 版本发展历程中，大部分的版本都离我们远去了，也就是说我们并不关心，而需要关心的是 4.01 和 5 这两个版本。5 版本是 HTML 目前最新版本，也就是我们现在常说的 HTML5，而且现在学习 HTML 都是针对 5 这个版本进行学习的。
反而需要特别关心的是 4.01 版本。因为 4.01 版本依旧存在于一些较老的网站或者系统中，如果将来你的工作是对这些网站或者系统进行升级工作的话，那么就需要了解 4.01 这个版本的内容。
```



### 二、框架



#### 1、基本概念

```
1、<!DOCTYPE>  
声明、元素和注释等内容
<!DOCTYPE html>在HTML5版本，基本结构的第一行，这块内容被称为 HTML 声明。HTML 声明的作用是浏览器运行该 HTML 页面时，告知浏览器当前 HTML 页面的版本。这样浏览器会准确地进行解析并展示其内容。

2、<html> 元素：表示当前 HTML 页面的根元素，用来包含所有其他 HTML 元素。
<html lang=""en">   en为（english）英文网站，可以输出为中文,只是会让你的浏览器提示你要不要翻译此页,如果改成zh-cn（中文）就没有翻译的选项了 

3、<head> 元素：表示当前 HTML 页面的头部，用来定义当前 HTML 页面的基本信息，例如标题、关键字、作者等内容。

4、<body> 元素：表示当前 HTML 页面的主体，用来定义最终显示在浏览器窗口的内容。

```



#### 2、HTML元素

```html
除了 HTML 声明之外，其他内容都是 HTML 元素
元素（Element）：是用来包含文字、图片或者音视频的内容，一般是由标签+内容组成。
标签（Tag）：是元素的组成部分，一般分为开始标签和结束标签。

HTML 元素可以分为闭合元素和空元素两种类型

闭合元素：具有开始标签和结束标签，而且开始标签和结束标签是成对出现的
空元素：只有开始标签，而没有结束标签。

注意：<html> 元素是比较特殊的元素，称为根元素。在一个 HTML 页面中只能存在一个 <html> 元素，即使编写了多个 <html> 元素，运行 HTML 页面时浏览器也会自动忽略。
```



#### 3、简单标签（了解）

```
一、双标签
1、“ol”有序列表
2、 “ul”无序列表 
3、 “h1~h6‘’递减标题标签
4、‘’html‘’超文本标记语言
5、‘’超文本‘’指页面内可以包含图片、链接、音乐、程序等非文字元素。一种静态的前端，可以说是前端的基础，web是动态前端。
6、‘’body‘’主体的意思。，部分提供网页的内容。
7、‘’head‘’开头，提供网页的信息。
8、‘’p‘’段落标签
9、‘’u‘’字体下划线
10、‘’s‘’中间一条删除线
11、‘’b‘’加粗 
12、‘’i‘’ 倾斜
13、‘’ol‘’组合列表标签有序，‘’li‘’是子列表，建立列表必要代码 ‘’ul‘’无序列表标签

二、单标签
1、‘’ <hr />‘’整行下划线
2、‘’<br />‘’换行标签
3、‘’<img src=“xxx" widh=500 height=200/> img是图片标签，src是图片路径，xxx是图片文件后缀名,widh是图片宽度，hight是图片高度，（如果图片路径不在同一个文件当中，比如在log文件中，那么格式是<img src="log/xxx"）

三、表格标签
1、‘’table（双）‘’是建立列表开始标签
  <table >里加‘’border‘’表边框，加边框数值，
 例：<table border="1"> ， 叫做标签属性，=左面表属性，=右面叫做属性值
2、 <table align="center">  align，是表列表对齐格式，center表居中对齐，<table align="right">表右对齐，当然left表左对齐
3、<table width=''500''> width是表格宽度的意思，500是像素宽值
      
4、   在<table></table>里面嵌套‘’tr（双）‘’表行（双），在<tr></tr>里面嵌套‘’td（双）‘’表列  
例如俩行一列: 
<tr> <td></td> </tr>
<tr> <td></td> </tr>
俩行俩列，例：
<tr>
       <td></td>
       <td></td>
</tr>

<tr>
       <td></td>
       <td></td>
</tr>

（1）<td rowspan="2">是把俩行合并成一行（可以说是在这一行中占了俩个单元格），rowspan是一整行的单元格合并
（2）<td colspan="2">是把俩列合并成一列，是一整列的单元格合并
5、<table cellpadding="10"> cellpadding是单元格填充（可以说是一个箱子里面填了棉花或者泡沫，使箱子里面的东西到盒子内部的边，距离的变化）
6、<table cellspacing="1">cellspacing是单元格间距（可以说是一个货车里面装的每一个箱子之间的距离）
```



#### 4、HTML 元素的属性

```html
属性定义在元素的开始标签中，这样无论是闭合元素还是空元素都可以正常使用属性。属性的语法结构是键值对形式的。

属性名（attribute name）：其数量和作用都是 HTML 给定的。
属性值（attribute value）：属性对应的值，建议使用一对双引号进行包裹。

例：
<div id="box">文本内容</div>
id 为属性名，box为属性值

同一个元素是允许编写多个不同的属性，但在同一个元素中不能同时定义多个相同的属性。
再有，HTML 元素的属性可以划分为以下 4 种：
1、标准（通用）属性：HTML 元素几乎都具有的属性，例如 id、name、style 和 class 属性等。
2、专有（私有）属性：HTML 中某些元素特有的属性，例如 <form> 元素的 action 属性等。
3、事件属性：用来为 HTML 元素注册 DOM 事件的属性，例如 onclick 属性等。
4、自定义属性：第三方框架中为了完成某个特定功能而定义的属性，例如 Vue 框架的 v-if 属性等。
```



#### 5、head 包括的元素

```html
<meta> 元素：定义 HTML 页面的元数据信息，例如编码格式、作者、关键字等。
常用：<meta charset="UTF-8">

<title> 元素：定义 HTML 页面的标题，显示在浏览器的标题或标签页上。

<base> 元素：定义 HTML 页面中所有相对 URL 的根 URL。

<link> 元素：定义 HTML 页面引入的外部资源，比较常见的是引入外部 CSS 文件或图标文件等。
    
<style> 元素：定义 HTML 页面的 CSS 样式，一般称为内嵌样式表。

<script> 元素：定义 HTML 页面的可执行的脚本，一般多为 JavaScript 脚本。
    
<noscript> 元素：定义当 HTML 页面的脚本代码不被支持或者浏览器关闭了脚本执行时的替代内容。

<command> 元素：定义 HTML 页面允许用户可以调用的命令。该元素已被废弃！
```



#### 6、meta 元素

```
<meta> 元素是用来定义不能由 <base>、<link>、<script>、<style> 和 <title> 元素定义的元数据信息。并且 <meta> 元素是个空元素。

<meta> 元素常用的用法如下所示：

为搜索引擎定义关键词：
<meta name="keywords" content="HTML, CSS, XML, XHTML, JavaScript">

为网页定义描述内容：
<meta name="description" content="Free Web tutorials on HTML and CSS">

定义网页作者：
<meta name="author" content="KingJ">

每30秒中刷新当前页：
<meta http-equiv="refresh" content="30">

HTML5 版本定义编码格式：
<meta charset="UTF-8">

定义 HTML 页面的视口：
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```



#### 7、HTML 注释

```
与很多开发语言类似，HTML 语言提供了编写注释的语法内容。在浏览器运行 HTML 页面时，浏览器会自动忽略注释里面的内容，用户是看不到 HTML 页面中有关注释的内容的。

当一段内容被 <!-- 和 --> 包裹起来时，那么这段内容就是一个注释内容。选中要注释内容 快捷键 Ctrl /
```



### 三、CSS 



#### 1、什么是 CSS

```css
CSS 是个缩写形式，其全称为 Cascading Style Sheets，翻译成中文的含义为层叠样式表。CSS 是用来定义 HTML 元素显示的样式和布局方式，例如设置显示字体的颜色、大小等效果。

例：
p {
	color: lightcoral;
	font-size: 24px;
}

CSS 的出现真正做到了将网页样式和内容有效进行分离，其中 HTML 元素用于展示内容，CSS 用于定义样式。

提示：HTML 同样提供了有关样式的元素及属性，例如 <font> 元素和 color 属性等。目前有关网页的样式统一由 CSS 进行定义，所以 HTML 有关样式的元素和属性基本上已废弃。

通过 CSS 设置 HTML 页面的样式，会覆盖掉浏览器的默认样式，从而使得 HTML 页面在不同浏览器中运行时显示的效果是一样的。

CSS 样式主要的应用场景是在 HTML 页面中，其作用就是为 HTML 页面设置在浏览器运行后的显示效果。而在 HTML 页面使用 CSS 样式具有三种方式：
内联样式
内嵌样式表
外联样式表
```



#### 2.1、内联样式

```css
HTML 元素的 style 属性的作用是为该元素设置 CSS 样式。

使用内联样式的优点在于简单、直接。HTML 元素的 <style> 属性属于标准属性，也就是说 HTML 所有的元素都可以通过 <style> 属性来定义 CSS 样式。

但使用内联样式的缺点也非常明显，具体缺点如下：
HTML 内容与 CSS 样式属于强耦合，并没有实现网页的内容和样式的有效分离。
如果为不同元素设置相同的 CSS 样式的话，会导致相同的 CSS 样式代码被重复定义，产生冗余代码。

例：
<div style="color: lightcoral;">这是测试内容.</div>
```



#### 2.2、内嵌样式表

```css
HTML <head> 元素中的 <style> 元素可以用来为当前 HTML 页面的元素设置 CSS 样式。

使用内嵌样式表的优点在于解决内联样式中的两个问题：
HTML 内容与 CSS 样式的强耦合问题，使得网页的内容和样式有效地分离。
如果为不同元素设置相同的 CSS 样式的话，只需要定义一次 CSS 样式代码。

但内嵌样式表依旧编写在 HTML 文件中。如果一个 HTML 页面中包含大量的 CSS 样式的话，会导致 HTML 文件变得很大，从而浏览器加载 HTML 页面时耗时变长。

例：
<style type="text/css">
	p {
		color: lightcoral;
		font-size: 24px;
	}
</style>

提示：上述示例代码中的 <style type="text/css"> 中的 type 属性在 HTML5 版本中可以省略。
```



#### 2.3、外联样式表

```css
CSS 样式代码可以定义在一个 CSS 文件中，这样有效地解决了内嵌样式表中的问题。

具体的做法如下所示：
创建一个扩展名为 .css 的文件，并且将 CSS 样式代码编写在这个文件中。
在 HTML 页面中，通过 <head> 元素中的 <link> 元素将创建的 CSS 文件引入到 HTML 页面中。

例 ：
<link rel="stylesheet" href="style/demo.css">

rel 属性：用来定义引入文件与当前 HTML 页面的关系，该属性值必须是链接类型值。
href 属性：用来定义引入文件的 URL。

说明：一个 HTML 页面允许引入多个 CSS 文件，多个 CSS 文件的加载顺序按照 HTML 页面引入的顺序进行加载。

需要注意的是，外联样式表不会与 HTML 页面同步被浏览器加载。具体的加载过程如下所示：
浏览器会加载 HTML 页面并进行解析。
解析到 <link> 元素引入的 CSS 文件，并通过 href 属性读取到 CSS 文件的路径。
根据读取的路径，开始加载 CSS 文件并进行解析。
```



#### 3、结构分化

```css
CSS 语法的基本结构可分为：

选择器（Selector）：用来定位当前 HTML 页面中的元素，可以是一个元素也可以是多个元素（元素集）。

例：class和id 选择器

class选择器：<head>
             <style type="text/css">
                 .p1{ font-family:"宋体"；
                            }
                 .p2{ font-family:"宋体"；
                            }
              </head>
<body>
      <p class="P1">我喜欢那个女孩</p>
      <p class="P2">不知她怎样？</p>
</body>

id选择器:<head>
             <style type="text/css">
                 #P1{ font-family:"宋体"；
 
                            }
                 #P2{ font-family:"宋体"；
 
                            }
              </head>
<body>
      <p class="P1">我喜欢那个女孩</p>
      <p class="P2">不知她怎样？</p>
</body>


声明块（Declaration block）：用来包含一个或多个 CSS 声明，其语法结构是一对花括号。
例：
{
	color: lightcoral;
	font-size: 24px;
}
```



#### 4、CSS 声明

```
CSS 语法结构中除了选择器之外，就是声明了。

CSS 声明是一个由 CSS 定义的规则，具体的语法结构是一对键/值对形式。

CSS 声明的语法结构可分为：
属性（Properties）：用来定义 HTML 元素样式的方式，是由 CSS 给定的。例如 color 属性是用来定义元素的文本颜色等。

属性的值（Property value）：用来定义 HTML 元素的样式。例如 color 属性的值可以是 red 等。

注意：不同的 CSS 属性对应的属性值是不同的。具体的可以参考 MDN提供的参考文档。

分隔符：是一个冒号（:），用来分隔 CSS 属性和值的。
结束符：是一个分号（;），用来表示一个 CSS 声明结束。
```



#### 5、CSS 注释

```css
CSS 与 HTML 同样提供了注释，其作用也与 HTML 的注释类似。不过 CSS 的注释语法与 HTML 不同

例： /*  注释内容  */
```





## 阶段 2：CSS 选择器



### 一、选择器概述



#### 1、什么是选择器

```css
CSS 选择器的作用是按照 CSS 规则定位 HTML 页面的一个或多个元素。浏览器在解析 HTML 页面时，会根据 CSS 规则中的选择器定位 HTML 页面的元素，并为对应的元素设定样式。
（说白了：就是对元素做标记，方便根据标记去决定给那几个元素添加css样式）

通过 CSS 选择器可以实现对 HTML 元素的一对一、一对多和多对一的定位

如下示例代码所示展示了 CSS 选择器一对一定位 HTML 元素：
#box {
  color: lightcoral;
  font-size: 24px;
}

如下示例代码所示展示了 CSS 选择器一对多定位 HTML 元素：
div {
  color: lightcoral;
  font-size: 24px;
}

如下示例代码所示展示了 CSS 选择器多对一定位 HTML 元素：
div.demo {
  color: lightcoral;
  font-size: 24px;
}
```



#### 2、选择器的分类

```
CSS 从第一版本发展到第三版本，导致 CSS 选择器的种类越来越复杂。目前，CSS 选择器的分类具体如下：

基本选择器：共有 5 个基本选择器，是 CSS 选择器的最为基本的用法。
层级选择器：共有 4 个层级选择器，是根据 HTML 元素之间的关系来定位 HTML 元素。
组合选择器：具有交集和并集两种用法，是将之前基本选择器和层级选择器进行组合。
伪类选择器：允许未包含在 HTML 页面中的状态信息选定位 HTML 元素。
伪元素选择器：定位所有未被包含 HTML 的实体。

提示：CSS 选择器的分类以及命名方式，不同资料中可能会有不同，但选择器的每一种用法是一致的。
```



### 二、基本选择器



#### 1、概述

```
CSS 的基本选择器是选择器所有种类中最为基础的用法，基本选择器共有 5 种具体用法，如下：

类型（Type）选择器（有些中文资料中称为“元素选择器”）

类（Class）选择器

ID 选择器

通用选择器（有些中文资料中称为“通配符选择器”）

属性选择器
```



#### 2.1、类型选择器

```css
类型选择器，又称为元素选择器，这种基本选择器是通过 HTML 页面的元素名定位具体 HTML 元素。如果类型选择器单独使用的话，会定位当前 HTML 页面中所有该元素名的元素。（通过元素名定位元素）

例：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>类型选择器</title>
  <style>
    div {
      color: lightcoral;
      font-size: 24px;
    }
  </style>
</head>

<body>
  <div>这是测试内容.</div>
  <p>这是另一个测试内容.</p>
</body>

</html>
```



#### 2.2、类选择器

```css
类选择器是通过 HTML 元素的 class 属性的值定位具体 HTML 元素。这种基本选择器的用法是 .className 形式，其中 className 称为类名

例：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>类选择器</title>
  <style>
    .demo {
      color: lightcoral;
      font-size: 24px;
    }
  </style>
</head>

<body>
  <div class="demo">这是测试内容.</div>
  <p>这是另一个测试内容.</p>
</body>

</html>
```



#### 2.3、ID 选择器

```css
ID 选择器是通过 HTML 元素的 id 属性的值定位具体 HTML 元素。这种基本选择器的用法是 #ID 形式，其中 ID 是 id 属性的值

例：
#ID {
	属性 : 属性值;
}
如下示例代码展示了ID 选择器的用法：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>ID选择器</title>
  <style>
    #Demo {
      color: lightcoral;
      font-size: 24px;
    }
  </style>
</head>

<body>
  <div id="Demo">这是测试内容.</div>
  <p>这是另一个测试内容.</p>
</body>

</html>
```



#### 2.4、通用选择器

```css
CSS2 版本新引入了通用选择器，又称为通配符选择器，是一个星号（*），这个基本选择器是用来定位任何类型的 HTML 元素。

例：
* {
	属性 : 属性值;
}
如下示例代码展示了通用选择器的用法：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>通用选择器</title>
  <style>
    * {
      color: lightcoral;
    }
  </style>
</head>

<body>
  <div id="Demo">这是测试内容.</div>
  <p>这是另一个测试内容.</p>
</body>

</html>

注意：通用选择器是性能最低的基本选择器，所以并不推荐使用这种基本选择器。
```



#### 2.5、属性选择器

```css
属性选择器是通过 HTML 元素已经存在属性名或属性值来定位具体 HTML 元素，而且属性选择器包括了如下几种具体用法：

1、[attr] 属性选择器：通过 HTML 元素的 attr 属性名来定位具体 HTML 元素，而不关注 attr 属性的值是什么。

例：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>属性选择器</title>
  <style>
    /* 所有包含`lang`属性的元素, 设置CSS font-weight: bold. */
    [lang] {
      font-weight: bold;
    }
  </style>
</head>

<body>
  <div lang="en-us en-gb en-au en-nz">Hello World!</div>
  <div lang="pt">Olá Mundo!</div>
  <div lang="zh-CN">世界您好！</div>
  <div lang="zh-TW">世界您好！</div>
  <div data-lang="zh-TW">?世界您好！</div>
</body>

</html>
```

```css
2、[attr=value] 属性选择器：通过 HTML 元素的 attr 属性名并且属性值为 value 来定位具体 HTML 元素。

例：
如下示例代码所示展示了**[attr=value] 属性选择器**的用法：
[attr=value] {
	属性 : 属性值;
}

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>属性选择器</title>
  <style>
    /* 所有包含`lang`属性并且属性值匹配"pt"的元素, 设置CSS color:green. */
    [lang="pt"] {
      color: green;
    }
  </style>
</head>

<body>
  <div lang="en-us en-gb en-au en-nz">Hello World!</div>
  <div lang="pt">Olá Mundo!</div>
  <div lang="zh-CN">世界您好！</div>
  <div lang="zh-TW">世界您好！</div>
  <div data-lang="zh-TW">?世界您好！</div>
</body>

</html>
```

```css
3、[attr~=value] 属性选择器：通过 HTML 元素的 attr 属性名，属性值是一个以空格分隔的列表并且 value 值是该值列表中的之一，来定位具体 HTML 元素。

如下示例代码所示展示了**[attr~=value] 属性选择器**的用法：
[attr~=value] {
	属性 : 属性值;
}

例：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>属性选择器</title>
  <style>
    /* 所有包含`lang`属性并且属性值是以空格为间隔的值列表, 值列表中包含"en-us"的元素, 设置CSS color:blue. */
    [lang~="en-us"] {
      color: blue;
    }
  </style>
</head>

<body>
  <div lang="en-us en-gb en-au en-nz">Hello World!</div>
  <div lang="pt">Olá Mundo!</div>
  <div lang="zh-CN">世界您好！</div>
  <div lang="zh-TW">世界您好！</div>
  <div data-lang="zh-TW">?世界您好！</div>
</body>

</html>
```

```css

4、[attr|=value] 属性选择器：通过 HTML 元素的 attr 属性名并且属性值为 value 或者以 value- 为前缀来定位具体 HTML 元素。


[attr|=value] {
	属性 : 属性值;
}
如下示例代码展示了**[attr|=value] 属性选择器**的用法：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>属性选择器</title>
  <style>
    /* 所有包含`lang`属性并且属性值匹配"zh"或 以"zh-"为开头的元素, 设置CSS color:red, 无论简体中文 (zh-CN) 或者 繁体中文 (zh-TW). */
    [lang|="zh"] {
      color: red;
    }
  </style>
</head>

<body>
  <div lang="en-us en-gb en-au en-nz">Hello World!</div>
  <div lang="pt">Olá Mundo!</div>
  <div lang="zh-CN">世界您好！</div>
  <div lang="zh-TW">世界您好！</div>
  <div data-lang="zh-TW">?世界您好！</div>
</body>

</html>
```

```css
5、[attr^=value] 属性选择器：通过 HTML 元素的 attr 属性名并且属性值是以 value 为开头来定位具体 HTML 元素。

[attr^=value] {
	属性 : 属性值;
}
如下示例代码展示了**[attr^=value] 属性选择器**的用法：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>属性选择器</title>
  <style>
    /* 存在href属性并且属性值以"#"开始的元素, 如下选择 */
    [href^="#"] {
      background-color: gold;
    }
  </style>
</head>

<body>
  <ul>
    <li><a href="#internal">Internal link</a></li>
    <li><a href="http://example.com">Example link</a></li>
    <li><a href="#InSensitive">Insensitive internal link</a></li>
    <li><a href="http://example.org">Example org link</a></li>
  </ul>
</body>

</html>
```

```css
6、[attr$=value] 属性选择器：通过 HTML 元素的 attr 属性名并且属性值是以 value 为结束来定位具体 HTML 元素。

例：
如下示例代码所示展示了**[attr$=value] 属性选择器**的用法：
[attr$=value] {
	属性 : 属性值;
}
如下示例代码展示了**[attr$=value] 属性选择器**的用法：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>属性选择器</title>
  <style>
    /* 存在href属性并且属性值结尾是".org"的元素, 如下选择 */
    [href$=".org"] {
      color: red;
    }
  </style>
</head>

<body>
  <ul>
    <li><a href="#internal">Internal link</a></li>
    <li><a href="http://example.com">Example link</a></li>
    <li><a href="#InSensitive">Insensitive internal link</a></li>
    <li><a href="http://example.org">Example org link</a></li>
  </ul>
</body>

</html>
```

```css
7、[attr*=value] 属性选择器：通过 HTML 元素的 attr 属性名并且属性值是包含 value 来定位具体 HTML 元素。

例：
如下示例代码所示展示了**[attr*=value] 属性选择器**的用法：
[attr*=value] {
	属性 : 属性值;
}
如下示例代码展示了**[attr*=value] 属性选择器**的用法：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>属性选择器</title>
  <style>
    /* 存在href属性并且属性值包含"example"的元素, 如下选择*/
    [href*="example"] {
      background-color: silver;
    }
  </style>
</head>

<body>
  <ul>
    <li><a href="#internal">Internal link</a></li>
    <li><a href="http://example.com">Example link</a></li>
    <li><a href="#InSensitive">Insensitive internal link</a></li>
    <li><a href="http://example.org">Example org link</a></li>
  </ul>
</body>

</html>
```



#### 3、选择器的优先级

```
CSS 优先级是基于不同的选择器来组成的定位规则。优先级的计算方式如下：
优先级就是分配给指定的 CSS 声明的一个权重，它由匹配的选择器中的每一种选择器类型的数值决定。
当优先级与多个 CSS 声明中任意一个声明的优先级相等的时候，CSS 中最后的那个声明将会被应用到元素上。
当同一个元素有多个声明的时候，优先级才会有意义。

选择器类型的权重
CSS 分配给每一种选择器类型的权重分值，如下列表所示：
通配符选择器的优先级为 0
类型（元素）选择器的优先级为 1
类选择器和属性选择器的优先级为 10
ID 选择器的优先级为 100
内联样式的优先级为 1000

通过上述列表内容我们和得到一个结论：内联样式总会覆盖内嵌样式表和外联样式表的任何样式。
提示：这里所罗列的选择器类型的权重仅是基本选择器内容
```



#### 4、!important 例外规则

```css
在上述选择器类型的权重中存在着一个例外规则，就是 !important。如果使用 !important 规则的话，会覆盖掉所有其他选择器的声明样式。
虽然 !important 规则与选择器类型的权重无关，但 !important 规则直接影响 CSS 样式的最终显示效果，所以 !important 一定要谨慎使用。
如下示例代码所示展示了 !important 规则的用法：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>!important规则</title>
  <style>
    div {
      color: lightcoral !important;
    }

    .demo {
      color: lightgray;
    }
  </style>
</head>

<body>
  <div class="demo">这是一个测试内容.</div>
</body>

</html>


```



### 三、层级选择器



#### 1、概述

```css
CSS 层级选择器是根据 HTML 元素之间的关系而提供的选择器用法，所以想要很好地学习层级选择器首先需要搞清楚 HTML 元素之间的关系是怎么样的。
HTML 元素之间的关系
想要搞清楚 HTML 元素之间的关系，在 HTML 页面中元素之间的关系存在着如下所示的三种关系：
父级与子级之间的关系：如下示例代码所示，<ul> 元素是 <li> 元素的父级元素，反之 <li> 元素是 <ul> 元素的子级元素。
<ul id="parent">
	<li id="child"></li>
</ul>

兄弟之间的关系：如下示例代码所示，<ul> 元素是两个 <li> 元素的父级元素，即两个 <li> 元素拥有同一个父级元素，那么这两个 <li> 元素就是兄弟元素。
<ul id="parent">
	<li id="child1"></li>
    <li id="child2"></li>
</ul>

祖先与后代之间的关系：如下示例代码所示，<ul> 元素和 <li> 元素是 <div> 元素的后代元素，反之 <div> 元素是 <ul> 和 <li> 元素的祖先元素。
<div id="ancestor">
	<ul id="parent">
    <li id="child1"></li>
    <li id="child2"></li>
  </ul>
</div>


接下来，我们再来看一个 HTML 页面的示例代码，如下所示：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>HTML元素之间的关系</title>
</head>

<body>
  <div id="ancestor1">
    <div id="parent1">
      <div id="child11"></div>
      <div id="child12"></div>
    </div>
    <div id="parent2">
      <div id="child2"></div>
    </div>
  </div>
  <div id="ancestor2"></div>
</body>

</html>
提示：根据 HTML 的基本结构我们知道，<html> 是根元素，然后包含 <head> 和 <body> 两个元素。这里我们主要讨论 <body> 元素包含元素的情况。
如上述示例代码所示，<body> 元素包含的所有元素按照包含和被包含的关系

如上所示，可以将 HTML 元素的结构按照 3 种关系划分：
兄弟元素：ancestor1 元素和 ancestor2 元素、parent1 元素和 parent2 元素，以及 child11 元素和 child12 元素。
父级与子级元素： 
如果 <body> 元素是父级元素的话，那 ancestor1 元素和 ancestor2 元素就是子级元素。
如果 ancestor1 元素是父级元素的话，那 parent1 元素和 parent2 元素就是子级元素。
如果 parent1 元素是父级元素的话，那 child11 元素和 child12 元素就是子级元素。
祖先与后代元素： 
如果 <body> 元素是祖先元素的话，那其包含的所有元素都是后代元素。
如果 ancestor1 元素是祖先元素的话，那其包含的所有元素都是后代元素。
如果 parent1 元素是祖先元素的话，那其包含的所有元素都是后代元素。
```



#### 2、层级选择器种类

```
根据 HTML 元素之间的 3 种关系，CSS 的层级选择器提供了如下 4 种用法：

后代选择器
子级选择器
相邻兄弟选择器
普通兄弟选择器
```

  

##### 2.1、后代选择器

```css
后代选择器是将某个元素当做祖先元素，定位该元素的所有后代元素。后代选择器的语法结构如下所示：

选择器1 选择器2 {
	属性 : 属性值;
}
上述语法结构具体说明如下：
选择器1：表示某个祖先元素。
选择器2：定位“选择器1”的指定“选择器2”的后代元素。
连接符：“选择器1”和“选择器2”之间是通过空格（’ '）操作符进行连接的。

如下示例代码所示展示了后代选择器的具体用法：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>后代选择器</title>
  <style>
    span {
      background-color: lightgreen;
    }

    div span {
      background-color: lightcoral;
    }
  </style>
</head>

<body>
  <div>
    <span>Span 1.
      <span>Span 2.</span>
    </span>
  </div>
  <span>Span 3.</span>
</body>

</html>

提示：后代选择器定位的元素中是包含子级选择器定位的元素的。
```



##### 2.2、子级选择器

```css
子级选择器是将某个元素当做父级元素，定位该元素的所有子级元素（并不包括孙级）。子级选择器的语法结构如下所示：
选择器1>选择器2 {
	属性 : 属性值;
}
上述语法结构具体说明如下：
选择器1：表示某个父级元素。
选择器2：定位“选择器1”的指定“选择器2”的子级元素。
连接符：“选择器1”和“选择器2”之间是通过大于号（>）操作符进行连接的。

如下示例代码所示展示了子级选择器的具体用法：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>子级选择器</title>
  <style>
    span {
      background-color: lightgreen;
    }

    div>span {
      background-color: lightcoral;
    }
  </style>
</head>

<body>
  <div>
    <span>Span 1.
      <span>Span 2.</span>
    </span>
  </div>
  <span>Span 3.</span>
</body>

</html>
```



##### 2.3、相邻兄弟选择器

```css
相邻兄弟选择器是将某个元素作为目标元素，定位与该目标元素拥有同一个父级元素的下一个指定元素（选择器1不会改变，选择器2才会被改变）。相邻兄弟选择器的语法结构如下所示：
选择器1+选择器2 {
	属性 : 属性值;
}
上述语法结构具体说明如下：
选择器1：表示某个目标元素。
选择器2：定位与“选择器1”拥有同一个父级元素的下一个“选择器2”元素。
连接符：“选择器1”和“选择器2”之间是通过加号（+）操作符进行连接的。

如下示例代码所示展示了相邻兄弟选择器的具体用法：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>相邻兄弟选择器</title>
  <style>
    span {
      background-color: lightgreen;
    }

    #span2+span {
      background-color: lightcoral;
    }
  </style>
</head>

<body>
  <div>
    <span>Span 1.
      <span id="span2">Span 2.</span>
      <span>Span 4.</span>
    </span>
  </div>
  <span>Span 3.</span>
</body>

</html>

注意：必须是目标选择器下一个元素，如若中间隔了一个元素，那么就无效
```



##### 2.4、普通兄弟选择器

```css
普通兄弟选择器是将某个元素作为目标元素，定位与该目标元素拥有同一个父级元素的之后任意指定元素。普通兄弟选择器的语法结构如下所示：
选择器1~选择器2 {
	属性 : 属性值;
}
上述语法结构具体说明如下：
选择器1：表示某个目标元素。
选择器2：定位与“选择器1”拥有同一个父级元素的之后任意“选择器2”元素。
连接符：“选择器1”和“选择器2”之间是通过波浪号（~）操作符进行连接的。

如下示例代码所示展示了普通兄弟选择器的具体用法：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>普通兄弟选择器</title>
  <style>
    span {
      background-color: lightgreen;
    }

    p~span {
      background-color: lightcoral;
    }
  </style>
</head>

<body>
  <span>This is not red.</span>
  <p>Here is a paragraph.</p>
  <code>Here is some code.</code>
  <span>And here is a span.</span>
</body>

</html>

注意：此选择器和相邻兄弟选择器不同，此选择器更灵活，可以指定目标元素之后任意一个元素
```



### 四、组合选择器



#### 1、概述

```
组合选择器是将之前学习的 CSS 选择器用法综合在一起的一种用法，从定位 HTML 元素的结果上可分为如下 2 种：
组合（并集）选择器
组合（交集）选择器
```



#### 2.1、组合（并集）选择器

```css
组合（并集）选择器就是不同选择器的相同 CSS 声明合并在一起，从而得到更为简洁的样式表。例如如果要为 <h1> 至 <h6> 标题元素设定相同的背景颜色，可以如下示例代码所示：
h1 { color:blue; }
h2 { color:blue; }
h3 { color:blue; }
h4 { color:blue; }
h5 { color:blue; }
h6 { color:blue; }
这时我们可以看到上述 CSS 使用了类型选择器，但元素名称不同，并且 CSS 声明完全一致。那么，上述示例代码可以通过组合（并集）选择器进行改写如下所示：
h1, h2, h3, h4, h5, h6 { color:blue; }
上述两段示例代码的作用是一致的，第二段示例代码展示的就是组合（并集）选择器的用法。
组合（并集）选择器是使用逗号（,）分隔不同的选择器，并为这些不同的选择器定义相同的 CSS 声明。组合（并集）选择器的语法结构如下所示：
选择器1, 选择器2, ... ... {
	属性 : 属性值;
}
```



#### 2.2、组合（交集）选择器

```css
组合（交集）选择器就是先通过第一个选择器定位 HTML 元素集，再通过第二个选择器从上述 HTML 元素集再次筛选定位 HTML 元素集，如此反复，直到最后一个选择器执行完毕。
例如如果我们要为所有 class 属性值为 cls 的 <p> 元素设定 CSS 样式的话，具体实现的代码如下所示：
p.cls {
	color: blueviolet;
}
如上述示例所示，展示了组合（交集）选择器的用法。
组合（交集）选择器在多个选择器之间不需要任何分隔符进行分隔，只需要将多个选择器依次编写即可。组合（交集）选择器的语法结构如下所示：
选择器1.选择器2... ... {
	属性 : 属性值;
}
说明：组合（交集）选择器中多个选择器的执行顺序是按照编写的先后顺序执行的。
```



### 五、伪类选择器



#### 1、概述

```css
伪类选择器是一种允许通过未包含在 HTML 元素的状态信息来定位 HTML 元素的用法。伪类选择器的具体用法就是向已有的选择器增加关键字，表示定位的 HTML 元素的状态信息。
（通俗说：CSS 伪类 是添加到选择器的关键字，指定要选择的元素的特殊状态。）
例如 :hover 伪类选择器可以用来在用户将鼠标悬停在按钮上时改变按钮的颜色。如下示例代码所示：
/* 所有用户指针悬停的按钮 */
button:hover {
  color: blue;
}
伪类选择器的语法结构如下所示：
选择器:伪类 {
  属性 : 属性值;
}
伪类选择器的具体语法格式为 :伪类，这里一定不要忘记 :。
说明：CSS 允许在同一个选择器上同时编写多个伪类选择器。
伪类选择器的种类
CSS 版本从第一版本发展到第三版本，提供的伪类选择器的数量已经很庞大了。尤其 CSS3 版本新增了大量的伪类选择器。
```



#### 2、种类

```css
伪类选择器的数量这么多，为了更好地梳理伪类选择器，我们可以按照用途的不同分为如下 5 种类型：
动态伪类选择器：常与 <a> 元素配合使用，用来表示用户的某种行为状态。
目标伪类选择器：常与 <a> 元素配合使用，用来定位当前 HTML 页面中唯一一个目标元素。
元素状态伪类选择器：常与表单组件元素配合使用，用来表示表单组件的某种状态。
结构伪类选择器：常与 <table> 元素配合使用，利用 HTML 元素之间的关系定位目标元素。
否定伪类选择器：用来定位与指定选择器不匹配的 HTML 元素。

说明：以上 5 种类型的伪类选择器，除否定伪类选择器会在本小节进行讲解之外，其他 4 种类型会在后续对应章节中进行详细讲解。

否定伪类选择器的语法结构如下所示：
:not(selector) {
	属性 : 属性值;
}
否定伪类选择器的作用是用来定位不匹配 selector 选择器定位的 HTML 元素的元素。可能这句话看起来比较绕，不太好懂。

接下来我们来看一个示例，通过示例代码会更容易理解否定伪类选择器的用法：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>否定伪类选择器</title>
  <style>
    .fancy {
      text-shadow: 2px 2px 3px gold;
    }

    p:not(.fancy) {
      color: green;
    }

    body :not(p) {
      text-decoration: underline;
    }
  </style>
</head>

<body>
  <p>我是一个段落。</p>
  <p class="fancy">我好看极了！</p>
  <div>我不是一个段落。</div>
</body>

</html>

注意：
可以利用这个伪类提高规则的优先级。例如， #foo:not(#bar) 和 #foo 会匹配相同的元素。 但是前者的优先级更高。
:not(foo) 将匹配任何非 foo 元素，包括 html 和 body 元素。
这个选择器只会应用在一个元素上，你无法用它排除所有父元素。
```



### 六、伪元素选择器



#### 1、概述

```css
CSS 中伪元素选择器的用法与伪类选择器的用法类似，都是在指定 CSS 选择器增加关键字。但这两者的作用并不相同，伪类选择器是用来描述某个指定元素的状态信息，而伪元素选择器是用来描述某个指定元素的特定部分设定样式。

例如 ::first-line 伪元素可改变段落首行文字的样式，如下示例代码所示：
p::first-line {
  color: blue;
  text-transform: uppercase;
}

伪元素选择器的语法结构如下所示：
/* CSS3 语法 */
选择器::伪元素 {
  属性 : 属性值;
}
/* CSS2 过时语法 (仅用来支持 IE8) */
选择器:伪元素 {
  属性 : 属性值;
}

伪元素选择器只能和基本选择器配合使用，并且一个选择器只能使用一个伪元素选择器，如果要为一个选择器增加多个伪元素选择器需要分别编写。

注意：按照规范，应该使用双冒号（::）而不是单个冒号（:），以便区分伪类和伪元素。但是，由于旧版本的 W3C 规范并未对此进行特别区分，因此目前绝大多数的浏览器都同时支持使用这两种方式来表示伪元素。
```



#### 2、::before 和 ::after 伪元素

```css
::before 伪元素的作用是作为定位的 HTML 元素的第一个子级元素，::after 伪元素的作用是作为定位的 HTML 元素的最后一个子级元素。

如下示例代码展示了::before 伪元素的用法：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>::before伪元素选择器</title>
  <style>
    a::before {
      content: "♥";
    }
  </style>
</head>

<body>
  <a href="#">这是一个测试内容.</a>
</body>

</html>

如下示例代码展示了::after 伪元素的用法：
a::after {
  content: "→";
}

如上述两个示例代码所示，::before 伪元素和 ::after 伪元素通常会配合 content 属性来为该元素增加装饰内容。
```



#### 3、内容生成

```
content 属性用于在元素的 ::before 伪元素和 ::after 伪元素中插入内容。该属性具有的值如下所示：
none：不会产生伪类元素。
normal：::before 伪元素和 ::after 伪类元素中会被视为 none。
text：文本内容。
url：格式为 url()，指定一个外部资源（比如图片）。如果该资源或图片不能显示，它就会被忽略或显示一些占位。
注意：由 content 属性增加的内容默认情况下为内联元素（有关内联元素的内容会在后续章节中进行详细讲解）。
```



#### 4、::first-letter 伪元素

```css
::first-letter 伪元素的作用是为匹配元素的文本内容的第一个字母设置样式内容。 

如下示例代码展示了**::first-letter 伪元素**的用法：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>::first-letter伪元素选择器</title>
  <style>
    p::first-letter {
      font-size: 130%;
    }
  </style>
</head>

<body>
  <p>我是一个段落.</p>
</body>

</html>

::before 伪元素 和 content 属性结合起来会在 HTML 元素前面注入一些文本。因此，::first-letter 伪元素将会匹配到 content 文本的首字母。
注意：只有一小部分 CSS 属性可以在包含使用了 ::first-letter 伪元素选择器的 CSS 规则集声明块内运用，具体请参看 MDN 网站的 ::first-letter 伪元素文章。
```



#### 5、::first-line 伪元素

```css
::first-line 伪元素的作用是为匹配 HTML 元素的文本内容的第一行设置样式内容。 

如下示例代码展示了::first-line 伪元素的用法：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>::first-line伪元素选择器</title>
  <style>
    p::first-line {
      background-color: lightpink;
    }
  </style>
</head>

<body>
  <p>
    这原本是一个用来测试的内容.为了测试出真正想要的效果，这段内容就变得很长很长.
  </p>
</body>

</html>
```



#### 6、::selection 伪元素

```css
::selection 伪元素的作用是匹配用户在 HTML 页面选中的文本内容（比如使用鼠标或其他选择设备选中的部分）设置高亮效果。

如下示例代码展示了::selection 伪元素的用法：
p::selection {
	color: gold;
	background-color: red;
}

只有一小部分 CSS 属性可以用于::selection 伪元素：
color 属性
background-color 属性
cursor 属性
caret-color 属性
outline 属性
text-decoration 属性
text-emphasis-color 属性
text-shadow 属性
```



## 阶段 3：颜色与单位



### 一、颜色



#### 1、概述

```
色调：很接近通俗意义上的颜色。
是指图像的相对明暗程度，在彩色图像上表现为颜色

饱和度：是指颜色中灰色的含量。
饱和度最大时，颜色中灰色的含量为零；饱和度最小时，颜色基本就是灰色。也就是说，饱和度与灰色的占比是成反比的。（可以理解为，纯度越高,表现越鲜明,纯度较低,表现则较黯淡）

亮度：是指颜色中黑色的含量。
亮度最大时，颜色中黑色的含量为零。亮度最小时，颜色会变得非常暗。也就是说，亮度与黑色的占比是成反比的。

对比度：前景色与背景色之间的差异。
差异越大，对比度越大；否则反之。

Web 安全色：不需要担心颜色在不同硬件环境、操作系统和浏览器之间的差异Web 安全色目前基本具有 216 种颜色，其中色彩为 210 种，非色彩为 6 种。
```



#### 2、前景色与背景色

```css
简单来说，CSS中color属性表示前景色，background-color 属性表示背景色。

例：
before {
	color: red;
}

last{
	background-color:lightcoral;
}
```



#### 3、颜色值的类型

```
在上述无论是 color 属性还是 background-color 属性都需要应用到颜色值，这个颜色是一种标准 RGB 色彩空间（sRGB color space）的颜色。

颜色值可以通过如下 3 种类型进行定义：色彩关键字、RGB 色彩模式、HSL 色彩模式

注意：虽然 CSS 颜色值是被精确定义的，但在不同的输出设备上仍然有可能显示不一。
```



#### 3.1 色彩关键字

```
色彩关键字是一个不区分大小写的标识符，其表示一个具体的颜色，例如 red 表示红色、blue 表示蓝色等。

注意：除了 16 个 HTML 基本颜色之外，其他任何颜色都需要通过特定的计算程序转换（通过进制转换），最终导致不同浏览器呈现出的效果可能会不一致。
transparent 关键字表示一个完全透明的颜色，并且 transparent 是 background-color 属性的默认值。
```



#### 3.2 RGB 色彩模式

```css
RGB是一个简称，全称为 Red-Green-Blue，即红-绿-蓝。RGB 色彩模式是工业界的一种颜色标准，是通过对红、绿、蓝三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的。

在 CSS 中使用 RGB 色彩模式有如下 2 种方式：

十六进制符号 #RRGGBB 和 #RGB

#RRGGBB：是 # 符号后面编写 6 个十六进制字符（0-9，A-F）
#RGB：是 # 符号后面编写 3 个十六进制字符（0-9，A_F）

说明：当 #RRGGBB 格式中的两个 R 或 G 或 B 值相同时，就可以改写为 #RGB 格式。例如 #ff0033 可以改写成 #f03。

函数符 rgb(R, G, B)

这里的 R、G、B 的值可以使用 0 ~ 255 之间的值
这里的 R、G、B 的值也可以使用 0% ~ 100% 之间的值
说明： rgb(R,G,B) 的 255 和 100% 是一致的，相当于十六进制符号中的 FF。

如下示例代码展示了 RGB 模式的几种用法：

#p1 {
	background-color: #FFCC33;
}
#p2 {
	background-color: #FC3;
}
#p3 {
	background-color: rgb(255, 204, 51);
}
```



#### 3.3 HSL 色彩模式

```css
HSL是一个简称，全称为 Hue-Saturation-Lightness，即 色调-饱和度-亮度。HSL 色彩模式是一种将 RGB 色彩模型中的点在圆柱坐标系中的表示法。

在 CSS 中使用 HSL 色彩模式是通过 hsl(H, S, L) 函数实现的，具体含义如下：

H 表示色调，其值范围为 0 ~ 360 之间的一个角度。
S 表示饱和度，其值范围为 0% ~ 100% 之间的百分值。
L 表示亮度，其值使用百分值表示。0%表示黑色，50%表示标准色，100%表示白色。

如下示例代码展示了 HSL 模式的几种用法：

p {
	background-color: hsl(50, 33%, 25%);
}
```



#### 4、透明度

```css
在 CSS3 版本中新增了 opacity 属性用来设置 HTML 元素的透明度，该属性的值范围介于 0 ~ 1 之间。具体情况如下所示：

如果值为 0 或 0.0 则表示完全透明
如果值为 0.5 则表示半透明
如果值为 1 或 1.0 则表示不透明

如下示例代码所示展示了 opacity 属性的用法：

    div {
      background-color: lightcoral;
    }

    .light {
      opacity: 0.2;
    }

    .medium {
      opacity: 0.5;
    }

    .heavy {
      opacity: 0.9;
    }
  </style>
</head>

<body>
  <div class="light">这是一个测试内容.</div>
  <div class="medium">这又是一个测试内容.</div>
  <div class="heavy">这还是一个测试内容.</div>
</body>

CSS 中的透明度除了提供了 opacity 属性用法之外，还可以结合 RGB 模式和 HSL 模式共同使用。具体如下所示：

RGB 模式增加了 rgba(R,G,B,A) 函数，其中 A 为 alpha 表示透明度。
HSL 模式增加了 hsla(H,S,L,A) 函数，其中 A 为 alpha 表示透明度。
```



### 二、单位



#### 1、css 的值

```
CSS 中的值是一种定义允许子值集合的方法。例如我们现在可以使用色彩关键字、RGB 色彩模式或 HSL 色彩模式不同类型来描述颜色值。

在 CSS 中除了颜色值需要不同类型描述之外，比较常见的还有长度值也需要不同类型描述，例如 10px 或 50% 等。
```



#### 2、CSS 的单位

```
1、绝对长度单位：
绝对长度单位所描述的长度一般与任何其他因素是无关的。可以简单地理解为无论在什么情况下，这种的长度是固定、不变化的。在 HTML 页面中比较常用的绝对长度单位是像素（px）

cm	厘米	1cm = 96px/2.54
mm	毫米	1mm = 1/10th of 1cm
Q	四分之一毫米	1Q = 1/40th of 1cm
in	英寸	1in = 2.54cm = 96px
pc	十二点活字	1pc = 1/16th of 1in
pt	点	1pt = 1/72th of 1in
px	像素	1px = 1/96th of 1in


2、相对长度单位：
相对长度单位所描述的长度一般会具有一个明确的参考物，例如父级元素、根元素或视口大小等。使用相对长度单位更适用于现在越发复杂的终端设备的屏幕输出。（自适应）

em	父元素的字体大小
ex	字符“x”的高度
ch	数字“0”的宽度
rem	根元素的字体大小
lh	元素的line-height
vw	视窗宽度的1%
vh	视窗高度的1%
vmin	视窗较小尺寸的1%
vmax	视图大尺寸的1%
```



#### 3、像素值

```
像素的英文为 Pixel，简写为 px。像素是指在由一个数字序列表示的图像中的一个最小单位。

目前几乎所有的数码设备都具有分辨率的概念，这里的分辨率更多是指图像分辨率。该图像分辨率指的是图像中存储的信息量，毕竟典型的是以每英寸的像素数（PPI，pixel per inch）来衡量。

在屏幕尺寸固定不变的情况下，分辨率的值越大，每英寸的像素数（PPI）越大，单个像素所占的大小就越小。而一般屏幕显示的字体都是通过像素来设置的，例如 18px。
```



#### 4、百分比

```
总是将某个值作为参考，设置为这个参考值的百分比
```



#### 5、em 与 rem

```css
em 与 rem 都是相对单位，目前更多应用于移动端设备，例如手机、平板电脑的显示。具体的含义如下所示：

em：是相对于当前 HTML 元素的父级元素来进行设置。（理解为相对）
rem：是相对于当前 HTML 根元素（<html>）来进行设置。（理解为绝对）

上述 2 种单位都具有如下 3 种情况：

小于 1 时：表示相对于父级元素或根元素缩小。例如 0.5em 表示是父级元素的 0.5 倍，0.5rem 表示是根元素的 0.5 倍。
等于 1 时：表示与父级元素或根元素的大小保持一致。
大于 1 时：表示相对于父级元素或根元素放大。例如 1.5em 表示是父级元素的 1.5 倍，1.5rem 表示是根元素的 1.5 倍。

例：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>em与rem</title>
  <style>
    html {
      font-size: 16px;
    }

    .ems li {
      font-size: 1.3em;
    }

    .rems li {
      font-size: 1.3rem;
    }
  </style>
</head>

<body>
  <ul class="ems">
    <li>One</li>
    <li>Two</li>
    <li>Three
      <ul>
        <li>Three A</li>
        <li>Three B
          <ul>
            <li>Three B 2</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <ul class="rems">
    <li>One</li>
    <li>Two</li>
    <li>Three
      <ul>
        <li>Three A</li>
        <li>Three B
          <ul>
            <li>Three B 2</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</body>

</html>
```





## 阶段 4：HTML于CSS中的文本



### 一、结构化元素



#### 1、概述

```css
结构化元素就是指 HTML 元素中具有明确含义和作用的元素，例如 <p> 元素表示段落。

如下列表所示展示了部分 HTML 4.01 版本的结构化元素：

标题元素（<h1> ~ <h6>）
段落元素（<p>）
粗体元素（<b>）
斜体元素（<i>）
上标元素（<sup>）与下标元素（<sub>）
换行符（<br>）
水平线元素（<hr>）

如下列表所示展示了部分 HTML5 版本新增的结构化元素：
<article> 元素  表示文档、页面、应用或网站中的独立结构

<section> 元素  在 web 页面应用中，该元素也可以用于区域的章节描述。是区块级通用元素

<nav> 元素      专门用于菜单导航、链接导航的元素，是 navigator 的缩写。
<aside> 元素    定义页面主区域内容之外的内容（比如侧边栏）。


<header> 元素   页面主体上的头部， header 元素往往在一对 body 元素中。

<main> 元素     　main元素(<main>)呈现了文档<body>或应用的主体部分
主体部分由与文档直接相关，或者扩展于文档的中心主题、应用的主要功能部分的内容组成。这部分内容在文档中应当是独一无二的，不包含任何在一系列文档中重复的内容

<footer> 元素   述了文档的底部区域，一个页脚通常包含文档的作者，著作权信息，链接的使用条款，联系信息等。
```



#### 2.1、标题元素

```
HTML 标题元素具体是指 <h1> ~ <h6> 元素，其呈现了 6 个不同级别的标题，<h1> 元素级别最高，<h6> 元素级别最低。

默认呈现效果是 <h1> 元素字体最大，然后依次减小，<h6> 元素字体最小。
<h1> ~ <h6> 元素每个元素独占一行，也就是说，<h1> ~ <h6> 元素呈现垂直方向排列规则。

注意：对于搜索引擎抓取 HTML 页面的内容，<h1> 元素仅次于 <title> 元素。为了可以被搜索引擎抓取，建议一个 HTML 页面只包含一个 <h1> 元素。

不要为了减小标题的字体而使用低级别的标题， 而是通过使用 CSS font-size 属性实现。

避免跳过某级标题，始终要从 <h1> 元素开始，依次使用 <h2> 元素、<h3> 元素、… …
```



#### 2.2、段落元素

```
HTML <p> 元素表示一个段落，该元素通常呈现出当前段落的文本与其他段落的文本之间会以空白进行隔离。

注意：如果想要改变段落之间的间隔空间，建议使用 CSS margin 属性实现，而不是插入空的段落元素或者 <br> 元素。
```



#### 2.3、粗体元素

```
注意：如果不是出于语义目的而使用 <b> 元素，那么让文本显示粗体更好的方式是使用将 CSS 的 font-weight 属性设置为 bold。

<b> 元素的应用场景例如摘要中的关键字、评论中的产品名称，或其他典型的应该加粗显示的文字

例：<p>这是一个<b>段落</b>内容.</p>
```



#### 2.4、斜体元素

```css
浏览器运行解析 <i> 元素一般呈现的效果是斜体。

例：<p>这是一个<i>段落</i>内容.</p>
```



#### 2.5、上标与下标元素

```css
HTML <sup> 元素表示为上标元素，HTML <sub> 元素表示为下标元素。

例：
<p>你将在下学期学习到 E=MC<sup>2</sup> 公式。</p>
<p>水的化学成分叫做H<sub>2</sub>O。</p>
```



#### 2.6、换行符

```
HTML <br> 元素会在 HTML 页面中生成一个换行符。编写在 <br> 元素后的文本内容会呈现在第二行中。

例：<p>这是一个<br>段落内容.</p>
```



#### 2.7、水平线元素

```css
在较早版本的 HTML 中，<hr> 元素表示一个水平线，并且浏览器运行解析也是水平线效果。但目前 <hr> 元素被定义为语义上的，而不是表现上。

例：
<p>§1: 这是一个段落内容.</p>
<hr>
<p>§2: 这是另一个段落内容.</p>
```



#### 3.1、article 元素

```css
HTML <article> 元素用来定义 HTML 页面中的可独立分配或可复用结构，例如论坛的帖子、新闻网站的文章等。

如下示例代码展示了 <article> 元素的用法：
<article>
	<h1>前端开发</h1>
	<p>前端开发现在已经是软件开发领域中的主流。</p>
	<p><small>版权归属 *** 公司所有。</small></p>
</article>
```



#### 3.2、section  元素

```css
HTML <section> 元素用来定义 HTML 页面中的独立部分，该独立部分没有更具体的的语义元素来描述该元素。


<section>
  <h1>前端开发</h1>
  <p>前端开发现在已经是软件开发领域中的主流。</p>
</section>

注意：
一般通过是否包含一个标题元素（<h1> ~ <h6>）作为子级元素来识别每一个 <section> 元素。
如果元素内容可以分为几个部分的话，应该使用 <article> 元素 而不是 <section> 元素。

不要将 <section> 元素作为一个普通容器使用，这应该是 <div> 元素的用法。
```



#### 3.3、nav 元素

```css
HTML <nav> 元素用来定义 HTML 页面中的导航链接，比较常见的是菜单，目录和索引。

如下示例代码展示了 <nav> 元素的用法：

<nav>
	<ul>
		<li><a href="#">设计与构建静态网站</a></li>
		<li><a href="#">JavaScript基础核心语法</a></li>
		<li><a href="#">DOM编程艺术</a></li>
	</ul>
</nav>

提示：上述示例所示效果是 <ul> 列表元素的呈现效果，因为没有为 <nav> 元素设定任何 CSS 样式，默认是没有任何效果的。

关于 <nav> 元素在开发中的使用时需要注意如下要点：

并不是所有的链接都必须使用 <nav> 元素，该元素只用于将一些热门的链接放入导航栏。
一个 HTML 页面可能存在多个 <nav> 元素。
```



#### 3.3、aside元素

```css
元素用来定义一个和 HTML 页面中其余内容几乎无关的内容，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。通常比较常见的是侧边栏或者标注框。

如下示例代码展示了 <aside> 元素的用法：

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>aside元素</title>
  <style>
    aside {
      width: 40%;
      padding-left: .5rem;
      margin-left: .5rem;
      float: right;
      box-shadow: inset 5px 0 5px -5px #29627e;
      font-style: italic;
      color: #29627e;
    }
  </style>
</head>

<body>
  <article>
    <p>
      迪斯尼电影<cite>海的女儿</cite>（<cite>The Little Mermaid</cite>）于 1989 年首次登上银幕。
    </p>
    <aside>
      在首次发行期间，该片便收获了 8700 万美元的票房。
    </aside>
    <p>
      更多有关该电影的信息…
    </p>
  </article>
</body>

</html>

aside元素这些效果都是由css来决定的。
```



#### 3.4、header 元素

```css
HTML <header> 元素用来定义 HTML 页面中的具有引导和导航作用的内容，比较常见的是 Logo、搜索框、作者名称等。

如下示例代码展示了 <header> 元素的用法：

<header>
  <h1>主页标题</h1>
</header> 
<article>
  <header>
    <h2>前端开发</h2>
    <p>前端开发现在已经是软件开发领域中的主流。</p>
  </header>
  <p>这是第一个测试内容.</p>
  <p><a href="#">更多内容....</a></p>
</article>

说明：一个 HTML 页面并没有限制只能出现一个 <header> 元素，可以为每个内容区块添加一个 <header> 元素。
```



#### 3.5、main 元素

```css
HTML <main> 元素用来定义 HTML 页面中的主要内容。主内容区块指与页面标题或主要功能直接相关的内容。这部分内容在HTML页面中应当是独一无二的，不包含任何任何重复的内容。

如下示例代码展示了 <main> 元素的用法：

<main>
	<h2>Coder 比赛</h2>
	<p>目前正在紧张进行中...</p>
</main>

注意：
一个 HTML 页面中只能出现一个 <main> 元素。
<mian> 元素不能出现在 <article> 元素、<aside> 元素、<nav> 元素、<header> 元素和 <footer> 元素的内部。
```



#### 3.6、footer 元素

```css
HTML <footer> 元素用来定义 HTML 元素中的一个章节内容或根元素的页脚。一个页脚通常包含该章节作者、版权数据或文档相关链接等信息。

如下示例代码展示了 <footer> 元素的用法：

<footer>
	<ul>
		<li>版权信息</li>
		<li>站点地图</li>
		<li>联系方式</li>
	</ul>
</footer>

关于 <footer> 元素在开发中的使用时需要注意 <footer>元素中的作者信息应该包含在 <address> 元素中。
```



#### 4、空白

```
当浏览器运行并解析 HTML 页面时，遇到两个或两个以上的连续空格时，只将其显示为一个空格效果。这种特性叫做白色空间折叠。
```



#### 5、转义字符

```
原义字符	描述	转义字符
    空格	&nbsp;
    <	小于号	&lt;
    >	大于号	&gt;
    &	和号	&amp;
    "	引号	&quot;
    ©	版权（copyright）	&copy;
    ®	注册商标	&reg;
    ™	商标	&trade;
    ×	乘号	&times;
    ÷	除号	&divide;
```



### 二、语义化元素



#### 1、概念

```css
语义化元素与结构化元素类似，都是具有具体含义的元素，区别在于语义化元素更多定义一个单词、一行内容的语义或样式。

如下列表所示展示了部分语义化元素：

加粗元素（<strong>）
强调元素（<em>）
引用元素（<blockquote> 和 <q>）
引文元素（<cite>）
定义元素（<dfn>）
地址元素（<address>）
内容修改元素（<del> 和 <ins>）
```



#### 2.1、加粗元素

```css
HTML <strong> 元素用来定义 HTML 页面中的十分重要的文本内容。浏览器运行 HTML 页面默认呈现的是粗体效果。

如下示例代码展示了 <strong> 元素的用法：

<p><strong>说明：</strong>HTML声明并不是一个HTML元素。</p>
```



#### 2.2、强调元素

```css
HTML <em> 元素用来定义 HTML 页面中的需要用户着重阅读的文本内容。浏览器运行 HTML 页面默认呈现的是斜体效果。

如下示例代码展示了 <em> 元素的用法：

<p>在HTML中，有些内容是需要<em>着重</em>来阅读的.</p>
```



#### 2.3、引用元素

```css
HTML <blockquote> 元素用来定义 HTML 页面中的标记较长的引用内容，一般浏览器解析后会对其进行缩进。HTML <q> 元素用来定义 HTML 页面中的较短的引用内容，浏览器解析后会在其两侧使用引号包裹。

如下示例代码展示了 <blockquote> 元素和 <q> 元素的用法：

<blockquote>
  <p>
    这是一段用来引用的文本内容.
  </p>
</blockquote>
<p>说明：<q>声明并不是一个HTML元素。</q></p>
```



#### 2.4、引文元素

```css
HTML <cite> 元素用来定义 HTML 页面中的对一个作品的引用，浏览器解析后会呈现斜体效果。该元素必须包含引用作品的符合简写格式的标题或者 URL，可能是一个根据添加引用元数据的约定的简写形式。

如下示例代码展示了 <cite> 元素的用法：

<p>更多信息可以阅读<cite>[ISO-0000]</cite>.</p>
```



#### 2.5、定义元素

```css
HTML <dfn> 元素用来定义 HTML 页面中的术语。有些浏览器会将 <dfn> 元素解析后呈现为斜体，但 Safari 和 Chrome 浏览器则不会改变其样式。

如下示例代码展示了 <dfn> 元素的用法：

<p>
  <dfn id="def-internet">The Internet</dfn> is a global system of interconnected networks that use the Internet Protocol Suite (TCP/IP) to serve billions of users worldwide.
</p>
```



#### 2.6、地址元素

```css
HTML <address> 元素用来定义 HTML 页面中提供了某个人或某个组织的联系信息，浏览器解析后会呈现为斜体效果。

如下示例代码展示了 <address> 元素的用法：

<address>
  <a href="mailto:jim@rock.com">jim@rock.com</a><br>
  <a href="tel:+13115552368">(311) 555-2368</a>
</address>
```



#### 2.7、内容修改元素

```css
内容修改元素可以标示出某个文本被更改过的部分。其中，HTML <del> 元素用来定义 HTML 页面中删除的文字内容，HTML <ins> 元素用来定义 HTML 页面中插入的文字内容。

如下示例代码展示了 <del> 元素和 <ins> 元素的用法：

<p>前端好<del>难</del><ins>容易</ins>学习啊</p>
```



#### 3、结构和语义区别

```
在 HTML 的结构化元素和语义化元素中存在大量地浏览器解析呈现效果类似的元素，为什么会出现这样的现象呢？我们可以理解为这是 HTML 发展过程中的历史原因。

但这样解释未免过于牵强。从 HTML4 版本开始，对 HTML 元素更强调其语义化，就是具体的含义。这样就划分出两种状态：

逻辑状态：将内容和样式进行分离。

也就是说，HTML 元素只体现其具体含义和作用，而呈现样式则交给 CSS 样式完成。例如 <strong> 元素表示该文本内容是非常重要的，但该元素中的文本内容可以通过 CSS 设定为红色字体、不同的背景颜色等。

物理状态：并不区分内容和样式，也就是说没有将内容和样式进行分离。例如只是将某个元素中的文本内容作加粗处理等。
```



### 三、字体样式



#### 1、分类

```
字体样式：直接应用于字体的属性，一般是指 font 属性以及与 font 相关的 CSS 属性。例如设置字体大小、粗细等内容。

文本样式：应用于文本之间的间距以及布局相关的属性，例如设置行间距、对齐方式、缩进等内容。
```



#### 2.1、字体样式

```css
CSS font-family 属性通过一个字体名或字体族名组成的列表来设置 HTML 页面中的字体

font-family 属性
font-size 属性
font-weight 属性
font-style 属性
```



#### 2.2、font-family

```css
font-family 属性的值有 2 种方式进行设置，具体如下：

1、设置一个字体名或字体族名：
 font-family 属性的值也可以划分为 2 种：
字体族的名字。例如 Times 和 Helvetica 都是字体族名。

字体族名必须是有效的。具体可以划分成如下几种情况：

如果字体族名是一个或多个合法标识串构成的话，是可以没有引号的。（在没有带引号的字体族名的开头是不能使用标点符号字符和数字字符的。）

如果字体族名是一个或多个非合法标识串构成的话，是需要使用引号的。

通用字体族名称，这是一种备选机制。
通用字体族名是用来在指定的字体不可用时给出较好的字体。通用字体族名都是关键字，所以不可以加引号。通用字体族名由如下几种：

serif：带衬线字体，笔画结尾有特殊的装饰线或衬线。
sans-serif：无衬线字体，即笔画结尾是平滑的字体。
monospace：等宽字体，即字体中每个字宽度相同。
cursive：草书字体。这种字体有的有连笔，有的还有特殊的斜体效果。
fantasy：主要是那些具有特殊艺术效果的字体。
说明：并不推荐只为 font-family 属性设置一个值。因为这样的话，浏览器运行 HTML 页面时很可能找不到这种字体或字体族，从而导致字体不能按照预期的效果进行展示。

例：
p {
  font-family: 宋体;
}

2、设置多个字体名或字体族名

font-family 属性的值除了可以设置一个值之外，还可以同时设置多个字体名或字体族名。在开发中也比较推荐这种方式。

为 font-family 属性设置多个值时，值之间需要使用逗号进行分隔。浏览器会选择列表中第一个该计算机上有安装的字体。

如下示例代码展示了 font-family 属性设置了多个值的用法：

p {
  font-family: "Gill Sans Extrabold", Helvetica, sans-serif;
}
```



#### 2.3、font-size

```css
CSS font-size 属性用来设置 HTML 页面的字体大小。如下示例代码所示展示了了 font-size 属性的用法：

p {
  font-size: 24px;
}

font-size 属性的值可以通过如下 4 种方式进行设置：

绝对大小值：xx-small、x-small、small、medium、large、x-large 和 xx-large 等值。
（这一系列的绝对大小关键字是相对于用户的默认字体大小（medium）定义的。）

相对大小值：larger 和 smaller 两个值。
（该相对大小值是相对于父级元素的字体大小为参考，使用与绝对大小关键字的相近缩放比率。）

长度值：px、em、rem 或 ex 等值。
（当大小值为 em 或 ex 值时，值一旦改变可能会影响其他元素的字体大小。）

百分比值：该值是相对于父级元素的字体大小的百分比。


关于标题元素在开发中的使用时需要注意如下要点：

建议最好使用用户默认字体大小的相对大小，避免使用除了 em 或 ex 的绝对大小单位。
如果一定要使用绝对大小的话，px 是众多单位中最好的选择。
```



#### 2.4、font-weight

```
CSS font-weight 属性用来设置 HTML 页面中字体的粗细程度。如下示例代码所示展示了 font-weight 属性的用法：

p {
  font-weight: bolder;
}

font-weight 属性的值可以通过如下 3 种方式进行设置：

绝对值：normal 和 bold 两个值。
（normal 与数字值 400 等价，bold 与数字值 700 等价。）

相对值：lighter 和 bolder 两个值。
lighter：比从父元素继承来的值更细（处在字体可行的粗细值范围内）。
bolder：比从父元素继承来的值更粗 （处在字体可行的粗细值范围内）。
数字值：介于 100 ~ 900 之间的值。
注意：一些字体只提供 normal 和 bold 两种值。
```



#### 2.5、font-style

```css
CSS font-style 属性用来设置 font-family 字体下的 italic 或 oblique 样式。

注意：不是所有的字体都有确切的 oblique 和 italic 字形。即便如此，浏览器也会通过使用现有的字形来模拟所缺少的字形。

如下示例代码所示展示了 font-style 属性的用法：

.italic {
  font-style: italic;
}

.oblique {
  font-style: oblique;
}
```



#### 3、  font 属性

```css
CSS font 属性是用来作为 font-family、font-size、font-weight、font-style、font-variant 和 line-height 属性的简写形式，或将 HTML 元素的字体设置为系统字体。

作为简写形式
如果将 font 属性作为简写形式的话，该属性必须包含 font-family 和 font-size 属性的值。而且指定相关属性的值时，需要注意如下要点：

font-style、font-variant 和 font-weight 属性必须定义在 font-size 属性之前。
line-height 属性必须定义在 font-size 属性后面，由 / 分隔，例如 16px/3。
font-family 属性必须最后定义。
系统字体
如果将 font 属性的值指定为系统关键字的话，必须是如下系统关键字之一：

caption：用于标题控件（如按钮，下拉列表等）的系统字体。
icon：用于标签图标的系统字体。
menu：菜单中（如下拉菜单和菜单列表）使用的系统字体。
message-box：用于对话框的系统字体。
small-caption：用于小标题控件的系统字体。
status-bar：用于窗口状态栏的系统字体。
如下示例代码所示展示了 font 属性的用法：

.p1 {
  font: 12px/14px sans-serif;
}

.p2 {
  font: 80% sans-serif;
}

.p3 {
  font: bold italic large serif;
}

.p4 {
  font: status-bar;
}
```



#### 4、嵌入 Web 字体

```css
@font-face 是 CSS 的 @规则 中的一种，用来为 HTML 页面引入在线字体。通过 @font-face 我们可以自己来准备字体文件，从而可以消除对用户电脑字体的依赖。

提示：@规则是 CSS 中的一个语句，以 @ 符号开始，后面是标识符，并包括直到下一个分号的所有内容。CSS 提供了很多 @规则，不同的规则具有不同的语法以及不同的作用。具体可以参考 MDN 网站的有关@规则文章。

@font-face 具体语法如下所示：

@font-face {
  [ font-family: <family-name>; ] ||
  [ src: <src>; ] ||
  [ unicode-range: <unicode-range>; ] ||
  [ font-variant: <font-variant>; ] ||
  [ font-feature-settings: <font-feature-settings>; ] ||
  [ font-variation-settings: <font-variation-settings>; ] ||
  [ font-stretch: <font-stretch>; ] ||
  [ font-weight: <font-weight>; ] ||
  [ font-style: <font-style>; ]
}
上述语法结构具体内容如下：

font-family：所指定的字体名字将会被用于 font 或 font-family 属性。
src：通过 url() 函数指定远程字体文件的位置，或者通过 local() 函数指定用户的本地计算机上的字体。
font-variant：同 font-variant 属性。
font-stretch：同 font-stretch 属性。
font-weight：同 font-weight 属性。
font-style：同 font-style 属性。
如下示例代码所示展示了 font 属性的用法：

@font-face {
  font-family: "Alibaba PuHuiTi";
  src: url("/fonts/Alibaba-PuHuiTi-Regular.ttf");
}

body {
  font-family: "Alibaba PuHuiTi", serif
}

附上两个在线字体转换格式的网站：
font2web：http://www.font2web.com/
freefontconverter：http://www.freefontconverter.com/
```



### 四、文本样式



#### 1、作用

```css
CSS 中的文本样式是用来定义 HTML 页面中文本的布局，例如设置行间距、对齐方式、缩进等内容。如下列表所示展示了部分文本样式的相关 CSS 属性：

文本装饰（text-decoration）
行间距（line-height）
字母间距（letter-spacing）与单词间距（word-spacing）
水平对齐方式（text-align）
垂直对齐方式（vertical-align）
文本缩进（text-indent）
文本阴影（text-shadow）
文本换行（word-wrap 和 word-break）
处理空白（white-space）
```



#### 2.1、文本装饰

```
  CSS text-decoration 属性用来设置 HTML 页面中文本排版（下划线、顶划线、删除线或者闪烁）。
  text-decoration 属性是一个简写属性，并且可以使用普通属性三个值中的任何一个。普通属性如下所示：
  
  - text-decoration-line属性：用于设置元素中的文本的修饰类型。
  - text-decoration-color属性：用于设置文本修饰线的颜色。
  - text-decoration-style属性：用于设置由 text-decoration-line 设定的的样式。
```

```css
如下示例代码展示了 text-decoration 的 3 个普通属性的用法：

p {
  text-decoration-color: lightcoral;
  text-decoration-line: underline;
  text-decoration-style: solid;
}

text-decoration 属性会延伸到后代元素。这意味着如果祖先元素指定了文本修饰属性，后代元素则不能将其删除。如下示例代码所示：

    p {
      text-decoration: underline;
    }

    em {
      text-decoration: none;
    }

  <p>这是一个用来<em>测试</em>的内容.</p>
```



#### 2.2、行间距

```css
CSS line-height 属性用来设置 HTML 页面中多行元素之间的空间量，例如多行文本的间距。

如下图所示，红色线是顶线、紫色线是中线、绿色线是基线、黄色线是底线，在本小节后面中会讲解到的 vertical-align 属性的 top、middle、baseline、bottom 指的就是这 4 条线。
```

![](http://changetm.oss-cn-beijing.aliyuncs.com/Temp/0d79410c-d356-44e5-bc08-a9787840fe69.png)

```
行间距：也称为行高指的是两行文本内容中基线的距离，即两条绿色线之间的距离。也就是上图中的 2、3 和 4 的区域。

行距：指的是上一行的底线到下一行的顶线之间的距离，即上一行的黄色线到下一行的红色线之间的距离，也就是3的区域

字体大小：是顶线到底线的距离，即红色线到黄色线之间的距离。
```

```css
CSS line-height 属性的值允许指定如下 4 种类型：

normal 关键字：标准值，该值取决于用户电脑。一般情况下，浏览器使用的默认值为 1.2。

数字值：line-height 属性的最终的效果值是该数字值乘以该元素的字体大小（font-size 属性值）。

长度值：该值可以使用的单位请参考《单位》一节内容。如果使用 em 单位的可能会产生不确定的效果。（相对值）

百分比值：line-height 属性的最终的效果值是该百分比值乘以该元素的字体大小（font-size 属性值）。
line-height 属性设置值时，建议使用数字值。因为使用数字值时，不会在继承时产生不确定的结果。

如下示例代码展示了 line-height 属性的用法：

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>行间距</title>
  <style>
    .div1 {
      line-height: 1.2;
      font-size: 10pt;
    }

    /* 无单位数值 number/unitless */
    .div2 {
      line-height: 1.2em;
      font-size: 10pt;
    }

    /* 长度 length */
    .div3 {
      line-height: 120%;
      font-size: 10pt;
    }

    /* 百分比 percentage */
    .div4 {
      font: 10pt/1.2 Georgia, "Bitstream Charter", serif;
    }
  </style>
</head>

<body>
  <div class="div1">这是一段用于测试的内容.</div>
  <div class="div2">这是一段用于测试的内容.</div>
  <div class="div3">这是一段用于测试的内容.</div>
  <div class="div4">这是一段用于测试的内容.</div>
</body>
```



#### 2.3、字母间距

```css
在 CSS 中 letter-spacing 属性用来设置 HTML 页面中字母之间的距离。
在英文中是可以分为单词和字符的，但在中文中只有文字，中文中的文字就相当于英文的字符，所以 letter-spacing 属性可以适用于中文环境。

letter-spacing 属性的值具有 2 种类型，如下所示：

normal：该值是按照当前字体的正常间距确定的。
长度值：指定文字间的间距以替代默认间距，可以是负值。
如下示例代码展示了 letter-spacing 属性的用法：

.first-example {
  letter-spacing: 0.4em;
}

.second-example {
  letter-spacing: 1em;
}

.third-example {
  letter-spacing: -0.05em;
}

.fourth-example {
  letter-spacing: 6px;
}
```



#### 2.4、单词间距

```css
CSS word-spacing 属性用来设置 HTML 页面中标签之间或单词之间的距离，该属性对英文是有效的，但对中文是无效的。

word-spacing 属性的值具有 3 种类型，如下所示：

normal：该值是按照当前字体的正常间距确定的。
长度值：指定单词间的间距以替代默认间距。
百分比值：指定单词之间的间距以替代默认间距的百分比。
如下示例代码展示了 word-spacing 属性的用法：

.first-example {
  word-spacing: 15px;
}

.second-example {
  word-spacing: 5em;
}
```



#### 2.5、水平对齐方式

```css
CSS text-align 属性用来设置 HTML 页面中文本内容相对于其所在元素在水平方式的对齐方式。值得注意的是，text-align 属性并不能设置 HTML 元素本身在水平方向的对齐，而是设置 HTML 元素内部的文本内容在其元素内水平方向的对齐。

如下示例代码展示了 text-align 属性的用法：

.example {
  text-align: right;
}

text-align 属性的值具有 7 种类型，如下所示：

start：如果内容方向是左至右的话则等于 left，反之则为 right。
end：如果内容方向是左至右的话则等于 right，反之则为 left。
left：行内内容向左侧边对齐。
right：行内内容向右侧边对齐。
center：行内内容居中。
justify：文字向两侧对齐，对最后一行无效。
justify-all：和 justify 一致，但是强制使最后一行两端对齐。
```



#### 2.6、垂直对齐方式

```css
CSS vertical-align 属性用来设置 HTML 页面中内联元素或表格单元格元素在垂直方向上的对齐方式。

vertical-align 属性可以被应用于 2 种环境：

设置某个内联元素的盒子模型与该内联元素的父级容器元素的垂直对齐方式。
设置表格中某个单元格中内容的垂直对齐方式。
注意：
vertical-align 属性只针对内联元素和表单单元格有效，对块级元素是无效的。

vertical-align 属性的值根据 2 种应用环境会有所不同：

应用于内联元素的值
相对于父级元素的值
baseline：使元素的基线与父元素的基线对齐。
sub：使元素的基线与父元素的下标基线对齐。
super：使元素的基线与父元素的上标基线对齐。
text-top：使元素的顶部与父元素的字体顶部对齐。
text-bottom：使元素的底部与父元素的字体底部对齐。
middle：使元素的中部与父元素的基线加上父元素 x-height 的一半对齐。
相对于行的值
top：使元素及其后代元素的顶部与整行的顶部对齐。
bottom：使元素及其后代元素的底部与整行的底部对齐。
应用于表单单元格的值
baseline：使单元格的基线，与该行中所有以基线对齐的其它单元格的基线对齐。
top：使单元格内边距的上边缘与该行顶部对齐。
middle：使单元格内边距盒模型在该行内居中对齐。
bottom：使单元格内边距的下边缘与该行底部对齐。
如下示例代码展示了 vertical-align 属性的用法：

img.top {
  vertical-align: text-top;
}

img.bottom {
  vertical-align: text-bottom;
}

img.middle {
  vertical-align: middle;
}
```



#### 2.7、文本缩进

```css
CSS text-indent 属性用来设置 HTML 页面中块级元素首行文本内容之前的缩进量。如下示例代码展示了 text-indent 属性的用法：

.example {
  text-indent: 5em;
}

text-align 属性的值具有 4 种类型，如下所示：

长度值：允许使用负值。
百分比值：使用所在块级元素的宽度的百分比作为缩进。
each-line：文本缩进会影响第一行，以及使用 <br> 元素强制断行后的第一行。
hanging：该值会对所有的行进行反转缩进：除了第一行之外的所有的行都会被缩进，看起来就像第一行设置了一个负的缩进值。
```



#### 2.8、文本阴影

```css
CSS text-shadow 属性用来设置 HTML 页面中文本内容的阴影。该属性的语法结构如下所示：

selector {
	text-shadow: color offset-x offet-y blur-raduis;
}
上述语法结构中的具体值的含义如下：

color：可选项，设置文本内容的阴影颜色。

offset-x：必选项，设置文本内容的阴影在水平方向的偏移量。

如果值小于 0 的话，则表示向左偏移。
如果值等于 0 的话，则表示水平方向不发生任何偏移。
如果值大于 0 的话，则表示向右偏移。
offset-y：必选项，设置文本内容的阴影在垂直方向的偏移量。

如果值小于 0 的话，则表示向上偏移。
如果值等于 0 的话，则表示垂直方向不发生任何偏移。
如果值大于 0 的话，则表示向下偏移。
blur-raduis：可选项，设置文本内容的阴影模糊半径。

如果没有指定，则默认为 0。值越大，模糊半径越大，阴影也就越大越淡。

设置单一阴影
text-shadow 属性可以用来为 HTML 页面中的文本内容设置单一的阴影效果。如下示例代码展示了单一阴影效果：

.example {
  text-shadow: red 0 -2px;
}

设置多重阴影
text-shadow 属性也可以用来为 HTML 页面中的文本内容设置多重阴影效果。设置多重阴影效果需要设置多个阴影值，这些值之间需要使用逗号（,）分隔。

如下示例代码展示了多重阴影效果：

.example {
  text-shadow: 1px 1px 2px black, 0 0 1em blue, 0 0 0.2em blue;

当通过 text-shadow 属性为文本内容设置多重阴影时，阴影的应用顺序是从左到右的，第一个指定的阴影在顶部。
```



#### 2.9、文本换行

```css
浏览器自身带有文本换行的功能。在浏览器显示文本内容时，让文本和浏览器的右端自动实现换行。具体的情况如下所示：

对于西方文本，浏览器会在半角空格或连字符的地方自动换行。
对于中文文本，可以在任何文字后面换行。通常标点符号以及前面的文字作为整体统一换行。
在 CSS 中可以用来设置文本换行效果的属性存在 2 个：
word-wrap 属性
word-break 属性
```

```css
word-wrap 属性属于微软的一个私有属性，在 CSS3 的文本规范中被重命名为 overflow-wrap。word-wrap 作为 overflow-wrap 的别名。

CSS overflow-wrap 属性用来设置 HTML 页面中当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。

overflow-wrap 属性的值具有如下 2 种：

normal：表示在正常的单词结束处换行。

break-word：表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。
如下示例代码展示了使用 overflow-wrap 属性前后的比对效果：

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>overflow-wrap属性</title>
  <style>
    .example {
      width: 13em;
      background: gold;
    }

    .break {
      overflow-wrap: break-word;
    }
  </style>
</head>

<body>
  <p class="example">
    FStrPrivFinÄndG (Gesetz zur Änderung des Fernstraßenbauprivatfinanzierungsgesetzes und straßenverkehrsrechtlicher
    Vorschriften)
  </p>
  <p class="example break">
    FStrPrivFinÄndG (Gesetz zur Änderung des Fernstraßenbauprivatfinanzierungsgesetzes und straßenverkehrsrechtlicher
    Vorschriften)
  </p>
</body>

</html>
```

```css
word-break 属性
CSS word-break 属性用来设置 HTML 页面中文本内容自动换行的处理方式。通过具体的属性值设置，可以告知浏览器实现任意位置的换行。

word-break 属性的值具有如下 3 种：

normal：使用默认的断行规则。
break-all：对于除中文、日文和韩文外的文本内容，设置可以在任意字符间断行。
keep-all：中文、日文和韩文的文本内容不断行，其他语言的文本内容等同于 normal。
```

![image-20200106191635032](C:\Users\10796\AppData\Roaming\Typora\typora-user-images\image-20200106191635032.png)



#### 3、处理空白

```css
CSS white-space 属性用来设置如何处理 HTML 元素中的空白。如下示例代码展示了 white-spaces 属性用法的基础页面：

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>white-space属性</title>
  <style>
    #example-element {
      width: 16rem;
    }

    #example-element p {
      background-color: #eee;
      padding: .75rem;
      text-align: left;
    }

    .example {
      /* 设置 white-space 属性不同的值用于测试效果 */
    }
  </style>
</head>

<body>
  <div id="example-element" class="example">
    <p>But ere she from the church-door stepped
      She smiled and told us why:
      'It was a wicked woman's curse,'
      Quoth she, 'and what care I?'

      She smiled, and smiled, and passed it off
      Ere from the door she stept—</p>
  </div>
</body>

</html>

该属性的值具有如下 6 种类型：
normal：默认值，连续的空白符会被合并，换行符会被当作空白符来处理。填充内联元素的盒子模型时，必要的话会换行。

nowrap：和 normal 一样，连续的空白符会被合并。但文本内的换行无效。

nowrap：和 normal 一样，连续的空白符会被合并。但文本内的换行无效。

pre：连续的空白符会被保留。在遇到换行符或者 <br> 元素时才会换行。

pre：连续的空白符会被保留。在遇到换行符或者 <br> 元素时才会换行。

pre-line：连续的空白符会被合并。在遇到换行符或者 <br> 元素，或者需要为了填充内联元素的盒子模型时会换行。

break-spaces：与 pre-wrap 的行为相同，除了如下情况：

任何保留的空白序列总是占用空间，包括在行尾。
每个保留的空格字符后都存在换行机会，包括空格字符之间。
这样保留的空间占用空间而不会挂起，从而影响盒子的固有尺寸。

如下列表总结了各种 white-space 属性值的行为：

换行符	空格和制表符	文字转行
normal	合并	合并	转行
nowrap	合并	合并	不转行
pre	保留	保留	不转行
pre-wrap	保留	保留	转行
pre-line	保留	合并	转行
break-spaces	保留	保留	转行
```





## 阶段 5：链接与图像



### 一、链接



#### 1、概述

```
HTML 页面使用超链接与网络上的另一个 HTML 页面相连。几乎可以在所有的网页中找到链接，点击链接可以从一张页面跳转到另一张页面。

超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，可以点击这些内容来跳转到新的 HTML 页面或者当前 HTML 页面中的某个部分。

当把鼠标指针移动到 HTML 页面中的某个链接上时，箭头默认会变为一只小手的样式。
```



#### 2、链接元素

```css
HTML <a> 元素用来定义 HTML 页面中的超链接，超链接可以创建跳转到其他 HTML 页面、文件、同一 HTML 页面内的另一个指定位置、电子邮件地址或任何其他 URL 的超链接。

使用 <a> 元素时，需要设置 href 属性，该属性的作用是用来设置跳转到指定 HTML 页面或其他链接的地址。如果使用 <a> 元素时没有设置 href 属性的话，那么 <a> 元素将是无效的。

如下示例代码展示了定义 <a> 元素时没有设置 href 属性的情况：

<a>这是一个没有设置href属性的a元素.</a>

注意：如果没有使用 href 属性，则不能使用 hreflang、media、rel、target 以及 type 属性。


如下示例代码展示了 <a> 元素的基本用法：

<a href="https://www.baidu.com">这是一个普通的链接元素.</a>
```



#### 3、绝对路径

实质：就是从根目录开始

```
绝对路径就是指完整的描述目标文件位置的路径。简单来说，绝对路径就是无论你当前的位置在哪，找到目标文件的路径是不变的

无论是本地电脑也好，还是网络上的网站也好，系统盘符或者网络协议后面的 // 都称为根目录。也就是说，绝对路径是从根目录开始查找目标文件的路径。

绝地路径的优点如下所示：

防止网站被恶意抄袭。使用绝对路径，如果有人抄袭采集你的网站内容，里面的链接还会指向你的网站。
网页被移动位置，里面的链接还是指向正确的 URL。

绝对路径的缺点如下所示：
除非链接是动态插入的，不然没办法在测试服务器上进行测试。因为里面的链接将直接指向真正的域名 URL，而不是测试服务器中的 URL。
除非链接是动态插入的，不然移动内容页面将很困难。因为内容页面位置发生变化，在其他页面上的链接却可能无法跟着变化，还指向原来的已经硬编码的绝对路径。
```



#### 4、相对路径

实质：相对于另外一个固定位置，而决定自己的位置

​			. 当前目录

​			.. 上级目录

```
相对路径就是指由这个文件所在的路径引起的跟其它文件（或文件夹）的路径关系。简单来说，相对路径和你所在的位置是有关系的，你所在位置的不同会导致相对路径也会不同。

例如我们的本地电脑中的某个文件，如果我们想要找到它的话，可以通过相对路径的方式，如下所示：



相对路径的情况，可以总结如下所示：

如果当前页面与目标页面或资源处在同一个目录中的话，相对路径就是目标文件名称。
如果当前页面在目标页面或资源的父级目录中的话，相对路径就是目录名称/目标文件名称。
如果当前页面在目标页面或资源的子级目录中的话，相对路径就是../目标文件名称。
如果当前页面的父级目录与目标页面或资源的父级目录处在同一个目录中的话，相对路径就是../目录名称/目标文件名称。
```



#### 5、打开方式

实质：跳转链接

```css
当使用 <a> 元素设置跳转到指定的 HTML 页面或文件时，默认情况下是在当前浏览器页签中直接打开目标 HTML 页面或文件。

通过 <a> 元素的 target 属性可以用来设置以什么方式打开目标资源，该属性的值有如下 2 种常见的值：

_self：默认值，表示目标链接在当前页面打开。
_blank：表示目标链接在新窗口打开。
如下示例代码展示了在一个新的浏览器页签中打开目标资源：

<a target="_blank" href="https://www.baidu.com">这是一个普通的链接元素.</a>
```



#### 6、Email 链接

```css
HTML <a> 元素可以实现调用用户电脑的 Email 程序并自动填写指定 Email 地址来写 Email 的功能。该功能常出现在网站首页底部的联系我们。

注意：如果用户电脑中并没有安装任何 Email 程序的话，则会导致调用失败。

想要实现这种功能只需要在 <a> 元素的 href 属性值中增加 mailTo: 前缀即可，即格式为 mailTo: + Email地址。

如下示例代码展示了 <a> 元素实现调用 Email 程序的功能：

<a target="_blank" href="mailto:front-end@example.com">联系我们</a>
```



#### 7、锚点

实质：通过id选择器，设定点击文本的跳转位置，所对应的元素

```css
HTML <a> 元素的 href 属性与当前 HTML 页面中其他元素的 id 属性值配合使用，可以实现锚点功能。该功能常出现展示文档的网站或者电商网站的楼层效果。

所谓锚点，就是指当点击链接文本时，跳转到当前页面的指定元素位置。想要实现这种锚点功能只需要在 <a> 元素的 href 属性值设置为 #ID属性值 的格式即可。

如下示例代码展示了 <a> 元素实现锚点功能：

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>锚点功能</title>
  <style>
    ul {
      margin-bottom: 600px;
    }
  </style>
</head>

<body>
  <ul>
    <li><a href="#second">第二章</a></li>
  </ul>
  <h2 id="second">什么是前端开发</h2>
  <p>前端开发已经肯定不是你认为的页面开发了，具体能干嘛、要干嘛这是你要学习的。</p>
</body>

</html>
```



#### 8、下载功能

```css
在 HTML5 版本中为 <a> 元素新增了 download 属性，该属性用于设置下载文件的 URL。用户点击链接时，浏览器会提示用户将其保存到本地。

提示：如果 download 属性只有一个值的话，它将在保存提示中作为预定义的文件名。

如下示例代码展示了通过 <a> 元素的 download 属性实现下载功能：

<a href="files/fonts.zip" download="fonts.zip">下载文件</a>
如上述示例，用户在点击此链接时，浏览器会自动下载该文件。
```



### 二、伪类选择器 <a.>



#### 1、动态伪类选择器

实质：添加指定元素的动态状态或特性

```css
动态伪类选择器可以划分为链接中锚点的伪类选择器和用户行为的伪类选择器，具体如下表所示：

伪类选择器	类型	描述
e:link	链接锚点伪类选择器	匹配的 e 元素，定义了超链接并且未被访问过
e:visited	链接锚点伪类选择器	匹配的 e 元素，定义了超链接并且已被访问过
e:active	用户行为伪类选择器	匹配的 e 元素，定义了超链接并且被激活
e:hover	用户行为伪类选择器	匹配的e元素，定义了超链接并且用户鼠标悬停在链接文本内容上
e:focus	用户行为伪类选择器	匹配的 e 元素，定义了超链接并且获得焦点
如下示例代码展示了动态伪类选择器在 <a> 元素上应用：

a:link { color: #FF0000 } 		/* 未访问的链接 */
a:visited { color: #00FF00 }	/* 已访问的链接 */
a:hover { color: #FF00FF }		/* 鼠标移动到链接上 */
a:active { color: #0000FF }		/* 选定的链接 */
```

```css
动态伪类选择器并不是只能应用于 <a> 元素，其他 HTML 元素同样可以使用动态伪类选择器。例如在 HTML 页面中的 <button> 按钮元素可以配合 :hover 伪类选择器来使用，如下示例代码所示：

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>动态伪类选择器</title>
  <style>
    /* 鼠标移动到链接上 */
    button:hover {
      background-color: lightblue;
    }
  </style>
</head>

<body>
  <button>这是一个按钮</button>
</body>

</html>
```

```css
    <!DOCTYPE html>

    <html>

    <head lang="en">

        <meta charset="UTF-8">

        <title>动态伪类选择器----美化按钮</title>

        <style>
		.download-info{

    text-align: center;

    margin-top: 50px;

}

/*默认状态下的按钮效果*/

.btn{

    font-size: 20px;

    /*background-color: #0074cc;*/

    /*css3，背景线性渐变*/

    background-image: -webkit-gradient(linear, 0 0, 0 100%, from(black), to(#0055cc));

    background-repeat: repeat-x;

    display: inline-block;

    border: 1px solid #cccccc;

    /*css3，色彩模块*/

    border-radius: 6px;

    cursor: pointer;

    font-weight: normal;

    /*滤镜*/

    /*filter: ;*/

    padding: 14px 24px;

    text-align: center;

    text-decoration: none;

    color: #ffffff;

}

/*悬浮状态下按钮效果*/

.btn:hover{

    background-position: 0 -15px;

    background-color: #0055cc;

    text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);

    /*动画效果*/

    /*transition: background-position 0.1s linear;*/

    /*-webkit-transition: background-position 0.1s linear;*/

}

/*点击时按钮效果*/

.btn:active{

    background-color: red;

    background-image: none;

}

/*获得焦点时按钮效果*/

.btn:focus{

    outline: thin dotted #333;

    outline-offset: -20px;

    outline: 5px auto -webkit-focus-ring-color;

    /*background-color: darkgoldenrod;*/

}
		
		
		</style>

    </head>

    <body>

        <div class="download-info">

            <a href="#" class="btn">要点击的按钮</a>

        </div>

    </body>

    </html>
```



#### 2、目标伪类选择器

实质：点击指定元素，跳转到目标元素，增加状态特效

```css
目标伪类选择器指的是 CSS 中的 :target 伪类选择器，该伪类选择器用来设置 <a> 元素锚点功能中的目标元素的样式。如下示例代码展示了 :target 伪类选择器的用法：

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>目标伪类选择器</title>
  <style>
    p:target {
      background-color: gold;
    }

    /* 在目标元素中增加一个伪元素*/
    p:target::before {
      font: 70% sans-serif;
      content: "►";
      color: black;
      margin-right: .25em;
    }

    /*在目标元素中使用italic样式*/
    p:target i {
      color: red;
    }
  </style>
</head>

<body>
  <h3>Table of Contents</h3>
  <ol>
    <li><a href="#p1">Jump to the first paragraph!</a></li>
    <li><a href="#p2">Jump to the second paragraph!</a></li>
    <li><a href="#nowhere">This link goes nowhere,
        because the target doesn't exist.</a></li>
  </ol>

  <h3>My Fun Article</h3>
  <p id="p1">You can target <i>this paragraph</i> using a
    URL fragment. Click on the link above to try out!</p>
  <p id="p2">This is <i>another paragraph</i>, also accessible
    from the links above. Isn't that delightful?</p>
</body>

</html>
```



### 三、图像



#### 1、图像元素

```css
HTML <img> 元素在 HTML 页面中表示一个图像，用来引入 HTML 页面外部的一张图片。该元素是一个空元素，如下示例代码展示了 <img> 元素的常见用法：

<img src="./files/HTML5.jpeg" alt="HTML5">

如上述示例所示，<img> 元素具有 2 个常用的属性，具体如下：

src 属性：必选项，用来设置一张图片的路径。该路径可以是绝对路径，也可以是相对路径。
alt 属性：可选项，用来定义了描述图像的替换文本。当浏览器无法正常显示指定图片时，会显示该属性值的内容。
```

```css
<img> 元素还支持其他属性，具体如下：

width 属性和 height 属性：设置图像在浏览器显示时的宽度和高度。建议使用 CSS 中的 width 和 height 属性替代。

HTML5 版本中可以使用的单位是像素（px）。
HTML4 版本中可以使用的单位是像素（px）和百分比值（%）。
注意：无论是通过 <img> 元素的 width 和 height 属性，还是通过 CSS 中的 width 和 height 属性设置宽度和高度，高宽比一定要与原图像的高宽比保持一致，否则该图像会被拉伸。

title 属性：鼠标悬停在图像上时所显示的文本内容。

HTML 标准并没有规定 <img> 元素所支持的图像格式，或者必须支持的图像格式。所以不同浏览器所支持的图像格式可能会不相同。

值得注意的是，从技术角度来说，<img> 元素并没有将一张图像嵌入到 HTML 页面中，只是在 HTML 页面进行占位并指定了该图像文件的路径而已。所以，浏览器在加载解析 HTML 页面时，会单独加载图像文件。
```



#### 2、背景图像

```css
该属性可以拆分为如下几个 CSS 属性：

background-image 属性
background-repeat 属性
background-position 属性
background-size 属性
background-attachment 属性
```



#### 2.1、背景图像

```css
CSS background-image 属性用来在 HTML 元素设置一张背景图像或多张背景图像。该属性具有 2 个值，具体如下：

none：该关键字表示没有背景图像。

如果设置的图像无法正确加载显示，浏览器会将此情况等同于其值设置为 none（表示无背景图像）。

url(path) 函数：用来引入要显示的背景图像的路径。

支持多背景图像。使用多个 url() 函数引入背景图像，并且 url() 函数之间使用逗号（,）进行分隔。

如下示例代码展示了 background-image 属性的用法：

body {
  background-image: url("files/HTML5.jpeg");
}
```



#### 2.2、平铺方式

```css
CSS background-repeat 属性用来设置背景图像的重复方式。背景图像可以按照水平方向、垂直方向或者两轴方向重复或者不重复。

background-repeat 属性具有 4 个值，具体如下：

repeat：图像同时在水平方向和垂直方向进行重复。如果最后一个图像无法显示完整，则会被剪裁。

no-repeat：图像在水平方向和垂直方向都不会重复。

space：图像同时在水平方向和垂直方向进行重复。第一个重复的图像和最后一个重复的图像会被固定在元素的边缘，同时空白间隙会均匀地分布在重复的图像之间。

round：跟随浏览器窗口的尺寸增长，重复的图像会被拉伸（重复的图像之间不存在空白间隙）以铺满整个浏览器窗口。
由于 background-repeat 属性分为水平方向是否重复和垂直方向是否重复，所以该属性的值是两个：

第一个值：表示水平方向图像是否重复。可使用上述 4 个值中的一个。
第二个值：表示垂直方向图像是否重复。可使用上述 4 个值中的一个。
当然，background-repeat 属性也可以使用单个值来进行设置，具体情况如下：

单值	等价于双值
repeat-x	repeat no-repeat
repeat-y	no-repeat repeat
repeat	repeat repeat
space	space space
round	round round
no-repeat	no-repeat no-repeat
如下示例代码展示了 background-repeat 属性的用法：

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>平铺方式</title>
  <style>
    div {
      background-image: url("files/starsolid.gif");
      width: 144px;
      height: 84px;
    }

    .no-repeat {
      background-repeat: no-repeat;
    }

    .repeat {
      background-repeat: repeat;
    }

    .repeat-x {
      background-repeat: repeat-x;
    }

    .repeat-y {
      background-repeat: repeat-y;
    }
  </style>
</head>

<body>
  <p>no-repeat</p>
  <div class="no-repeat">&nbsp;</div>
  <p>repeat</p>
  <div class="repeat">&nbsp;</div>
  <p>repeat-x</p>
  <div class="repeat-x">&nbsp;</div>
  <p>repeat-y</p>
  <div class="repeat-y">&nbsp;</div>
</body>

</html>
```



#### 2.3、图像位置

```css
CSS background-position 属性用来设置背景图像在 HTML 页面中的初始位置。该属性具有 3 种类型的值，具体如下：

关键字：center、left、right、top 和 bottom，分别表示居中、左边、右边、顶部和底部。
长度值：绝对长度值和相对长度值都可以使用。
百分比值
由于设置的位置同时存在水平方式和垂直方向，所以 background-position 属性的值是两个：

第一个值：表示设置在水平方向的位置。
第二个值：表示设置在垂直方向的位置。
当然，background-position 属性也可以设置为一个值。

background-position 属性在使用时，需要注意如下一些问题：

如果第一个值是一个关键字，那么第二个值不能是相同的关键字。例如第一个值为 top 或 left 的话，那第二个值不能为 top 或 left。

如果背景图像显示的大小与所在元素的大小是相同的话，那么使用百分比值是无效的。这种情况下，如果要设置背景图像的位置，应该使用像素（px）。

如下示例代码展示了 background-position 属性的用法：

.example {
  background-image: url("files/HTML5.jpeg");
  background-repeat: no-repeat;
  background-position: top center;
}
```



#### 2.4、图像大小

实质：创建div块元素，将图片嵌入进去的效果

```css
CSS background-size 属性用来设置背景图像在 HTML 页面中的显示大小。该属性具有 4 种类型的值，具体如下：

cover：缩放背景图像以完全覆盖背景区，可能背景图像部分看不见。
contain：缩放背景图像以完全装入背景区，可能背景区部分空白。
一个值：表示设置背景图像的宽度为这个值，而高度值为 auto。
两个值：第一个值表示设置背景图像的宽度，第二个值表示设置背景图像的高度。
注意：如果使用两个值来设置背景图像的宽度和高度的话，高宽比一定要与原图像的高宽比保持一致，否则该图像会被拉伸。
```

```css
例：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>图像大小</title>
  <style>
    #container {
      width: 100%;
      display: flex;
      justify-content: space-around;
      height: 300px;
      overflow: scroll;
      background-color: #EEEEEE;
    }

    .subcontainer {
      width: 100%;
      max-width: 200px;
      margin: 8px;
      padding: 5px;
      background-color: white;
      background-image: url("kt.jpg");
      background-repeat: no-repeat;
      color: white;
      font-family: monospace;
    }

    .contain {
      background-size: contain;
    }

    .cover {
      background-size: cover;
    }

    .width {
      background-size: 120px;
    }

    .width-height {
      background-size: 120px 200px;
    }
  </style>
</head>

<body>
  <div id="container">
    <div class="subcontainer contain">contain</div>
    <div class="subcontainer cover">cover</div>
    <div class="subcontainer width">120px</div>
    <div class="subcontainer width-height">120px 200px</div>
  </div>
</body>

</html>
```



#### 2.5、背景关联

```css
CSS background-attachment 属性用来设置背景图像的位置是在视口内固定的，还是跟随所在的元素区域滚动。该属性具有 3 个值，具体如下：

fixed：表示背景图像相对于视口固定。即使一个元素拥有滚动机制，背景图像也不会随着元素的内容滚动。
local：表示背景图像相对于元素的内容固定。如果一个元素拥有滚动机制，背景图像将会随着元素的内容滚动， 并且背景图像的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。
scroll：示背景图像相对于元素本身固定， 而不是随着元素的内容滚动，但对元素边框是有效的。
```

```css
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>图像关联</title>
  <style>
    .output {
      background-color: #fff;
      overflow: scroll;
      box-shadow: 2px 2px 5px -2px rgba(0, 0, 0, .2);
      padding: 1em;
      height: 300px;
    }

    #default-example {
      height: 600px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
    }

    #example-element {
      max-width: 20rem;
      height: 100%;
      background: url("files/lizard.png") right 3rem top 1rem/15rem no-repeat, url("files/moon.jpg") center/10rem;
      color: #fff;
      font-size: 1.5em;
      font-weight: 700;
      overflow: auto;
      padding: 20px;
      text-shadow: 0 0 0.6rem #000, 0 0 0.6rem #000;
    }

    #default-example .attachment {
      background-attachment: local;
    }
  </style>
</head>

<body>
  <div id="output" class="output">
    <section id="default-example">
      <div id="example-element" class="attachment">
        London. Michaelmas term lately over, and the Lord Chancellor sitting in Lincoln's Inn Hall. Implacable November
        weather. As much mud in the streets as if the waters had but newly retired from the face of the earth, and it
        would not be wonderful to meet a Megalosaurus, forty feet long or so, waddling like an elephantine lizard up
        Holborn Hill.
        London. Michaelmas term lately over, and the Lord Chancellor sitting in Lincoln's Inn Hall. Implacable November
        weather. As much mud in the streets as if the waters had but newly retired from the face of the earth, and it
        would not be wonderful to meet a Megalosaurus, forty feet long or so, waddling like an elephantine lizard up
        Holborn Hill.
      </div>
    </section>
  </div>
</body>

</html>
```



#### 2.6、background 属性

```css
CSS background 属性是一个简写属性，用来一次性集中设置各种有关背景的属性。该属性可以用来设置一个或多个属性，其中包含 background-color 属性、background-image 属性、background-position 属性、background-repeat 属性、background-size 属性和background-attachment 属性。

如下示例代码展示了 background 属性的用法：

.example {
  background: url("files/HTML5.jpeg") no-repeat top center;
}
```



#### 2.7、精灵图

```css
CSS 中的精灵图又称为雪碧图，应用在使用了众多小图标的网站中。精灵图的做法就是把众多的小图标整合成一个图片，通过 backgroud-postion 属性分别指定使用这张图片中的哪个小图标。

实质：就是导入一个div块，将背景图按照块大小插入，可通过移动背景图位置，最后在块中显示出背景图

这样做法的好处就是 HTML 页面的外部资源请求减少，对内存和带宽更加友好。

```

```css
例：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>精灵图</title>
  <style>
    .example {
      width: 20px;
      height: 20px;
      /* 通过 background-image 属性引入背景图像 */
      background: url("kt.jpg") no-repeat;
      /* 通过 background-position 属性设置背景图像偏移量 */
      background-position: 0 -50px;
    }
  </style>
</head>

<body>
  <div class="example"></div>
</body>

</html>


精灵图的实现方式如下：

<div> 元素通过 CSS 的 width 和 height 属性设置显示的区域大小为 20px * 20px。
通过 CSS 的 background-image 属性为 <div> 元素引入背景图像，并设置为不重复显示。
通过 CSS 的 background-position 属性设置背景图像显示的位置（垂直方向向上移动 50px），以达到显示想要显示的图标。
```



#### 3、position定位

```css
position 属性规定元素的定位类型。

这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在正常流中的默认位置偏移。


absolute
生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。
元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。

fixed
生成绝对定位的元素，相对于浏览器窗口进行定位。
元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。

relative
生成相对定位的元素，相对于其正常位置进行定位。
因此，"left:20" 会向元素的 LEFT 位置添加 20 像素。

static
默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。

inherit
规定应该从父元素继承 position 属性的值。

注意：margin和position的相对值 ，使用起来，相似但不相同，margin会影响其他元素。

注意：当一个父元素也用了position的值除static外，当子元素用absolute的话，会按照这个父元素为绝对定位，而不是浏览器窗口
fixed始终是相对于浏览器窗口定位
```



## 阶段 6：列表



### 一、列表元素



#### 1、概述

```
列表方式呈现一系列平行的内容，在 HTML 页面中同样提供了列表元素来完成类似的功能，可以划分为如下 3 列表：

有序列表（有数字顺序序号）
无序列表（全是 · 没有序号）
定义列表
```



#### 2.1、有序列表

```css
HTML <ol> 元素表示有序列表，默认情况下使用数字作为列表编号。
而 <li> 元素则表示列表项，定义在有序列表中。

例：

<ol>
  <li>iPhone手机</li>
  <li>小米手机</li>
  <li>华为手机</li>
</ol>
```

```css
<ol> 元素默认使用数字作为编号，可以通过 type 属性进行修改，该属性的值具有 5 种类型，如下所示：

“a”：表示小写字母编号
“A”：表示大写字母编号
“i”：表示小写罗马数字编号
“I”：表示大写罗马数字编号
“1”：默认值，表示数字编号
type 属性的值默认情况下会作用到整个有序列表。

说明：type 属性在 HTML4 版本中被弃用，但在 HTML5 版本中被重新引入。如果不是为了元素的语义化的话，该属性可以使用 CSS 中的 list-style-type 属性进行替代。

除了 type 属性之外，在 HTML5 版本中新增了 2 个属性，如下所示：

1、reversed：布尔值，设置列表采用倒序的方式。

注意：该属性只需要定义属性名即可，而不需要设置属性值。

如下示例代码展示了 reversed 属性的用法：

<ol reversed>
  <li>iPhone手机</li>
  <li>小米手机</li>
  <li>华为手机</li>
</ol>

效果便是倒序输出

2、start：整数值，设置列表序号开始的值。

说明：该属性在 HTML4 版本中被弃用，在 HTML5 版本中被重新引入。
```

```css
HTML <li> 元素也同样具有如下 2 个属性：

value：整数值，设置当前列表项在有序列表的序号。（如果和start一起使用，会执行value的作用）

说明：该属性在 HTML4 版本中被弃用，在 HTML5 版本中被重新引入。

type：设置有序列表的数字类型。

说明：该属性值会覆盖 <ol> 元素的 type 属性值。

由于 <li> 元素的 2 个属性，会导致两种比较特殊的情况出现：

<li> 元素通过 value 属性设置了该元素在有序列表的序号，但与默认的序号是不同的。
如下示例代码展示了这种情况：

<ol start="3">
  <li>iPhone手机</li>
  <li value="5">小米手机</li>
  <li>华为手机</li>
</ol>

结果是 3 5 6 ， 因为第二个li开始设置了value值，也导致了第三个默认升序
```



#### 2.2、无序列表

```css
HTML <ul> 元素表示无序列表，默认情况下使用 disc 作为列表编号。而 <li> 元素则表示列表项，定义在无序列表中。

如下示例代码展示了 HTML 中无序列表的用法：

<ul>
  <li>iPhone手机</li>
  <li>小米手机</li>
  <li>华为手机</li>
</ul>
```

```css
<ul> 元素默认使用 disc 作为编号，可以通过 type 属性进行修改，该属性的值具有 3 种类型，如下所示：

disc：默认值，表示实心圆
circle：表示空心圆
square：表示实心方块
说明：type 属性已经被弃用，建议使用 CSS 中的 list-style-type 属性进行替代。

HTML <li> 元素的 value 属性或 type 属性都是针对有序列表的，对无序列表是无效的。
```



#### 3、列表嵌套

```css
在一个有序列表或无序列表中定义另一个有序或无序列表作为子列表，这样就构成了列表嵌套。列表嵌套会有如下 4 种情况：

有序列表嵌套有序列表：父级和子级列表默认使用数字作为序号。

如下示例代码所示：

<ol>
  <li>iPhone手机
    <ol>
      <li>iPhone 7</li>
      <li>iPhone 8</li>
      <li>iPhone X</li>
    </ol>
  </li>
  <li>小米手机</li>
  <li>华为手机</li>
</ol>
```

```css
有序列表嵌套无序列表：父级有序列表默认使用数字作为序号，子级无序列表默认使用 circle 作为序号。

如下示例代码所示：

<ol>
  <li>iPhone手机
    <ul>
      <li>iPhone 7</li>
      <li>iPhone 8</li>
      <li>iPhone X</li>
    </ul>
  </li>
  <li>小米手机</li>
  <li>华为手机</li>
</ol>
```

```css
无序列表嵌套无序列表：父级无序列表默认使用 disc 作为序号，子级无序列表默认使用 circle 作为序号。

如下示例代码所示：

<ul>
  <li>iPhone手机
    <ul>
      <li>iPhone 7</li>
      <li>iPhone 8</li>
      <li>iPhone X</li>
    </ul>
  </li>
  <li>小米手机</li>
  <li>华为手机</li>
</ul>
```

```css
无序列表嵌套有序列表：父级无序列表默认使用 disc 作为序号，子级有序列表默认使用数字作为序号。

如下示例代码所示：

<ul>
  <li>iPhone手机
    <ol>
      <li>iPhone 7</li>
      <li>iPhone 8</li>
      <li>iPhone X</li>
    </ol>
  </li>
  <li>小米手机</li>
  <li>华为手机</li>
</ul>
```



#### 4、定义列表

```css
HTML <dl> 元素在 HTML4 版本中称为定义列表，在 HTML5 版本中称为描述列表。该元素是一个包含术语定义及描述的列表，其中术语定义使用的是 <dt> 元素，描述使用的是 <dd> 元素。该元素通常应用于例如词汇表、键值对列表等。

如下示例代码展示了定义列表的基本用法：

<dl>
  <dt>爱好</dt>
    <dd>抽烟</dd>
    <dd>喝酒</dd>
    <dd>烫头</dd>
  <dt>职业</dt>
    <dd>程序员</dd>
    <dd>讲师</dd>
    <dd>说书人</dd>
</dl>

说明：不要将定义列表用来实现缩进效果，因为这样做法导致语义化不清晰。
```



### 二、列表样式



#### 1、概述

说明：h5版本以摒弃以往的type属性，只能用list-style代替

```css
列表样式主要是针对 HTML 页面中的列表元 CSS 所提供的样式。具体来讲，主要就是 CSS 中的 list-style 属性以及相关属性内容。

由于 list-style 属性是简写形式，具体划分为如下 3 普通属性：

list-style-type 属性
list-style-image 属性
list-style-position 属性
```



#### 2、项目符合样式

```css
CSS list-style-type 属性用来设置列表元素的项目符号（编号/序号）。该属性可以被应用在 <ol> 元素、<ul> 元素和 <li> 元素中。

list-style-type 属性的值可以划分如下 2 种类型的值：

1、none：表示不显示任何项目符号。

2、关键字：表示特定含义的项目符号关键字。
关于 list-style-type 属性的值为关键字的情况，还可以划分为有序列表和无序列表 2 种：

（1）有序列表：
    decimal：十进制阿拉伯数字，从 1 开始
    decimal-leading-zero：十进制阿拉伯数字，例如 01、02、03… …
    lower-alpha：小写英文字母
    upper-alpha：大写英文字母
    lower-roman：小写罗马数字
    upper-roman：大写罗马数字
（2）无序列表：
    disc：实心圆点
    circle：空心圆点
    square：实心方块

如下示例代码展示了 list-style-type 属性的用法：

ul {
  list-style-type: circle;
}

ol {
  list-style-type: lower-alpha;
}
```



#### 3、项目符号图像

说明：自己定义符号显示图标

```css
CSS list-style-image 属性用来设置某个图像为列表元素的项目符号
该属性的值可以划分如下 2 种类型的值：

1、none：没有任何图像作为项目符号。这种情况下，将使用 list-style-type 属性的值来替代。
2、url() 函数：设置引入图像的路径。

如下示例代码展示了 list-style-image 属性的用法：

ul {
  list-style-image: url("files/rocket.svg");
}
```



#### 4、项目符号定位

```css
CSS list-style-position 属性用来设置列表元素的项目符号的位置，该属性的值可以划分如下 2 种类型的值：

1、inside：该值表示项目符号位于文本块的内部，同时文本会进行缩进。
2、outside：该值表示项目符号位于文本块的左侧。

如下示例代码展示了 list-style-position 属性的用法：

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>项目符号定位</title>
  <style>
    li {
      background-color: lightcoral;
    }

    .inside {
      list-style-position: inside;
    }

    .outside {
      list-style-position: outside;
    }
  </style>
</head>

<body>
  <ul class="inside">
    <li>iPhone手机</li>
    <li>小米手机</li>
    <li>华为手机</li>
  </ul>
  <ul class="outside">
    <li>iPhone手机</li>
    <li>小米手机</li>
    <li>华为手机</li>
  </ul>
</body>

</html>

```



#### 5、list-style 属性

说明：以上简写形式

```css
CSS list-style 属性是一个简写属性，list-style-type 属性、list-style-image 属性和 list-style-position 属性的值可以同时定义在 list-style 属性中。

如下示例代码展示了 list-style 属性的用法：

ul {
  list-style: url("files/rocket.svg") outside;
}
```



### 三、计数器



#### 1、概述

实质：计数器就是初始化变量然后进行自增赋值，就类似 a+=1

```
CSS 中的计数器本质上来说就是由 CSS 维护的变量，计数器的值可以通过 CSS 规则递增来跟踪计数器的使用次数，例如可以使用计数器来自动为网页中的标题编号。

简单来说，有序列表就是一个比较简单的计数器，但计数器可以实现编号更为复杂的情况。
```

```css
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>计数器示例</title>
  <style>
    #demo ol {
      counter-reset: section;
      list-style-type: none;
    }

    #demo ol li {
      counter-increment: section;
    }

    #demo ol li:before {
      content: counters(section, ".") ". ";
    }
  </style>
</head>

<body>
  <div id="demo">
    <ol>
      <li>进风口的爽肤水
        <ol>
          <li>非进口商的</li>
          <li>非进口商的</li>
          <li>非进口商的</li>
        </ol>
      </li>
      <li>进风口的爽肤水
        <ol>
          <li>非进口商的</li>
          <li>
            非进口商的
            <ol>
              <li>将咖啡色的开发商</li>
              <li>将咖啡色的开发商</li>
              <li>将咖啡色的开发商</li>
              <li>将咖啡色的开发商</li>
            </ol>
          </li>
          <li>非进口商的</li>
        </ol>
      </li>
      <li>进风口的爽肤水</li>
    </ol>
  </div>
</body>

</html>
```

```css
如上述示例所示，操作计数器的值是通过如下 2 个属性实现：

counter-reset 属性
counter-increment 属性

在 HTML 页面中显示计数器是通过如下 2 个函数实现：

counter() 函数
counters() 函数
```



#### 2.1、counter-rest 属性（初始化）

实质：变量的初始化

```css
CSS counter-reset 属性用来将计数器重置为给定的值。该属性的默认值为 none，其值的类型具有如下 3 种情况：

要重置为计数器的名称。该名称可以是字母（A-Z，a-z）、十进制数字（0-9）、连接符（-）、下划线（_）以及转义字符。
要在元素每次出现时将计数器重置为的值。如果没有指定，默认值为 0。
none：不执行计数器复位。
```

```css
如下示例代码展示了 counter-reset 属性为 none 值的情况：

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>counter-reset属性</title>
  <style>
    #chapters {
      counter-reset: chapter-count;
    }

    h2 {
      counter-increment: chapter-count;
      font-size: 1em;
    }

    h2::before {
      content: "Chapter "counter(chapter-count) ": ";
    }

    #example-element {
      background-color: #add8e6;
      counter-reset: none;
    }
  </style>
</head>

<body>
  <div id="chapters">
    <h2>什么是计数器</h2>
    <h2 id="example-element">coutner-reset属性</h2>
    <h2>counter-increment属性</h2>
    <h2>counter()和counters()函数</h2>
  </div>
</body>

</html>
```



#### 2.2、counter-increment 属性（递增或递减）

```css
CSS counter-increment 属性用来设置计数器每次增加的值。该属性的默认值为 none，其值的类型具有如下 3 种情况：

要增加为计数器的名称。该名称可以是字母（A-Z，a-z）、十进制数字（0-9）、连接符（-）、下划线（_）以及转义字符。
要在元素每次出现时将计数器增加为的值。如果没有指定，默认值为 1。
none：任何计数器都不能递增。
```

```css
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>counter-increment属性</title>
  <style>
    #chapters {
      counter-reset: chapter-count;
    }

    h2 {
      counter-increment: none;
      font-size: 1em;
    }

    h2::before {
      content: "Chapter "counter(chapter-count) ": ";
    }
  </style>
</head>

<body>
  <div id="chapters">
    <h2>什么是计数器</h2>
    <h2 id="example-element">coutner-reset属性</h2>
    <h2>counter-increment属性</h2>
    <h2>counter()和counters()函数</h2>
  </div>
</body>

</html>
```

```css
说明：如果将 counter-increment 属性值设置为 chapter-count -1 则表示递减。

如果 counter-increment 属性设置多个计数器的递增值的话，计数器之间使用空格进行分隔。如下示例代码展示了 counter-increment 属性设置多个计数器：

h1 {
  counter-increment: chapter section 2 page;
}
上述示例代码的含义是：

将 chapter 和 page 两个计数器递增为 1。
将 section 计数器递增为 2。
```



#### 2.3、counter() 函数（打印输出）

```css
CSS counter() 函数用来简单地将计数器的内容显示在 HTML 页面中。counter() 函数返回一个字符串，该字符串表示指定的计数器的当前值。

counter() 函数的语法结构如下所示：

conter(custom-ident, counter-style)
上述语法结构具体说明如下：

custom-ident 参数：表示计数器的名称。
counter-style 参数：表示显示的样式。
```

```css
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>counter()函数</title>
  <style>
    ol {
      counter-reset: listCounter;
    }

    li {
      counter-increment: listCounter;
    }

    li::after {
      content: "["counter(listCounter) "] == ["
        counter(listCounter, upper-roman) "]";
        /* 打印输出计数器变量，输出格式为默认和罗马 */
    }
  </style>
</head>

<body>
  <ol>
    <li></li>
    <li></li>
    <li></li>
  </ol>
</body>

</html>

注意：counter() 函数经常与 ::before 和 ::after 伪元素选择器配合使用。
```



#### 2.4、counters () 函数

```css
CSS counters() 函数支持计数器的嵌套情况。counters() 函数返回一个字符串，该字符串表示指定的计数器的当前值。

counters() 函数的语法结构如下所示：

conter(custom-ident, string, counter-style)
上述语法结构具体说明如下：

custom-ident 参数：表示计数器的名称。
string 参数：表示计数器嵌套的分隔符，可以是任意数量的文本字符。
counter-style 参数：表示显示的样式。
```

```css
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>counters()函数</title>
  <style>
    ol {
      counter-reset: listCounter;
    }

    li {
      counter-increment: listCounter;
    }

    li::marker {
      content: counters(listCounter, '.', upper-roman) ') ';
    }

    li::before {
      content: counters(listCounter, ".") " == "counters(listCounter, ".", lower-roman);
    }
  </style>
</head>

<body>
  <ol>
    <li>
      <ol>
        <li></li>
        <li></li>
        <li></li>
      </ol>
    </li>
    <li></li>
    <li></li>
    <li>
      <ol>
        <li></li>
        <li>
          <ol>
            <li></li>
            <li></li>
            <li></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</body>

</html>
```





## 阶段 7：表格



### 一、表格元素



#### 1、概述

注意：boder必须设置，方便看效果

```css
表格是一组由行和列组成的结构化数据集，可以将不同类型的数据集成在一张表中以显示不同类型数据之间存在的某种关系
（和平常用的表格一样，行、列、单元格）

HTML 页面中提供的表格元素如下：

<table boder='1'>
  <tr>
    <td>单元格</td>
  </tr>
</table>

<table> 元素：表示 HTML 页面中的一个表格，作为表格的容器。
<tr> 元素：表示 HTML 页面中一个表格的行。一个表格可以拥有一行或多行。
<td> 元素：表示 HTML 页面中的一个表格中一行的单元格。一行可以拥有一个单元格或多个单元格。
```



#### 2、标题单元格

```css
HTML <th> 元素用来定义为一组单元格的标题。该元素的用法与 <td> 元素保持一致，定义在 <tr> 元素中。

如下示例代码展示了 <th> 元素的用法：

<table>
  <tr>
    <th>First name</th> 
    <th>Last name</th>
  </tr>
  <tr>
    <td>John</td>
    <td>Doe</td>
  </tr>
  <tr>
    <td>Jane</td>
    <td>Doe</td>
  </tr>
</table>

<th> 元素中的文本内容在浏览器运行时会自动加粗并且居中显示的效果。
```

```css
<th> 元素的 scope 属性用来定义与该标题单元格相关联的单元格，是一个枚举类型，具体的值如下所示：

row：表示当前标题单元格关联一行中的所有单元格。
col：表示当前标题单元格关联一列中的所有单元格。
rowgroup：表示当前标题单元格属于某一个行组并与其中所有单元格相关联。
colgroup：表示当前标题单元格属于某一个列组并与其中所有单元格相关联。
auto：由浏览器自动分配。
如下示例代码展示了 <th> 元素的 scope 属性的用法：

<table boder="1">
  <tr>
    <th scope="col">Name</th>
    <th scope="col">HEX</th>
    <th scope="col">HSLa</th>
    <th scope="col">RGBa</th>
  </tr>
  <tr>
    <th scope="row">Teal</th>
    <td><code>#51F6F6</code></td>
    <td><code>hsla(180, 90%, 64%, 1)</code></td>
    <td><code>rgba(81, 246, 246, 1)</code></td>
  </tr>
  <tr>
    <th scope="row">Goldenrod</th>
    <td><code>#F6BC57</code></td>
    <td><code>hsla(38, 90%, 65%, 1)</code></td>
    <td><code>rgba(246, 188, 87, 1)</code></td>
  </tr>
</table>
```



#### 3、表格的标题

```css
HTML <caption> 元素用来定义 HTML 页面中表格上方的标题。
该元素一般作为 <table> 元素的第一个子级元素出现，同时会显示在表格内容中的最前面，并且会在水平方向居中显示。
```

```css
<table>
  <caption>Color names and values</caption>
  <tr>
    <th scope="col">Name</th>
    <th scope="col">HEX</th>
    <th scope="col">HSLa</th>
    <th scope="col">RGBa</th>
  </tr>
  <tr>
    <th scope="row">Teal</th>
    <td><code>#51F6F6</code></td>
    <td><code>hsla(180, 90%, 64%, 1)</code></td>
    <td><code>rgba(81, 246, 246, 1)</code></td>
  </tr>
  <tr>
    <th scope="row">Goldenrod</th>
    <td><code>#F6BC57</code></td>
    <td><code>hsla(38, 90%, 65%, 1)</code></td>
    <td><code>rgba(246, 188, 87, 1)</code></td>
  </tr>
</table>
```



#### 4、跨行与跨列（合并单元格）

实质：合并单元格

```css
colspan 属性：用来规定表格单元格可横跨的列数。
rowspan 属性：用来规定表格单元格可横跨的行数。

<table>
	<caption>Web前端课程</caption>
	<tr>
		<th></th>
		<th scope="col">设计与构建静态网站</th>
		<th scope="col">JavaScript基础核心语法</th>
	</tr>
	<tr>
		<th scope="row">是否完成</th>
		<td colspan="2">已完成</td>
	</tr>
</table>
```



#### 5、长表格（语义）

```css
HTML 页面还提供如下 3 个元素来丰富表格：

<thead> 元素：用来定义 HTML 页面中表格的标题单元格的行。
<tbody> 元素：用来定义 HTML 页面中表格的主体（表格中真正的数据内容）。
<tfoot> 元素：用来定义 HTML 页面中表格一组各列的汇总行。
如下示例代码展示了 <thead> 元素、<tbody> 元素和 <tfoot> 元素的用法：

<table>
  <caption>Color names and values</caption>
  <thead>
    <tr>
      <th scope="col">Name</th>
      <th scope="col">HEX</th>
      <th scope="col">HSLa</th>
      <th scope="col">RGBa</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">Teal</th>
      <td><code>#51F6F6</code></td>
      <td><code>hsla(180, 90%, 64%, 1)</code></td>
      <td><code>rgba(81, 246, 246, 1)</code></td>
    </tr>
    <tr>
      <th scope="row">Goldenrod</th>
      <td><code>#F6BC57</code></td>
      <td><code>hsla(38, 90%, 65%, 1)</code></td>
      <td><code>rgba(246, 188, 87, 1)</code></td>
    </tr>
  </tbody>
</table>

<thead> 元素、<tbody> 元素和 <tfoot> 元素不会使表格更易于屏幕阅读器用户访问，也不会造成任何视觉上的改变。然而，它们在应用样式和布局上会起到作用，可以更好地让 CSS 应用到表格上。
```



### 二、表格样式



#### 1、表格布局

实质：auto是自适应，随着每个新的单元格都要改变整体布局，而fixed当第一行单元格固定以后的单元格都被固定

```css
CSS table-layout 属性用来实现表格中单元格的布局，行和列的计算。该属性具有如下 2 个值：

auto：默认值，浏览器会使用自动表布局算法，已达到表格及其单元格的宽度被调整以适应内容。
fixed：表格或表格中列的宽度是由表格中第一行单元格的宽度决定的，后续行的单元格则不会影响表格中列的宽度。
以上两个值产生的结果可能不同，但两者之间最大的差异主要是速度上的。相对 fixed 的速度更快，而 auto 的速度稍慢，原因如下：

fixed：之所以速度快，主要原因是一旦浏览器解析了表格中第一行单元格的宽度就可以呈现整个表格，而不依赖表格中单元格的内容。
auto：表格的 width 属性的值为 auto 就会触发这种方式，无论 table-layout 属性的值是什么。这种方式之所以速度慢，主要原因在于每渲染一个新的单元格都要完成整个表格的布局。
```

```css
如下示例代码展示了 table-layout 属性的用法：

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>table-layout属性</title>
  <style>
    table {
      display: table;
      border-collapse: separate;
      border-spacing: 2px;
      border: 1px solid #139;
      width: 100%;
    }

    td,
    th {
      border: 2px solid #a19;
      padding: .25rem .5rem;
    }

    #example-element {
      table-layout: auto;
    }
  </style>
</head>

<body>
  <table id="example-element">
    <tbody>
      <tr>
        <th>姓名</th>
        <th>地点</th>
      </tr>
      <tr>
        <td>李雷</td>
        <td>北京</td>
      </tr>
      <tr>
        <td>韩梅梅</td>
        <td>上海</td>
      </tr>
      <tr>
        <td>露西</td>
        <td>深圳</td>
      </tr>
      <tr>
        <td>小明</td>
        <td>鹤岗</td>
      </tr>
    </tbody>
  </table>
</body>

</html>
```



#### 2、表格标题

```css
CSS caption-side 属性用来设置 HTML 页面中表格的 <caption> 元素显示的位置，该属性需要与 <caption> 属性配合使用。该属性的值具有如下 2 个：
top：默认值，表示表格标题显示在表格的上方。
bottom：表示表格标题显示在表格的下方。
```

```css
如下示例代码展示了 caption-side 属性值为 bottom 时的情况：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>caption-side属性</title>
  <style>
    table,
    th,
    td {
      padding: 5px;
      border: 1px solid black;
    }

    table caption {
      caption-side: bottom;
    }
  </style>
</head>

<body>
  <table>
    <caption>Color names and values</caption>
    <thead>
      <tr>
        <th scope="col">Name</th>
        <th scope="col">HEX</th>
        <th scope="col">HSLa</th>
        <th scope="col">RGBa</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th scope="row">Teal</th>
        <td><code>#51F6F6</code></td>
        <td><code>hsla(180, 90%, 64%, 1)</code></td>
        <td><code>rgba(81, 246, 246, 1)</code></td>
      </tr>
      <tr>
        <th scope="row">Goldenrod</th>
        <td><code>#F6BC57</code></td>
        <td><code>hsla(38, 90%, 65%, 1)</code></td>
        <td><code>rgba(246, 188, 87, 1)</code></td>
      </tr>
    </tbody>
  </table>
</body>

</html>
```



#### 3、处理空单元格

```css
CSS empty-cells 属性用来设置 HTML 页面的表格中没有可见内容的单元格的边框和背景是显示还是隐藏。该属性的值具有如下 2 个：

show：默认值，边框和背景正常渲染，与普通元素一样。
hide：边框和背景被隐藏。
```

```css
如下示例代码展示了 empty-cells 属性的用法：

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>empty-cells属性</title>
  <style>
    table {
      display: table;
      border-collapse: separate;
      border-spacing: 2px;
      border: 1px solid #139;
      width: 100%;
    }

    td,
    th {
      border: 2px solid #a19;
      padding: .25rem .5rem;
    }

    #example-element {
      empty-cells: show;
    }
  </style>
</head>

<body>
  <table id="example-element">
    <tbody>
      <tr>
        <th>姓名</th>
        <th>地点</th>
      </tr>
      <tr>
        <td>李雷</td>
        <td>北京</td>
      </tr>
      <tr>
        <td>韩梅梅</td>
        <td>上海</td>
      </tr>
      <tr>
        <td>露西</td>
        <td>深圳</td>
      </tr>
      <tr>
        <td>小明</td>
        <td></td>
      </tr>
    </tbody>
  </table>
</body>

</html>

注意：empty-cells 属性只有在 border-collapse 属性值为 separate 时才有效，值为collapse无效果
```



#### 4、单元格边框

```css
CSS border-collapse 属性用来设置 HTML 页面中表格的边框是分离的还是合并的，该属性具有如下 2 个值：

separate：默认值，每个单元格拥有独立的边框。
collapse：相邻的单元格共用同一条边框。（给table设置）

当 border-callapse 属性值为 separate 时称为**分隔（separated）模式，是 HTML 表格的传统模式。这种模式下，相邻单元格都拥有不同的边框。边框之间的距离是通过 CSS 的 border-spacing 属性来进行设置。

CSS border-spacing 属性用来设置 HTML 页面中表格的相邻单元格边框之间的距离。该属性的值设置具有如下 2 种方式：

单值：同时设置单元格之间在水平方向和垂直方向的距离。
双值：第一个值用来设置相邻两列的单元格之间的水平方向的距离，第二个值用来设置相邻两行的单元格之间的垂直方向的距离。
```

```css
如下示例代码展示了 border-callapse 属性值为 separate 时，border-spacing 属性的用法：

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>border-spacing属性</title>
  <style>
    table {
      display: table;
      border: 1px solid #139;
      width: 100%;
    }

    td,
    th {
      border: 2px solid #a19;
      padding: .25rem .5rem;
    }

    #example-element {
      border-collapse: separate;
      border-spacing: 5px;
    }
  </style>
</head>

<body>
  <table id="example-element">
    <tbody>
      <tr>
        <th>姓名</th>
        <th>地点</th>
      </tr>
      <tr>
        <td>李雷</td>
        <td>北京</td>
      </tr>
      <tr>
        <td>韩梅梅</td>
        <td>上海</td>
      </tr>
      <tr>
        <td>露西</td>
        <td>深圳</td>
      </tr>
      <tr>
        <td>小明</td>
        <td>鹤岗</td>
      </tr>
    </tbody>
  </table>
</body>

</html>

当 border-collapse 属性值为 collapse 时称为合并（collapsed ）模式。这种模式下，表格中相邻单元格共享边框。
```



### 三、结构伪类选择器



#### 1、概述

```css
CSS 中的结构伪类选择器是根据 HTML 页面中元素之间的关系来定位 HTML 元素，从而减少对 HTML 元素的 id 属性和 class 属性的依赖。
```

| 伪类选择器                   | 作用                                                         |
| :--------------------------- | :----------------------------------------------------------- |
| selector:first-child         | 用来定位一组兄弟元素中的第一个元素                           |
| selector:last-child          | 用来定位一组兄弟元素中的最后一个元素                         |
| selector:nth-child(n)        | 用来定位一组兄弟元素中的第 n 个元素                          |
| selector:nth-last-child(n)   | 用来定位一组兄弟元素中倒序方式的第 n 个元素                  |
| selector:first-of-type       | 用来定位一组同类型的兄弟元素中的第一个元素                   |
| selector:last-of-type        | 用来定位一组同类型的兄弟元素中的最后一个元素                 |
| selector:nth-of-type(n)      | 用来定位一组同类型的兄弟元素中的第 n 个元素                  |
| selector:nth-last-of-type(n) | 用来定位一组同类型的兄弟元素中倒序方式的第 n 个元素          |
| selector:only-child          | 用来定位一个没有任何兄弟元素的元素                           |
| selector:only-of-type        | 用来定位一个没有任何同类型兄弟元素的元素                     |
| selector:empty               | 用来定位一个没有子级元素的元素，并且该元素也没有任何文本内容 |
| selector:root                | 用来定位 HTML 页面中的根元素（《html》）                     |

```
在上述表中，使用到的 n 是一个整数，而且是从 1 开始的正整数。也就是说，第一个元素的序号是 1，不是 0。当 n 的值为 0 时，则表示不定位任何 HTML 元素。
```



#### 2.1、:first-child 与 :last-child

```css
:first-child 伪类是 CSS2 版本中的选择器。在最初定义 :first-child 伪类时，所定位的这一组兄弟元素是必须具有父级元素的。从 CSS4 版本开始，父级元素已经不再是必须的。

:last-child 伪类则是 CSS3 版本中新增的选择器。使用 :last-child 伪类时，需要注意浏览器的兼容性问题。

如下示例代码展示了 :first-child 伪类和 :last-child 伪类的用法：

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>first-child与last-child伪类</title>
  <style>
    #example-element td {
      background-color: lightsalmon;
      padding: 5px 10px;
    }

    #example-element td:first-child {
      border-top-left-radius: 5px;
    }

    #example-element td:last-child {
      border-top-right-radius: 5px;
    }
  </style>
</head>

<body>
  <table id="example-element">
    <tr>
      <td>公司介绍</td>
      <td>产品中心</td>
      <td>新闻动态</td>
    </tr>
  </table>
</body>

</html>

:first-child 伪类可以使用 :nth-child(n) 伪类改写为 :nth-child(1)，而 :last-child 伪类可以使用 :nth-last-child(n) 伪类改写为 :nth-last-child(1)。

:first-child 伪类和 :last-child 伪类经常会引起误解。例如 td:first-child 是用来定位所有 <td> 元素中第一个作为子级元素的，而不是定位 <td> 元素的第一个子级元素。
```



#### 2.2、:first-of-type 与 :last-of-type

```css
:first-of-type 伪类和 :last-of-type 伪类都是 CSS3 版本新增的选择器。在最初定义 :first-of-type 伪类时，所定位的这一组兄弟元素是必须具有父级元素的。从 CSS4 版本开始，父级元素已经不再是必须的。

如下示例代码展示了 :first-of-type 伪类和 :last-of-type 伪类的用法：

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>first-of-type与last-of-type伪类</title>
  <style>
    table {
      display: table;
      border: 10px solid #139;
      width: 100%;
    }

    td,
    th {
      border: 15px solid #a19;
      padding: .75rem .5rem;
    }

    #example-element td:first-of-type,
    #example-element td:last-of-type
    /* 选择第一列的td和第二列的td */
     {
      text-align: center;
    }
  </style>
</head>

<body>
  <table id="example-element">
    <tbody>
      <tr>
        <th>序号</th>
        <th>姓名</th>
        <th>地点</th>
      </tr>
      <tr>
        <th>1</th>
        <td>李雷</td>
        <td>北京</td>
      </tr>
      <tr>
        <th>2</th>
        <td>韩梅梅</td>
        <td>上海</td>
      </tr>
      <tr>
        <th>3</th>
        <td>露西</td>
        <td>深圳</td>
      </tr>
      <tr>
        <th>4</th>
        <td>小明</td>
        <td>鹤岗</td>
      </tr>
    </tbody>
  </table>
</body>

</html>
```

```css
:first-of-type 伪类与 :last-of-type 伪类的用法一定要和 :first-child 伪类与 :last-child 伪类的用法区分开。以 :first-of-type 伪类和 :first-child 伪类为例来说明：

:first-of-type 伪类是定位一组同类型的兄弟元素中的第一个元素，不管这个元素在兄弟元素中的位置如何。
:first-child 伪类是定位一组兄弟元素中的第一个元素，这些兄弟元素不一定是同类型的。
```



#### 2.3、:nth-child(n) 与 :nth-last-child(n)

```css
:nth-child(n) 伪类和 :nth-last-child(n) 伪类都是 CSS3 版本新增的选择器，这两个选择器的用法基本上是一致的。区别在于 :nth-last-child(n) 伪类是倒序方式定位元素，也就是说，:nth-last-child(n) 伪类是从一组元素的结尾开始的。

接下来，主要以 :nth-child(n) 伪类为例进行讲解。:nth-child(n) 伪类中的 n 参数的含义具有 3 种情况：

数字值：任意一个大于 0 的正整数。例如 #example td:nth-child(1) 表示定位 ID 为 example 的父元素下所有 <td> 元素中的第一个元素。

关键字：
odd 表示奇数，等同于 :nth-child(2n+1)
；even 表示偶数，等同于 :nth-child(2n)。
格式为 (an+b) 公式：a 表示周期的长度（步长），n 表示计数器（从 0 开始），而 b 则表示偏移值。
```

```css
例：
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>nth-child伪类</title>
  <style>
    table {
      width: 100%;
      border-collapse: collapse;
      /* 单元格边框共用一条边框 */
    }

    td {
      padding: 10px;
      border-top: 12px solid lightslategray;
      text-align: center;
    }

    table tr:nth-child(1) {
      font-weight: bold;
    }

    table tr:nth-child(odd) {
      background-color: red;
      /* odd奇数选择器 */
    }
  </style>
</head>

<body>
  <table id="example-element">
    <tbody>
      <tr>
        <td>序号</td>
        <td>姓名</td>
        <td>地点</td>
      </tr>
      <tr>
        <td>1</td>
        <td>李雷</td>
        <td>北京</td>
      </tr>
      <tr>
        <td>2</td>
        <td>韩梅梅</td>
        <td>上海</td>
      </tr>
      <tr>
        <td>3</td>
        <td>露西</td>
        <td>深圳</td>
      </tr>
      <tr>
        <td>4</td>
        <td>小明</td>
        <td>鹤岗</td>
      </tr>
    </tbody>
  </table>
</body>

</html>
```



#### 2.4、:empty

```css
:empty 伪类是用来定位没有任何子级元素或文本内容的元素，其中文本内容包含了空白。但是 HTML 的注释是不影响 :empty 伪类定位元素的。

如下示例代码展示了 :empty 伪类的用法：

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>empty伪类</title>
  <style>
    .box {
      background: pink;
      height: 80px;
      width: 80px;
      float: left;
      margin-left: 10px;
    }

    .box:empty {
      background: lime;
    }
  </style>
</head>

<body>
  <div class="box"><!-- 这是一个注释 --></div>
  <div class="box">这个元素的背景是粉色的</div>
  <div class="box"><!-- 这是一个注释，但有空格所以内容不为空 -->    </div>
</body>

</html>
```



## 阶段 8：盒子模型



#### 1、概述

```css
盒子模型又称为框模型，HTML页面所有的元素都具有盒子模型，该模型用于设计HTML页面和实现HTML页面布局

有外到内，可分为：外边距、边框、内边框、内容区

内容区（content）：用于显示文本和图像
内边距（padding）：内容区至边框的距离
边框（border）：内容区的边界
外边距（margin）：俩个元素边框之间的距离

可用width和height来规定盒子大小

元素占页面空间大小 实际宽度=width+padding（左和右）+border（左和右）
```

```css
例：
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
    div{
       background-color: aqua;
       color: blueviolet;
       width: 100px; 
       height: 100px;
    }
    #d1{
        border:10px solid red;
        padding: 30px;
        margin: 180px;

    }

    #d2{
        width: 50px;
        height: 50px;
        background-color: royalblue;
        padding: 20px;
      
    }

    </style>
</head>
<body>
    <div id="d1">
        <div id="d2"></div>
    </div>
</body>
</html>
```



#### 2、盒子的阴影

```css
box-shadow：5px 5px 5px black;
水平 垂直 模糊程度 颜色
```



#### 3、边框

```css
border
边框宽度和颜色不设置会有默认
边框样式style是必须设置的
边框属性按照上、右、下、左，四个方向划分

边框圆
border-radius:50px;
值为半径

如若值为俩个
border-radius:50px 25px;
那么方向便为左上和右下 右上和左下

如若值为4个
border-radius:2px 0px 0px 2px
左上   右上  右下  左下
```



#### 4、边框图像

```css
再插入图片前必须设置边框大小

border-image-source:xxx; 设置边框图片来源
border-image-width：30px; 设置边框图片的宽度
border-image-repeat:stretch; 设置边框图像的平铺方式 为拉伸
border-image-slice:  将边框切成9块，方便控制个区域大小和距离
border-image:url("xxxx") 30;
```



#### 5、内边距

```css
padding-top:20px;
padding-right:10px;
paading-bottom:10px
padding-left:20px;

padding: 上 右 下 左 ;
```



#### 6、外边距

```css
margin-left:100px; （控制当前元素水平方向的位置）
margin-top:100px； （控制当前元素垂直方向的位置）

margin-right:100px; (控制块级元素的下一个兄弟元素的位置)
margin-bottom:100px; (控制块级元素的下一个兄弟元素的位置)
```



##### 1、常见作用

```css
margin:0 auto;  （上下，左右）
可以实现元素水平方向居中
```



##### 2、常见问题

**（1）重叠**

```css
问题：
1、只能出现在兄弟关系的元素中
2、如若第一个块级元素用了bottom，第二个块级元素用了top，这俩个一起设置值的话，只会选择最大值，所以会出现重叠问题。
3、外边距重叠问题只会出现在上外边距和下外边距

解决：
1、不要同时设置俩个边距（bottom和top）
2、或者在其俩个元素之间添加第三个元素。
```

**（2）传递**

```css
问题：
1、出现在父子关系中
2、在父子关系中，如若在子级设置了上外边距的值，那么父级也受其影响，会和子级元素一起变动。

解决：
1、可以不在子级设置上外边距（bottom），而是在其父级中设置上内边距（padding）。（在修改padding时，也应该修改其对应的盒子宽高，因为padding会在盒子中填充空间，会使空间的大小发生变化）
```



#### 7、盒子类型

```css
box-sizing属性用于设置盒子模型的类型
有俩个值：
1、content-box   （为默认值，实际效果为内容区宽高+padding+border+margin。）
2、border-box  （称为怪异盒子模型，由微软提出。实际效果为内容区域宽高+外边距）

```



#### 8、知识点

```css
块级元素、内联元素、行内块级元素在盒子模型的效果：

1、块级元素：在盒子模型中所有功能都是可用的
2、内联元素：水平方向padding有效，垂直无效。垂直方向margin无效，水平有效
3、行内块级元素：在盒子模型中所有功能都是可用的

行内块级元素常用有：image、button、input
```



## 阶段 9：显示与溢出



### 一、显示与隐藏

#### 1、显示

```css
1、display:block;  （将元素设置为块级元素）
2、display:inline; （将元素设置为内联元素）
3、display:lnline-block;  （将元素设置为行内元素）
4、visibility:visible;
```



#### 2、隐藏

```css
1、display:none; （设置当前元素为隐藏，但会使该元素不会再占有页面空间）
2、visibility:hidden; （设置当前元素为隐藏，但会使该元素会依旧占有页面空间）

```



#### 3、display补充

```css
用于元素的呈现框的类型。

当使用none（关闭一个元素的显示），所有的后代元素的显示也会被关闭

也可以用display来设置表格，以前都这样使用，但是现在有了语义化table标签
```



### 二、内容溢出



#### 1、溢出状况

```
指定元素中的文本内容
或图片
或子级元素
超出元素范围叫溢出
```



#### 2、overflow属性

```css
overflow属性设置当前子元素内容若溢出父级元素（块级元素）时，是否剪辑内容，显示滚动条或显示溢出的内容。

该属性有以下几种值：
visible（默认值） 内容不会被修剪，会显示在父级容器之外
hidden （内容会被修剪，并且其余内容不可见）
scroll （内容会被修剪，浏览器会显示滚动条以便查看其余内容，不溢出也会显示滚动条）
auto   （由浏览器决定，如果内容超出便会显示滚动条，如果没有溢出什么也不会显示）

overflow-x （水平溢出属性）
overflow-y	（垂直溢出属性）

white-space:nowrap;  强制一行输出文本内容

caniuse   （这个网站可以查询新增的元素，那些浏览器支持或者不支持）


text-overflow 属性（确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号或显示一个自定义字符串）

有以下几个值：
clip：将文本内容超出父级容器的部分隐藏
ellipsis：将文本内容超出父级容器的部分使用省略号表示
string:将文本内容超出父级容器的部分使用指定文本内容表示

注意：使用text-overflow属性时，必须在前加上overflow属性。
```



## 阶段 10、定位



#### **文档流**

```
文档流HTML页面中元素在排列时所占用位置的一种规则。
将HTML页面中的元素直上向下分成一行一行，并在每行中按从左至右挨次排放元素，即为文档流。

文档流HTML页面的底层结构，HTML页面创建的元素默认都在文档流中。

如果一行中不能容纳所有元素，那么会换到下一行，继续自左向右排列。

有三种状况使得元素离开文档流存在，分别是浮动、绝对定位、固定定位。
```



### 一、浮动

#### 1、语法

```css
float属性 指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。

有以下几个值：
none （默认值，表示元素不浮动）
left （表示元素必须要浮动在其所在容器的左侧）
right（表示元素必须要浮动在其所在容器的右侧）

浏览器解析HTML页面提供默认规则：
1、块级元素是垂直方向排列。
2、内联元素或行内块级元素是水平方向排列。

注意：当前元素设置为浮动后，只影响其后面所有元素的位置。

如若所有元素都设置浮动话，块级元素排列顺序变为水平方向排列。

注意：若用margin实现水平居中：当前元素不能脱离文档流，也就是不能设置为浮动。
```



#### 2、块级元素的浮动

```css
块级元素默认的宽度是父级宽度的100%
高度是 0 或者 所有后代元素高度之和

如若设置为浮动后：宽或高默认是0或者所有后代元素宽或高之和

多个元素设置为浮动后：垂直方向排列变为水平方向排列，如果占满父级元素宽度的100%后，会自动换行。
```



#### 3、内联元素的浮动

```css
内联元素的默认宽高是内容的宽高

内联元素设置为浮动后：宽高属性便可手动设置

多个内联元素设置为浮动：元素之间依旧是水平方向排列
```



#### 4、行内块级元素

```css
当行内块级元素设置为浮动：元素之间的空白间隙被去掉
```



#### 5、浮动的特殊情况

```css
父级与子级的浮动：如若为子级元素设置为浮动，子级元素的浮动不能超出父级元素的范围

兄弟元素同时设置浮动（多个元素设置浮动）：会自动进行排列，若当前元素设置为浮动，但不会超出前一个兄弟元素

文本内容与浮动元素之间：文本内容不会被浮动的元素所覆盖，而是环绕在浮动元素的周围。

```



#### 6、清除浮动

```css
clear 属性设置元素是否显示在其之前元素的下方。

有以下几个值：
none：元素不会向下移动清除之前的浮动（不清除浮动）
left：元素被向下移动用于清除之前的左浮动
right：表示元素被向下移动用于清除之前的右浮动
both：元素被向下移动用于清除之前的左右浮动


使用clear属性俩种情况：
1、使用clear为非浮动元素清除浮动时，该元素将移动之前的浮动元素下方。
2、使用cleat为浮动元素清除浮动时，该元素将移动到之前浮动元素的下方，并且会影响之后浮动元素的布局。

可以用伪元素清除下个浮动，这样不会影响后面浮动元素的布局。
```



#### 7、高度塌陷

```css
出现问题条件：
1、存在于父级与子级之间的元素
2、父级元素没有设置高度
3、子级元素设置为浮动

解决方法：
1、给父级设置高度，但父级多的话会很繁琐
2、块级格式化上下文（BFC），默认是关闭的，需要手动设置给父级开启（开启后具有副作用）

开启方式：
1、将元素设置为浮动
2、将元素设置为绝对定位
3、将元素设置为行内块级元素
4、overflow属性值设置为visible的块级元素
```



#### 8、开启BFC 解决浮动带来的影响 案例

```css
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>BFC解决浮动带来的影响</title>
    <style>
    .container{
    
        border: 10px solid red;

        /* 父级开启BFC
           作用：子级元素脱离文档流，因为父级没有设置宽高，会有高度塌陷。
           这样父级了开启BFC，可以使开启浮动的块级子级不会乱跑，而去影响父级，而是受到父级的限制。
         */
        overflow: hidden;
    }
    .box{
        width: 400px;
        height: 200px;
        background-color: royalblue;
        float: left;
    }
    </style>
</head>
<body>
    <div class="container">
        <div class="box"></div>
    </div>
</body>
</html>
```



#### 9、行内块级（BFC）案例

```css
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>卡片悬停动态</title>
    <style>
  
    .container{
        margin: 0 auto;
        width:1000px;
        height: 600px;
        background-color: rgb(187, 216, 142);
    }
    .big_box{
        width: 90%;
        height: 80%;
        border: 1px solid rgba(79, 83, 93, 0.507);
        margin: 0px auto;
        position: relative;
        top:50%;
        /* 垂直效果 */
        transform:translate(0%,-50%) ;

        /* 把子级高度设的比父级高，实现溢出部分隐藏，方便图片的收缩 */
        overflow: hidden;
        
        box-shadow:0px 0px 10px 0px rgb(49, 48, 48) ;
       
   
    }
    .box{
        
        display: inline-block;
        width: 207px;
        height: 600px;
        margin-right: 20px;
    
        /* 父级使用行内块级，子级内容块会影响父级的变动        
         */


		/* 第一种：父级开启了bfc
		overflow属性值设置为visible，不会开启，其他属性都会开启
        1：便会使子级块中的内部的文本对齐方式，不会对父级产生影响，使其父级布局不受任何影响。
		
		2：使 BFC 内部的块级元素不会到处乱跑而去影响父级，不会脱离父级，而是受父级的限制。
		
		*/
		
        /* 父级开启BFC*/
        overflow: hidden; 
        
        


        /* 第二种：行内块级带来的影响，
        默认该元素的基线就是它的margin底边缘，
        或者是默认是该元素的内部元素最后一行内联元素的baseline（基线）对齐，
        这个是使子级元素并不会以基线对齐，而是以中线为基准 
        经测试发现，除了baseline无效，其他都有效果
        */
        vertical-align:middle;
		

        box-shadow:0px 0px 10px 0px rgb(49, 48, 48) ; 
		transition:all 0.5s;
       
    }
    .box:last-child{
        margin-right:0px;
    }
    .one{
        background-image: url("勇士.jpg");
        background-repeat: no-repeat;
        background-size: cover;
        background-position:center;
    }
   
    .two{
        background-image: url("萌神.jpg");
        background-repeat: no-repeat;
        background-size: cover;
        background-position:center;
    }
    .there{
        background-image: url("佛祖.jpg");
        background-repeat: no-repeat;
        background-size: cover;
        background-position:center;
    }
    .four{
   
        background-image: url("枸杞哥.jpg");
        background-repeat: no-repeat;
        background-size: cover;
        background-position:center;
    }
    .box:hover{
        /* 移动图片位置 */
        background-position:center -40px;
        background-size:cover;
    
        /* transform: perspective(500px) translateZ(-100px); */
        /* transform: skew(0deg,-1deg); */

    }

    .content{
        margin-top: 30px;
        width: 100%;
        height:100%;  
        text-align: center;
        color: rgb(247, 34, 69); 
        transition: all 0.5s;
        position:relative;
        top:410px;
    }
    p{
        margin-top: 50px;
    }
    button{
        background-color: rgb(170, 179, 187);
    }

    .box:hover .content{
        /* 大坑：px丢了个p（搞了20分钟），心态要炸 */
        top:0px;
    }
 
    </style>
</head>
<body>
    <!-- 外层容器 -->
    <div class="container">
        <!-- 中间大盒子 -->
        <div class="big_box">
            <!-- 第一个盒子 -->
            <div class="box one">
                <!-- 内容块 -->
                <div class="content" >
                    <h2>金州勇士队</h2>
                    <p>中文队名金州勇士队外文队名Golden State Warriors运动项目篮球角逐赛事NBA所属地区美国,加利福尼亚州,旧金山市成立时间1946年主场馆大通中心球馆 主要荣誉6次NBA总冠军</p>
                    <button>点击查看更多...</button>
                </div>
            </div>
            <!-- 第二个盒子 -->
            <div class="box two">
                <!-- 内容块 -->
                <div class="content" >
                    <h2>斯蒂芬.库里</h2>
                    <p>
                        中文名
                            斯蒂芬·库里 
                        外文名
                            Stephen Curry 
                        别    名
                            萌神 
                        国    籍
                            美国 
                        出生地
                            美国俄亥俄州阿克伦 
                        出生日期
                            1988年3月14日 
                        毕业院校
                            戴维森学院 
                        身    高
                            1.91米/6英尺3英寸 
                        体    重
                            83.9公斤/185磅 
                        运动项目
                            篮球 
                        所属运动队
                            金州勇士队 
                        专业特点
                            投篮准、出手速度快、善于抢断与投三分球
                    </p>
                    <button>点击查看更多...</button>
                </div>
            </div>
            <!-- 第三个盒子 -->
            <div class="box there">
                <!-- 内容块 -->
                <div class="content" >
                    <h2>克莱·汤普森</h2>
                    <p>
                        中文名克莱·汤普森外文名Klay Thompson别    名佛祖、汤神 [5] 国    籍美国出生地美国加利福尼亚州洛杉矶出生日期1990年2月8日毕业院校华盛顿州立大学身    高2.01米/6英尺7英寸体    重97.5公斤 [6] 运动项目篮球 克莱·汤普森是顶级的三分射手，需要优化投篮选择；自主进攻平平，很少传球，能在低位背打对手；防守端兼具臂展和移动，能够盯防控卫。 [128]  （新浪体育评）
                    </p>
                    <button>点击查看更多...</button>
                </div>
            </div>
            <!-- 第四个盒子 -->
            <div class="box four">
                <!-- 内容块 -->
                <div class="content" >
                    <h2>安德鲁.维金斯</h2>
                    <p>
                        中文名
                        安德鲁·威金斯 
                    外文名
                        Andrew Wiggins 
                    别    名
                        枸杞哥 [8]  
                    国    籍
                        加拿大 
                    出生地
                        加拿大多伦多 
                    出生日期
                        1995年2月23日 
                    毕业院校
                        堪萨斯大学 
                    身    高
                        2.03米/6英尺8英寸
                    </p>
                    <button>点击查看更多...</button>
                </div>
            </div>
        </div>     
    </div>
</body>
</html>
```



### 二、定位



```
提升网页中现实的优先级
网页中有三层：普通元素层 < 浮动元素层 < 定位元素层
```



#### 1、语法

```css
position属性用于指定元素在HTML页面中定位的方式。
有以下几个值：
static （默认值，表示元素为静态定位，不开启定位）
absolute（表示元素为绝对定位。不为元素预留空间，也就是说不占用下个元素的空间）脱离文档流
fixed   （表示元素为固定定位。不为元素预留空间，固定在浏览器页面上）脱离文档流
relative （相对定位，不改变页面布局前提下修改位置）

注意：margin对于脱离文档元素作用无效
```

#### 2、绝对定位

```css
1、如果当前元素的父级元素是body元素，那么结果相对于当前页面定位
2、如果当前元素的父级不是body元素，且父级元素没有开启定位，那么结果是相对于当前页面的定位。
3、如果当前父级元素不是body元素，父级元素开启定位那么结果是相对于父级元素的定位。
```

#### 3、相对定位

```
相对定位相对于自身原来位置的定位
```



#### 4、堆叠

```css
z-index 属性指定了一个具有定位属性的元素及其子代元素的z-order。
当元素之间重叠时，z-order决定哪一个元素覆盖其余元素上方显示。
通常z-index属性值较大会覆盖较小的一个。

注意：必须在开启定位的前提下

```



#### 5、继承

```css
指该样式属性不仅可以作用在当前元素，还会继续应用在该元素的所有后代元素

inherit 属性加这个值表示当前元素继承于元素父级样式
```



#### 6、层叠

```css
如何合并来自多个源的属性值的算法。

三种来源：
1、浏览器对HTML定义的默认样式
2、用户定义的样式
3、开发者定义的样式

开发者会覆盖用户定义的样式，用户定义的样式会覆盖浏览器定义的默认样式

层叠顺序：
1、首先过滤来自不同源的全部规则，并保留要应用到指定元素上的那些规则
2、其次，依据重要性对那些规则进行排序。层叠是按升序排序
3、假如层叠顺序相等，则使用哪个值决于 优先级别（属于层叠）

!import 破坏了样式表中的固有级联规则，不建议使用
```

 

## 阶段11、表单



### 一、概述

```
表单是用户与服务器端之间交互的主要方式之- -。 简单来说，表单允许用户输入数据，并将这些数据发送给服务器端进行处理。
表单是由一个或多个小部件组成的，这些部件可以是文本字段、选择框或者按钮等。而这些部件被称为表单的组件。
表单与HTML页面其他元素的区别在于，表单允许接收用户输入数据，而其他元素更多是向用户展示数据。
在实际应用中，比较常见的表单有搜索框、用户登录或用户注册等功能。

```

```css
<form>元素表示为表单。在该元素中允许定义表单的组件元素，用于接收用户输入的数据，井将这些发送给服务器端。

action设置指定服务器端的地址路径

<form action="https://blog.3xnb.com" method="post" enctype=">
<input type="text" name="username">  
<input type="submit" value="登录">
</form>

```

```css
<form>元素-表单

★作用 -将用户输入的数据，发送给服务器端

1.如果获取用户输入的数据内容（method属性）
2.将数据内容发送给服务器端（action属性，用来设置服务器地址路径）

action属性-设置服务器端的地址路径
method属性- 发送给服务器端的方式(请求方式)
GET-为默认值，将请求数据添加在请求地址中（地址栏输入数据大小受限制，且数据内容不安全）
POST -- -般为提交表单的方式（请求数据被添加到请求头中）
```

```css
enctype属性

<form>元素enctype属性用于设置将当前表单数据提交的MIME类型，该类型主要分以下两种:
●application/x- -www -form-urlencoded:默认值，表示当前提交为表单数据。
●multipart/form-data: 该值用于表单组件中<input type=“file” >文件域时，实现文件上传功能。
该属性的值可以被<input type=“su Jbmit”>元素或者<bu tton type=“submit”>沅素中的formenctype属性所覆盖。


示例：
<body>
< !--
	<form>元素-实现文件上传功能
	* method属性-设置为POST
	*enctype属性-设置提 交表单时，数据内容的MIME类型
	*application/x-www- form-urlencoded -为默认值
	* multipart/ form-data 修改为实现文件上传功能
--> 

<form acti on="#" method="post" enctype="multi part/form-data">
    <input type="file" name="'myFile">
    <input type="submit'">
</ form>

< /body>

```

```css
组合表单元素

<fieldset>元素用于将相关的表单组件进行分组，显示效果一般为一条边框。
<legend>元素与<fieldset>元素配合使用，用于设置这一分组的标题。

<form action="http://www.wolongxueyuan.com" method="POST">
	<fieldset>
		<legend>卧龙学苑</legend>
		<input type="text" name="username">
		<input type="submit" value="提交">
	</fieldset>
</form>

```





### 二、input（输入框）

#### 1、type

```css
<input type=“text”> 默认是文本输入框

input元素表示表示输入框控件，其type属性值如下：

text（默认文本输入框）

password（密码输入框）行内块级元素，图片也是

以下是新增类型
email（email地址框，和submit配合使用，文本框输入内容时便需要验证，验证格式是否正确）

submit（提交）

URL地址（输入网页网址，验证格式，也是与submit配合使用）

search（搜索框，仅在移动端有效）

tel（电话框，仅在移动端有效）

date（日期选择框，提供日期选择）
month（年、月）
week（年、周）
time（时间）

type属性表示控件的类型

```

```css
input元素表示表示选择控件，其type属性值如下：

color（选择颜色控件）
number（选择数字控件，限制只能输入数字）
range（滑动条控件）
```

```css
input元素表示表示按钮控件，其type属性值如下：

submit（表示提交的按钮，特殊按钮）
reset（表示重置的按钮，特殊按钮）
button（表示按钮，普通按钮，没有其他功能但属于表单的组件，配合value=“我是一个按钮”）

如果在表单中不用type属性值为button，而是用button元素作为子元素，那么其具有表单的提交功能
```

```css
input元素表示图像组件，其type属性值如下：

image（图像组件，src="xxx.jpg"），与表单有关，在表单内使用，也可以提交表单
```



#### 2、其他属性

```css
1、value（设置默认文字或获取文本输入框的值）
时间也可以设置（xxxx-xx-xx）

2、disabled（表示不可用，不可点用，属性和值一样，可以省略值）

3、readonly属性（表示只读，不可写，和disabled功能类似，但显示样式不同）
```



#### 3、输入框样式

```css
placeholder属性（提供默认提供信息）
outofocus属性（自动获取焦点，光标闪动的效果）

```



#### 4、单选框

```css
type属性值为radio

加上name属性，当属性值为一样便为一组

checked（选中的状态，值为true表示被选中，为false表示没被选中）

vlue（方便其他使用可以获取值）

```



#### 5、多选框

```css
checkbox属性表示多选，语法和单项一样
```



#### 6、文件上传域

```css
type属性值为file，表示文件域，用于接收用户选择本地需要上传的文件。

允许用户在页面中选择本地文件，默认允许读取所有文件类型，并且是单文件域

有以下属性配合使用：
multiple：表示允许选择多个文件
accept：表示允许选择的文件类型。一般值为MUME类型，例如：audio/* 、 video/* 等格式。

例：
accept="image/png"
前缀表示文件类型，后缀扩展名称
```



#### 7、隐藏域

```css
type="hidden"

页面中不做任何显示效果，用户不知道该元素的存在
通过该元素的value属性存在一些不需要用户知道的数据内容

问题：不安全，未加密
```



#### 8、lable元素

```css
作用：仅仅是显示文本内容，与指定元素相关联
for属性的值指定相关联元素的id属性值



示例：
<input type="text" id="username">
<lable for="username">用户名:</lable>

因为label中有for 可以获取到值，所以lable显示在任何位置都可以
```



### 三、textarea（文本域）

```css
文本域，默认是可以拖动文本框大小（实现效果，例如：评论框效果）

css中加入 resize：none； 便可让文本框固定，不可改变大小

例：
<textarea cols="30"rows="10">< /textarea>

```



### 四、select（下拉列表）

```css
<select>元素表示下拉列表，可以是下拉单选框，也可以是下拉多选框。该元素常见属性如下:
●id属性:元素的标识，唯一不可重复。
●name属性:元素的名称，-般用于提交表单。
●value属性:元素的值，-般用于获取当前元素被选中的值。
●disabled属 性:表示不可用。
<select>元素-般与<option>元素配合使用,其中<option>元素表示列表项。
<option>元素还可以由<optarouD>元素进行分组。


例：
<select>
<option value="apple"> 苹果</option>
<option selected value="xi aomi">小米< /option>
<option value="weihua"> 华为</option>
</select>

默认显示第一个下拉option，且默认为单选框


下拉多选框.
* multiple属性表示多选
*size属性表示显示的个数

例：
<select multiple size="3">
<option value="apple"> 苹果</option>
<option selected value="xi aomi">小米< /option>
<option value="weihua"> 华为</option>
</select>


```



### 五、表单验证

```css
表单验证就是指在表单提交时，对表单内组件中的数据内容进行检查是否符合输入要求。例如单行文
本框是否为空等效果。
HTML.5中提供一些自带表单验证的表单组件元素，并且还提供了一系列具有表单验证功能的属性。


HTML 5中提供一些自 带表单验证的表单组件元素，具体内容如下:
●<input type=“email”>沅素具有验证输入内容是否符合Email地址格式要求。
●<input type=“ur!” >元素具有验证输入内容是否符合URL地址格式要求。
●<input type=“number”>元素具有限制输入内容必须为数字值。
●<input type=“color” 沅素具有限制输入内容必须为颜色值。
● <input type=“tel”>元素具有限制输入内容必须为数字值。
●<input type=“date” >元素具有限制输入内容必须为日期格式。

HTML 5中提供了一系列具有表单验证功能的属性，具体内容如下:
●required属性:表示验证指定表单组件元素是否为空。
●pattern属性:表示验证指定表单组件元素的值是否与该属性的值指定的正则表达式匹配。
●
min属性:表示验证指定表单组件元素的值是否大于等于该属性的值。
●
max属性:表示验证指定表单组件元素的值是否小于等于该属性的值。
●step属性: 表示限制指定表单组件元素每次增加或减少的步长。
●minlength属性: 表示验证指定表单元素值的长度是否小于等于该属性的值。
●maxlength属性:表示验证指定表单元素值的长度是否大于等于该属性的值。

```



## 补充

### 1、a标签配合使用动态效果

```css
link（设置链接默认的样式）
hover（鼠标悬停的样式）
active（鼠标点击链接，没有释放的样式）
visited（链接被访问过的样式）
```



### 2、z-index前提

```
必须开启定位，才能实现
```



# 二、CSS 3.0



## 一、渐变

```
利用css渐变替代HTML页面中引入渐变的拼图，这样减少HTML页面加载的时间，减小带宽的占用

由于css渐变是由浏览器直接生成，在HTML页面缩放时的效果比图片更好，使得可以便捷地调整HTML页面布局

css中新增的渐变主要分以下三种：
线性渐变
径向渐变
重复渐变
```



### 1、线性渐变

```css
线性渐变由一个轴（基准线）定义的，并且轴上每个点都具有独立的颜色。linear-gradient() 函数构建垂直于基准线的渐变效果，渐变的颜色取决于与之垂直相交的基准线上的色点。


linear-gradient（45deg，blue，red） 函数

angle：通过角度来定义方向，0度表示渐变方向从下向上，90度渐变从左到右，其角度按照顺时针方向增加
side-or-corner：通过关键字定义渐变方向。left，right，top，bottom
```

![](https://jine.oss-cn-beijing.aliyuncs.com/image/23.png)

![](https://jine.oss-cn-beijing.aliyuncs.com/image/111.png)





### 2、径向渐变

```
径向渐变由其中心点、边缘形状轮廓、位置以及颜色结束点定义的。

径向渐变的中心点至边缘形状以及其延伸的部分是由连续缩放的若干同心轮廓组成的。


颜色结束点用于设定虚拟渐变射线的变化方式，由中心点水平变化至右侧。颜色结束点由百分比设定，中心点为0%，终止点为100%。终止点为渐变射线与边缘形状相交点的渐变半径。

```

![](https://jine.oss-cn-beijing.aliyuncs.com/image/24.png)

```css
radial-gradient（blue，red） 没有加改变形状的参数，默认是椭圆

shape：定于渐变的形状，包括circle（圆形），ellipse（椭圆形）
position:设置起点坐标值（例：radial-gradient（circle at 50% 0% ，blue ，red））
size：规定形状大小（半径大小），圆形大小就是半径大小，椭圆形大小就是一个短半径和一个长半径的大小


extent-keyword：用于定义径向渐变的边缘形状的位置。
closest-side：渐变的边缘形状与容器距离渐变中心点最近的一边相切（圆形）或者渐变的边缘形状与距离渐变中心点最近的垂直和水平边相切（椭圆）。
closest-corner：渐变的边缘形状与容器距离渐变中心点最近的一个角相交。
farthest-side：与closest-side相反，边缘形状与容器距离渐变中心点最远的一边相切（或最远的垂直和水平边）。
farthest-corner：渐变的边缘形状与容器距离渐变中心点最远的一个角相交。
color-stop：用于定义径向渐变的颜色终止点。


```



#### 滤镜练习

![](https://jine.oss-cn-beijing.aliyuncs.com/image/lvj.png)

```css
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
    html,body{
        width:100%;
        height: 100%;
    }
    .container{
        margin: 0px;
        background-image: linear-gradient(-10deg, #7028e4 0%,#e5b2ca 100%);
        width: 100vw;
        height: 100vh;
    }
    .box{
        width: 200px;
        height: 200px;
        margin: 0 auto;
        background: linear-gradient(45deg,rgba(23, 160, 202, 0.7),rgba(168, 16, 206, 0.7));
        position: relative;
        top:-200px;
        border-radius: 50%;
    }
    img{
        display: block;
        width: 200px;
        height: 200px;
        border-radius: 50%;
        margin: 0 auto;
    }
    </style>
</head>
<body>
    <div class="container">
        <img src="https://jine.oss-cn-beijing.aliyuncs.com/image/wjs.jpg" alt="">
        <div class="box"></div>
    </div>
</body>
</html>
```



#### 渐变综合练习

![](https://jine.oss-cn-beijing.aliyuncs.com/image/text.png)

```css
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
    html,body{
        width: 100%;
        height: 100%;
    }
    div{
        width: 300px;
        height: 200px;   
        float: left; 
        margin: 20px;  
    }
    .box1{
        background:linear-gradient(0deg,blue,red);
    }
    .box2{
        background: linear-gradient(45deg,blue,red);
    }
    .box3{
        background: linear-gradient(90deg,blue,red);
    }
    .box4{
        background: linear-gradient(to top,blue,red);
    }
    span{
        float: left;
        display: block;
        width: 100%;
    }
    hr{
        width: 100%;  
    }
    .rg1{
        background: radial-gradient(circle ,blue,red);
    }
    .rg2{
        background: radial-gradient(circle at 30% ,blue ,red);
    }
    .rg3{
        background:radial-gradient(closest-side,blue,red)
    }
    .rg4{
        background:radial-gradient(closest-corner,blue,red)
    }
    .rg5{
        background:radial-gradient(farthest-side,blue,red)
    }
    .rg6{
        background:radial-gradient(farthest-corner,blue,red)
    }



    </style>
</head>
<body>
    <div class="box1"></div>
    <div class="box2"></div>
    <div class="box3"></div>
    <div class="box4"></div>
    <span><hr></span>
    <div class="rg1"></div>
    <div class="rg2"></div>
    <div class="rg3"></div>
    <div class="rg4"></div>
    <div class="rg5"></div>
    <div class="rg6"></div>
 
</body>
</html>
```



#### 3d小球练习

![](https://jine.oss-cn-beijing.aliyuncs.com/image/ball.png)

```css
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        .box{
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 1px solid #42098b;
            background: radial-gradient(circle at 33% 30%,#DFFFDF,rgb(91, 39, 187),#42098b);
            box-shadow:5px 4px 9px rgb(0, 0, 0);
            position: relative;
            margin: 0  auto;;
            margin-top: 190px;
            
        }
    </style>
</head>
<body>
    <div class="box"></div>
</body>
</html>
```



### 3、重复渐变

```css
CSS3 中的线性渐变和径向渐变不支持自动重复的渐变“模式”

但可以通过 repeating-linear-gradient() 函数和 repeating-radial-gradient() 函数来实现重复的渐变效果。
```



#### 重复线性渐变

```css
repeating-linear-gradient() 创建一个由重复线性渐变组成的图片

语法：repeating-linear-gradient(<angle> | <side-or-corner>, <color-stop>, <color-stop> +)


angle：通过角度来定义渐变的方向。0度表示渐变方向从下向上，90度表示渐变从左向右。其角度按照顺时针方向增加。
side-or-corner：通过关键字定义渐变的方向。具有两个关键字，一个表示水平位置（left或right），一个表示垂直位置（top或bottom）。关键字的先后顺序无影响，并且都是可选的。
```



#### 重复径向渐变

```css
repeating-radial-gradient() 函数用于创建一个表示由中心点辐射开的径向渐变的图片


语法：repeating-radial-gradient([ [ <shape> ] || <extent-keyword> ] [ at <position> ]?)

shape：用于定义径向渐变的形状，包含circle（圆形）和ellipse（椭圆形）。
extent-keyword：用于定义径向渐变的边缘形状的位置。
position：用于定义径向渐变的中心点位置。
color-stop：用于定义径向渐变的颜色终止点
```



#### 唱片案例

```css
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>重复径向渐变实现唱片效果</title>
    <style>
        .radial-gradient {
            position: relative;
            width: 262px; 
            height: 262px;
            border-radius: 50%;
            background: linear-gradient(30deg, transparent 40%, rgba(42, 41, 40, .85) 40%) no-repeat 100% 0, linear-gradient(60deg, rgba(42, 41, 40, .85) 60%, transparent 60%) no-repeat 0 100%, repeating-radial-gradient(#2a2928, #2a2928 4px, #ada9a0 5px, #2a2928 6px);
            background-size: 50% 100%, 100% 50%, 100% 100%;
        }
        .radial-gradient::after {
            position: absolute;
            top: 50%; 
            left: 50%;
            margin: -35px;
            border: solid 1px #d9a388;
            width: 68px; height: 68px;
            border-radius: 50%;
            box-shadow: 0 0 0 3px #ee1141, inset 0 0 0 27px #14d179;
            background: #b5ac9a;
            content: '';
        }
    </style>
</head>
<body>
    <div class="radial-gradient"></div>
</body>
</html>
```



## 二、变形



### 1、概述

```css
通过修改坐标，CSS transforms 属性可以在不影响正常文档流的情况下改变作用内容的位置。

CSS transforms 包括一系列 CSS 属性，通过这些属性可以对 HTML 元素进行变形。可以进行的变形包括旋转，倾斜，缩放以及位移，同时适用于平面以及三维空间。

在空间中实现 CSS 变形会稍微复杂一点。首先必须设置一个透视点（perspective）来配置 3D 空间，然后定义 2D 元素在空间中的变形。

```



### 2、属性

```css
CSS transform 属性

允许你修改 CSS 视觉格式模型的坐标空间。使用它，元素可以被转换（translate）、旋转（rotate）、缩放（scale）、倾斜（skew）。 

transform: none | <transform-list>

该 CSS 属性可用于内联元素和块级元素。其默认值为 none，表示匹配元素不进行任何变形。
transform-list：表示作用于元素的一个或多个变形的 CSS 函数。如果为多个函数的话，使用空格进行分隔。

```

```css
transform-origin 属性

CSS transform-origin 属性允许更改一个元素变形的原点。默认情况，变形的原点在元素的中心点，或者是元素 X 轴和 Y 轴的 50% 处。

transform-origin: [ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?

上述语法结构可以拆分成如下所示：
/* 设置一个值 */
transform-origin: x-offset
transform-origin: offset-keyword
/* 设置两个值 */
transform-origin: x-offset y-offset
transform-origin: x-offset-keyword y-offset-keyword
/* 设置三个值 */
transform-origin: x-offset y-offset z-offset
transform-origin: x-offset-keyword y-offset-keyword z-offset


俩个值：
transform-origin: left top;
transform: scale(0.5, 0.5);
```

```css
transform-style 属性

CSS transform-style 属性确定元素的子元素是否位于 3D 空间中，还是在该元素所在的平面内被扁平化。
如果被扁平化，则子元素不会独立的存在于三维空间。

transform-style: flat | preserve-3d

flat：指定子元素位于此元素所在平面内
preserve-3d：指定子元素定位在三维空间内
```

```css
perspective 属性

CSS perspective 属性指定了观察者与 z=0 平面的距离，使具有三维位置变换的元素产生透视效果。z>0 的三维元素比正常大，而 z<0 时则比正常小，大小程度由该属性的值决定。

三维元素在观察者后面的部分不会绘制出来，即z轴坐标值大于 perspective 属性值的部分。
默认情况下，消失点位于元素的中心，但是可以通过设置 perspective-origin 属性来改变其位置。
当该属性值不为 0 和 none 时，会创建新的层叠上下文。
```

```css
perspective-origin 属性

CSS perspective-origin 属性指定了观察者的位置，在属性 perspective 中被用作消失点。该属性实际上设置 X 轴和 Y 轴位置，在该位置观察者好像在观看该元素的子元素。

perspective-origin: x-position /* one-value syntax */
perspective-origin: x-position y-position /* two-value syntax */

x-position：指定消失点的水平方向坐标。
y-position：指定消失点的垂直方向坐标
```

```css
backface-visibility 属性

CSS backface-visibility 属性指定当元素背面朝向观察者时是否可见。元素的背面总是透明的，当其朝向观察者时，显示正面的镜像。
在某些情况下，我们不希望元素内容在背面可见，比如实现翻牌效果。
因为 2D 变换无透视效果，故该属性对 2D 变换无效。

backface-visibility: visible | hidden

visible：表示背面可见，允许显示正面的镜像。
hidden：表示背面不可见。

```



### 3、2D效果



#### 位移

```css
translate() 函数用于将元素向指定的方向进行移动，类似于 position 中的 relative。使用 translate() 函数移动元素时，不会影响在 X 轴或 Y 轴上其他元素。

translate(tx) 或者 translate(tx, ty)

```



#### 2D缩放

```css
scale() 函数用于将元素根据中心原点进行缩放，默认值为 1。如果该值的范围在 0.01 至 0.99 之间的话，表示缩小；如果该值是大于 1 的值，则表示放大。

scale(sx) 或者 scale(sx, sy)

```



#### 2D旋转

```css
rotate() 函数用于通过指定的角度将元素根据原点进行旋转。该函数主要用于 2D 空间进行旋转。如果该角度值为正值的话，表示顺时针旋转；如果该角度值为负值的话，则表示逆时针旋转。

rotate(angle)

angle：表示旋转的角度值，单位为 deg。

```



#### 2D倾斜

```css
skew() 函数用于将元素以其中心位置围绕着 X 轴和 Y 轴按照一定的角度倾斜。与 rotate() 函数的旋转不同，rotate() 函数只是旋转，而不会改变元素的形状。skew() 函数不会旋转，而只会改变元素的形状。

skew(ax) 或者 skew(ax, ay)

```



### 4、3D效果



#### 位移

```css
translateZ() 函数用于将元素在 3D 空间沿 Z 轴进行位移。

translateZ(t)
t：表示 Z 轴移动的偏移量。当其值为正值时，元素向 Z 轴越移动越近，导致元素变得越大；反之其值为负值时，元素向 Z 轴越移动越远，导致元素变得越小。

CSS3 中还提供了 translate3d() 函数用于将元素在 3D 空间进行位移
translate3d(tx,ty,tz)
tx：表示 X 轴移动的偏移量。
ty：表示 Y 轴移动的偏移量。
tz：表示 Z 轴移动的偏移量。

```



#### 3D缩放

```css
scaleZ() 函数用于将元素在 3D 空间沿 Z 轴进行缩放。

scaleZ(s)
s：表示 Z 轴的缩放向量。
CSS3 中还提供了 scale3d() 函数用于将元素在 3D 空间进行缩放

scale3d(sx,sy,sz)
sx：表示 X 轴的缩放向量。
sy：表示 Y 轴的缩放向量。
sz：表示 Z 轴的缩放向量。

```



#### 3D旋转

```css
rotateZ() 函数用于将元素在 3D 空间沿 Z 轴进行旋转

rotateZ(a)
a：表示 Z 轴进行旋转。


CSS3 中还提供了 rotate3d() 函数用于将元素在 3D 空间进行旋转。
rotate3d(x,y,z,a)
x：表示 X 轴旋转的矢量值。
y：表示 Y 轴移动的矢量值。
z：表示 Z 轴移动的矢量值。
a：表示旋转的角度值。

```



## 三、过渡



### 1、概述

```css
CSS transition 提供了修改 CSS 的样式属性值时控制值变化时间的方式。简单来说，控制某一个或者多个 CSS 的样式属性值由一个值到另一个值，并不是立即生效，而是持续指定时间的过程。
例如通过 transition 属性控制指定元素的背景颜色经历 2 秒的时长从白色变为黑色，而不是立即改变。

CSS transition 属性可以设定指定元素的哪些 CSS 样式属性发生过渡效果、何时开始、持续多久以及如何执行动画效果等。

```



### 2、transition属性

```css
CSS transition 属性是一个简写属性，该属性可以为指定元素在不同状态之间定义不同的过渡效果。该属性可以分为以下几种子属性：
transition-property 属性：用于定义过渡效果中的样式属性名称。
transition-duration 属性：用于定义过渡效果执行动画的时长。
transition-timing-function 属性：用于定义过渡效果计算的函数。
transition-delay 属性：用于定义过渡效果开始的延迟时间。

```



#### 浏览器兼容性

```css
transition 属性虽然已加入 CSS3 的标准规范中，但是有些浏览器仍然需要添加前缀才能正常使用
/* WebKit引擎的浏览器（Chrome、Safari、Opera） */
-webkit-transition : <single-transition>;
/* Gecko引擎的浏览器（Firefox） */
-moz-transition : <single-transition>;
/* Trident引擎的浏览器（IE 10+） */
-ms-transition : <single-transition>;
/* Presto引擎的浏览器（Opera） */
-o-transition : <single-transition>;

```



### 3、过渡子属性



#### 过渡属性名称

```css
transition-property 属性用于设定指定元素执行过渡动画的 CSS 样式属性名称。该属性的语法结构如下：

transition-property : none | all | <single-transition-property>

none：表示没有任何用于执行过渡动画的CSS样式属性。
all：默认值，表示指定元素所有支持过渡动画的CSS样式属性。
single-transition-property：表示过渡动画的样式属性。
值得注意的是，不是所有的 CSS 样式属性都支持过渡动画（参考支持过渡动画属性列表）。

transition-property: none;
transition-property: all;
transition-property: width height;

默认值为all
```



#### 过渡属性所需时间

```css
transition-duration 属性用于设定过渡动画执行所需的时长，单位为秒或毫秒。默认值为 0 秒，表示不出现过渡动画。

该属性允许设置多个时长，每个时长会被应用到 transition-property 属性设置的CSS样式属性上。
如果指定的时长的个数小于属性的个数，则时长列表会被重复，以与属性的个数匹配。
如果指定的时长的个数大于属性的个数，则时长列表会被裁减。
值得注意的是，上述两种情况下，通过 transition-property 属性设置的 CSS 样式属性列表始终保持不变。

transition-duration: 6s;
transition-duration: 120ms;
transition-duration: 1s, 15s;


可以配合过渡属性名称一起使用，当然也可以简写
例： transition：background 2s，width 3s ;
```

```css
练习例子：

.container{
        width: 300px;
        height: 300px;
        background-color: brown;
        transition-property:  background,height ;
        transition-duration: 10s,2s;
    
    	/* 可简写为
        transition:background 10s,height 2s; */
    
    	/*时长个数小于属性个数，会以第一个设置的值对于没有写的值
     	 transition-duration: 1s; */
    
    	/*时长个数大于属性个数(最后一个10s会被裁减掉)
    	 transition-duration: 1s,100s,10s; */
        

    }
    .container:hover{
        height: 100px;
        background-color: cornflowerblue; 
    }
```



#### 过渡延迟时间

```css
transition-delay 属性用于设置指定元素开始过渡动画之前需要等待的时长，单位为秒或毫秒。
如果值为正数时，则表示延迟多长时间开始过渡动画。
如果值为负数时，则导致立即开始执行过渡动画。

设置过渡动画之前需要等待的时长
```



#### 过渡函数

```css
transition-timing-function 属性用于设置过渡动画执行过程的中间值是如何计算的。该属性可以设定浏览器的过渡速度以及过渡过程中的操作进展情况，通过该属性会建立一条加速度曲线，该加速度曲线会被作用到每个过渡的 CSS 样式属性。

transition-timing-function : <single-transition-timing-function>

single-transition-timing-function：用于过渡的计算函数。
ease：默认值，元素样式从初始状态过渡到终止状态时速度由快到慢。
linear：元素样式从初始状态过渡到终止状态时速度是匀速。
ease-in：元素样式从初始状态过渡到终止状态时速度由慢到快。
ease-out：元素样式从初始状态过渡到终止状态时速度由快到慢。
ease-in-out：元素样式从初始状态过渡到终止状态时，先加速再减速。
step：将整个过渡过程划分成相同大小的间隔，每个间隔是相等的。

```



#### 多个过渡效果

```css
很多时候，需要通过改变两个或多个 CSS 样式属性实现过渡动画效果。

可以通过过渡子属性进行设置：
transition-property: background, border-radius;
transition-duration: 2s, 3s;
transition-timing-function: linear, ease-in;
transition-delay: 2s, 4s;

可以通过过渡简写属性进行设置：
transition: background 2s linear 2s, border-radius 3s ease-in 4s;

```



### 4、伪类触发过渡

```css
过渡动画效果可以通过 CSS 的伪类进行触发，例如鼠标悬停（:hover）、获取焦点（:focus）等。

.transition{
	background: #8ec63f;
	width: 100px;
	height: 100px;
	border-radius: .5em;
	-webkit-transition: background 2s linear 2s, border-radius 3s ease-in 4s;
	-moz-transition: background 2s linear 2s, border-radius 3s ease-in 4s;
	-o-transition: background 2s linear 2s, border-radius 3s ease-in 4s;
	-ms-transition: background 2s linear 2s, border-radius 3s ease-in 4s;
	transition: background 2s linear 2s, border-radius 3s ease-in 4s;
}
.transition:hover {
	background:#f7941d;
	border-radius: 50%;
}

```



### 5、JS触发器过渡（了解）

```css
过渡动画效果也可以通过 JavaScript 逻辑代码触发。

<style>
.transition{
	background: #8ec63f;
	width: 100px; height: 100px;
	border-radius: .5em;
	transition: background 2s linear 2s, border-radius 3s ease-in 4s;
}
</style>
<div id="box" class="transition"></div>
<script>
	var box = document.getElementById('box’);
	box.addEventListener('mouseover', function(){
		box.style.background = '#f7941d’;
		box.style.borderRadius = '50%’;
	});
</script>

```

```css
transitionend 事件

transitionend 事件在 CSS transition 属性实现过渡动画执行完毕时被触发

transitionend 事件提供了以下两个属性：
propertyName 属性：字符串类型，表示已完成过渡动画的 CSS 样式属性。
elapsedTime 属性：浮点类型，表示当 transitionend 事件被触发时过渡动画已执行的时间（单位为秒）。该属性值不会受到 transition-delay 的影响。

/*
 * 在指定的元素上监听transitionend事件, 例如#slidingMenu
 * 然后指定一个函数, 例如 showMessage()
 */
function showMessage() {
	console.log('Transition 已完成');
}
var element = document.getElementById('slidingMenu');
element.addEventListener('transitionend', showMessage);

```



## 四、动画



### 1、概述

```css
CSS3 新增 animation 属性使得仅通过 CSS 的样式属性实现动画效果成为可能。

实现动画包括以下两个部分：
用于定义动画的样式规则
用于设置动画开始、结束以及中间点样式的关键帧

相对于传统使用 JavaScript 实现的动画方式，CSS3 新增的 animation 属性具有以下三个优点：
能够非常容易地创建简单动画，甚至不需要掌握 JavaScript。
动画运行效果良好，可以在低性能的系统运行。性能以及流畅程度都优于 JavaScript 实现的动画效果。
允许浏览器优化动画的性能和效果，让浏览器控制动画序列。

原因：浏览器的内核：1. 引擎专门解析HTML和CSS；2.引擎专门解析JavaScript
```



### 2、定义动画序列



#### @keyframes 声明动画

```css
通过使用 @keyframes 建立两个或两个以上关键帧来实现。每一个关键帧都描述了动画元素在给定的时间点上应该如何渲染。

必须要先定义关键帧动画名称（并且至少包含俩个关键帧：开始和结束）

@keyframes <keyframes-name> {
	<keyframe-block-list>
}

keyframes-name：用于设置当前动画的名称，以便通过 animation-name 属性调用。

keyframe-block-list：用于设置动画执行过程中的关键帧。

属性值：
0% 或 from
100% 或 to
```



#### 调用 @ keyframes 动画

```css
通过使用 @keyframes 建立建立动画序列后，需要通过 animation 属性或者 animation-name 属性调用。

@keyframes slideLeft {
	0% { left: -500px; }
	100% { left: 0; }
}
.slideLeft:target {
	z-index: 100;
	animation-name: slideLeft;
	animation-duration: 1s;
	animation-iteration-count: 1;
}

```



### 3、动画子属性

```css
CSS animation 属性是一个简写属性，用于创建复杂的动画序列，并控制 CSS 的样式属性实现动画效果。该属性可以分为以下几个样式属性：

animation-name：用于设置关键帧动画的名称，该属性值必须与 @keyframes 规则相对应。
animation-duration：用于设置动画执行所需的时长。
animation-timing-function：用于设置动画的执行方式，与 过渡中的 属性类似。
animation-delay：用于设置开始执行动画之前需要等待的时长。
animation-iteration-count：用于设置动画执行的循环次数。
animation-direction：用于设置动画执行的方向。
animation-play-state：用于设置动画执行的状态。
animation-fill-mode：用于设置动画的时间外属性。
```

```css
想要通过 CSS3 新增的 animation 属性实现动画效果，首先需要确认当前浏览器是否支持该样式属性。

var animation = false,
    animationstring = 'animation‘,
    keyframeprefix = ‘’,
    domPrefixes = 'Webkit Moz O ms Khtml'.split(' ‘),
    pfx = ‘’,
    elm = document.createElement('div');
if( elm.style.animationName !== undefined ) { 
	animation = true; 
} if( animation === false ) {
	for( var i = 0; i < domPrefixes.length; i++ ) {
		if( elm.style[ domPrefixes[i] + 'AnimationName' ] !== undefined ) {
			pfx = domPrefixes[ i ];
			animationstring = pfx + 'Animation’;
			keyframeprefix = '-' + pfx.toLowerCase() + '-’;
			animation = true;
			break;
		}
	}
}
```



#### animation-name 属性

```css
用于应用指定的一系列动画，每个动画名称都是由 @keyframes 规则定义

/* Single animation */
animation-name: none;
animation-name: test_05;
/* Multiple animations */
animation-name: test1, animation4;
```



#### animation-duration 属性

```css
用于设置动画执行的时长。默认值为 0 秒，表示无动画效果。

animation-duration: 6s;
animation-duration: 120ms;
animation-duration: 1s, 15s;
```



#### animation-timing-function 属性

```css
用于设置动画执行的方式。

/* Keyword values */
animation-timing-function: ease;  默认值，元素样式从初始状态过渡到终止状态时速度由快到慢。
animation-timing-function: ease-in; 元素样式从初始状态过渡到终止状态时速度由慢到快。
animation-timing-function: ease-out; 元素样式从初始状态过渡到终止状态时速度由快到慢。
animation-timing-function: ease-in-out; 元素样式从初始状态过渡到终止状态时，先加速再减速。
animation-timing-function: linear; 元素样式从初始状态过渡到终止状态时速度是匀速。
animation-timing-function: step-start; 将整个过渡过程划分成相同大小的间隔，每个间隔是相等的。
animation-timing-function: step-end;
/* Function values */
animation-timing-function: cubic-bezier(0.1, 0.7, 1.0, 0.1);
animation-timing-function: steps(4, end);
```



#### animation-delay 属性

```css
用于设置动画开始执行之前需要等待的时间。默认值为 0 秒，表示动画立即执行。

animation-delay: 3s;
animation-delay: 2s, 4ms;
```



#### animation-iteration-count 属性

```css
用于设置动画执行的次数。默认值为 1，表示动画只执行一次。

animation-iteration-count: infinite; （无限次）
animation-iteration-count: 3;
animation-iteration-count: 2.3;

```



#### animation-direction 属性

```css
用于设置动画是否反向执行。

animation-direction: normal;（默认效果）
animation-direction: reverse;（反向开始）
animation-direction: alternate;（不断交替效果，次数需要大于1）
animation-direction: alternate-reverse;（反向不断交替，次数需要大于1）

```



#### animation-play-state 属性

```css
用于设置动画是运行还是暂停。通过该样式属性可以确定动画是否正在执行。
用js可看出效果

animation-play-state: running;
animation-play-state: paused;

```



#### animation-fill-mode 属性

```css
用于设置动画执行之前和执行之后如何为动画的目标元素应用样式。

animation-fill-mode: none;（默认效果，例：一开始为红色背景，加上动画变蓝色，但最后执行完，会恢复红色）
animation-fill-mode: forwards;（会保留最后的动画效果，而不会还原为默认效果）
animation-fill-mode: backwards;（和默认效果开始之前有些区别（会先是蓝色效果）最后会恢复成红色效果，也就是默认效果）
animation-fill-mode: both;（运用了forwards和backwards的共性）

MDN解释
none：当动画未执行时，动画将不会将任何样式应用于目标，而是已经赋予给该元素的 CSS 规则来显示该元素。这是默认值。
forwards：目标将保留由执行期间遇到的最后一个关键帧计算值。 最后一个关键帧取决于animation-direction和animation-iteration-count的值
backwards：动画将在应用于目标时立即应用第一个关键帧中定义的值，并在animation-delay期间保留此值。 第一个关键帧取决于animation-direction的值
both：动画将遵循forwards和backwards的规则，从而在两个方向上扩展动画属性。
```



### 4、案例练习



#### 综合练习

```css
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>动画练习</title>
    <style>

    @keyframes animate{
        0% {
            width:100px;
            height: 100px;
        }

        50% {
            width:300px;
            height: 300px;
            border-radius: 50%;
            background: linear-gradient(45deg,blue,pink);
        }

        100% {
            width:500px;
            height: 500px;
            background: linear-gradient(45deg,blue,red);
        }

    }
    .animation{
        margin: 0 auto;
        width: 100px;
        height: 100px;
        background-color: blue;
        animation-name: animate;
        animation-duration: 5s;
        animation-iteration-count: 1;
        animation-direction: alternate;
        animation-fill-mode:forwards;
        
    }
    </style>
</head>
<body>
    <div class="animation"></div>
</body>
</html>
```



#### 圆盘转动

```css
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>圆盘转动</title>
    <style>
    @keyframes animate{
        from{
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: linear-gradient(45deg,blue,pink);
            transform:  perspective(500px) rotateZ(0deg);
        }

        to{
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: linear-gradient(45deg,blue,pink);
            transform: perspective(500px) rotateZ(360deg);
        }
    }
    .animation{
        margin: 0 auto;
        width: 300px;
        height: 300px;
        border-radius: 50%;
        background: linear-gradient(45deg,blue,pink);
        animation-name: animate;
        animation-duration: 1s;
        animation-iteration-count: infinite;
        animation-timing-function: linear;
    }
    span{
        float: left;
        display: block;
        width: 100%;
    }
    hr{
        width: 100%;  
    }
    </style>
</head>
<body>
    <div class="animation"></div>
    <span><hr></span>
</body>
</html>
```



#### 大风车转动

```css
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>大风车转动</title>
    <style>
        *{
            padding:0;
            margin:0;
        }
        body,html{
            width: 100%;
            height: 100%;
            overflow:hidden;
        }
        @keyframes move{
            from{
                transform:rotate(0deg);
            }
            to{
                transform:rotate(360deg);
            }
        }
        #box{
            width:200px;
            height:200px;
            margin:100px auto;
            position:relative;
            -webkit-animation:4s move linear infinite running;
        }
        #box div{
            width: 100px;
            height: 50px;
            border-radius:0 0 50px 50px;
            -webkit-transform-origin:right center;
            position:absolute;
        }
        .red{
            background:-webkit-radial-gradient(right,circle,red,#000);
            transform:translateX(100px) translateY(100px);
        }
        .yellow{
            background:-webkit-radial-gradient(right,circle,yellow,#000);
            transform:translateX(-25px) translateY(175px) rotateZ(90deg);
        }
        .blue{
            background:-webkit-radial-gradient(right,circle,blue,#000);
            transform:translateX(-100px) translateY(50px) rotateZ(180deg);
        }
        .green{
            background:-webkit-radial-gradient(right,circle,green,#000);
            transform:translateX(25px) translateY(-25px) rotateZ(-90deg);
        }
        #box .dot{
            width: 20px;
            height: 20px;
            background:-webkit-radial-gradient(rgba(255,255,255,1),rgba(0,0,0,1));
            border-radius:50%;
            top:50%;
            left:50%;
            margin:-10px 0 0 -10px;
        }
 
    </style>
</head>
<body>
    <div id="box">
        <div class="red"></div>
        <div class="yellow"></div>
        <div class="blue"></div>
        <div class="green"></div>
        <div class="dot"></div>
    </div>
</body>
</html>
```





## 五、弹性盒子



### 1、概述

```css
CSS3 新增了弹性盒子模型（Flexible Box 或 FlexBox），是一种新的用于在 HTML 页面实现布局的方式。使得当 HTML 页面适应不同尺寸的屏幕和不同的设备时，元素是可预测地运行。

弹性盒子模型实现 HTML 页面布局是与方向无关的。不类似于块级布局侧重垂直方向，内联布局侧重水平方向。

弹性盒子模型主要适用于 HTML 页面的组件以及小规模的布局，而并不适用于大规模的布局，否则会影响 HTML 页面性能。
```

![](https://jine.oss-cn-beijing.aliyuncs.com/image/%E5%9B%BE%E7%89%871.png)

```css
伸缩容器（flex container）：包裹伸缩项目的父元素。
伸缩项目（flex item）：伸缩容器的每个子元素。
轴（axis）：每个弹性盒子模型拥有两个轴。
主轴（main axis）：伸缩项目沿其一次排列的轴被称为主轴。
侧轴（cross axis）：垂直于主轴的轴被称为侧轴。
方向（direction）：伸缩容器的主轴由主轴起点和主轴终点，侧轴由侧轴起点和侧轴终点描述伸缩项目排列的方向。
尺寸（dimension）：根据伸缩容器的主轴和侧轴，伸缩项目的宽度和高度。
对应主轴的称为主轴尺寸。
对应侧轴的称为侧轴尺寸。


注意：主轴和侧轴并不是水平也不是按垂直方向，而是按照属性设置的，默认是水平方向排列，默认水平是主轴。可以进行设置更改主轴，侧轴便是垂直主轴排列
```



### 2、定义弹性盒子

```css
CSS3 中想要设置为弹性盒子模型的话，需要通过 display 样式属性设置值为 flex 或 inline-flex 即可。(一般在父级元素设置)


display : flex;
display : inline-flex;


按照上述示例代码设置指定元素为弹性盒子模型，该元素成为伸缩容器，其子元素则成为伸缩项目。
flex：设置指定元素为块级元素的弹性盒子模型。
inline-flex：设置指定元素为行内块级元素的弹性盒子模型。
弹性盒子模型依旧存在浏览器兼容问题：

display : -webkit-flex;
display: -ms-flex;
display: -moz-flex;
display: -o-flex;

```



### 3、**flex-direction** 属性

```css
CSS flex-direction 属性适用于伸缩容器元素，用于创建主轴的方向。
flex-direction: row | row-reverse | column | column-reverse

row：设置主轴是水平方向。
row-reverse：与 row 的排列方向相反。
column：设置主轴是垂直方向。
column-reverse：与 column 的排列方向相反。


通过这个属性便可更改弹性盒子的主轴方向，默认是row行
```

```css
案例练习

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>弹性盒子练习</title>
    <style>
    .container{
        width: 1200px;
        height: 800px;
        border: 1px solid black;
        margin: 200px auto;
        display: flex;
        /* 主轴为垂直方向，并且按反序 */
        flex-direction: column-reverse;
        /* display: inline-flex; */  
    }
    .box{
        width: 300px;
        height: 300px;
    }

    .box.one{
        background-color: red;
    }
    .box.two{
        background-color: lightpink;
    }
    .box.there{
        background-color: lightseagreen;
    }
    .box.four{
        background-color: maroon;
    }
    .box.five{
        background-color: orangered;
    }
    </style>
</head>
<body>
    <div class="container">
        <div class="box one"></div>
        <div class="box two"></div>
        <div class="box there"></div>
        <div class="box four"></div>
        <div class="box five"></div>
    </div>
</body>
</html>
```



### 4、**justify-content** 属性（主轴）

```css
center：伸缩项目向第一行的中间位置对齐（项目中间无间距，整行开始结尾有间距）。
flex-start：伸缩项目向第一行的开始位置对齐。（项目直接顶到开始位置，项目间无间距）
flex-end：伸缩项目向第一行的结束位置对齐。
space-between：伸缩项目会平均分布在一行中。（开始和结尾没有间距，只有中间有，等分间距）
space-around：伸缩项目会平均分布在一行中，两端保留一半的空间。（开始和结尾也有间距）
justify-content: center | flex-start | flex-end | space-between | space-around
CSS justify-content 属性适用于伸缩容器元素，用于设置伸缩项目沿着主轴线的对齐方式。（用于每个子项目元素之间的设置）

```

```css
案例练习：本案例因为设置的主轴方向为纵向，而且又用的center所以整列无间隙便以垂直方向居中对齐

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>弹性盒子练习</title>
    <style>
    .container{
        width: 1200px;
        height: 800px;
        border: 1px solid black;
        margin: 200px auto;
        display: flex;
        flex-direction: column;
        /*项目中间无间距，整行开始结尾有间距*/
        justify-content: center
            
        /* 每个项目之间等分间距空白，俩边开始和结尾没有间隙 */
        /* justify-content:space-between; */
            
            /*俩边都有间隙，每个项目之间也有间隙
            justify-content: space-around;*/
            
    }
    .box{
        width: 200px;
        height: 100px;
    }

    .box.one{
        background-color: red;
    }
    .box.two{
        background-color: lightpink;
    }
    .box.there{
        background-color: lightseagreen;
    }
    .box.four{
        background-color: maroon;
    }
    .box.five{
        background-color: orangered;
    }
    </style>
</head>
<body>
    <div class="container">
        <div class="box one"></div>
        <div class="box two"></div>
        <div class="box there"></div>
        <div class="box four"></div>
        <div class="box five"></div>
    </div>
</body>
</html>
```





### 5、**align-items** **属性**（侧轴，项目元素）

```css
align-items: center | flex-start | flex-end | baseline | stretch
CSS align-items 属性适用于伸缩容器元素，用于设置伸缩项目所在行沿着侧轴线的对齐方式。
center：伸缩项目向侧轴的中间位置对齐。
flex-start：伸缩项目向侧轴的起点位置对齐。
flex-end：伸缩项目向侧轴的终点位置对齐。
baseline：伸缩项目根据伸缩项目的基线对齐。
stretch：默认值，伸缩项目拉伸填充整个伸缩容器。（子级项目如若设置高度便不生效，不设置高度便拉伸填充）

```

```css
本案例因属性和主轴属性类似，只对stretch进行演示

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>弹性盒子练习</title>
    <style>
    .container{
        width: 1200px;
        height: 800px;
        border: 1px solid black;
        margin: 200px auto;
        display: flex;
        flex-direction: row;
        
        /* 侧轴自动拉伸 */
        align-items:stretch;
    }
    .box{
        /* 因为主轴设置的是row，那么侧轴便是垂直方向，当不设置子级项目元素的高度时，便可生效，否则便按照设置的高度 */
        width: 200px;
        
    }

    .box.one{
        background-color: red;
    }
    .box.two{
        background-color: lightpink;
    }
    .box.there{
        background-color: lightseagreen;
    }
    .box.four{
        background-color: maroon;
    }
    .box.five{
        background-color: orangered;
    }
    </style>
</head>
<body>
    <div class="container">
        <div class="box one"></div>
        <div class="box two"></div>
        <div class="box there"></div>
        <div class="box four"></div>
        <div class="box five"></div>
    </div>
</body>
</html>
```



### 6、**flex-wrap** **属性**（单、多行）

```css
CSS flex-wrap 属性适用于伸缩容器元素，用于设置伸缩容器的子元素是单行显示还是多行显示。
flex-wrap: nowrap | wrap | wrap-reverse
nowrap：设置伸缩项目单行显示。这种方式可能导致溢出伸缩容器。
wrap：设置伸缩项目多行显示。
wrap-reverse：与 wrap 相反。

```

```css
本案例练习：
如若子级项目元素超出父级元素，那子级元素会在下一行显示。
如若设置成nowrap，便会将子级元素压缩，强制单行显示（这个也是针对主轴设置的方向来决定的）默认是nowrap

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>弹性盒子练习</title>
    <style>
    .container{
        width: 1000px;
        height: 800px;
        border: 1px solid black;
        margin: 200px auto;
        display: flex;
        flex-direction: row;
        /*多行显示*/
        flex-wrap: wrap;
    }
    .box{
      
        width: 200px;
        height: 200px;    
    }

    .box.one{
        background-color: red;
    }
    .box.two{
        background-color: lightpink;
    }
    .box.there{
        background-color: lightseagreen;
    }
    .box.four{
        background-color: maroon;
    }
    .box.five{
        background-color: orangered;
    }
    .box.six{
        background-color: limegreen;
    }

    </style>
</head>
<body>
    <div class="container">
        <div class="box one"></div>
        <div class="box two"></div>
        <div class="box there"></div>
        <div class="box four"></div>
        <div class="box five"></div>
        <div class="box six"></div>
    </div>
</body>
</html>
```



### 7、**align-content** **属性** （侧轴，多行）

```css
CSS align-content 属性适用于伸缩容器元素，用于设置伸缩行的对齐方式。该属性会更改 flex-wrap 属性的效果。
align-content: center | flex-start | flex-end | space-between | space-around | stretch

center：各行向伸缩容器的中间位置对齐。
flex-start：各行向伸缩容器的起点位置对齐。
flex-end：各行向伸缩容器的终点位置对齐。
space-between：各行会平均分布在一行中。
space-around：各行会平均分布在一行中，两端保留一半的空间。
stretch：默认值，各行将会伸展以占用额外的空间。
```

```css
本案例：只对侧轴，且是行与行之间的设置

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>弹性盒子练习</title>
    <style>
    .container{
        width: 500px;
        height: 500px;
        border: 1px solid black;
        margin: 200px auto;
        display: flex;
       
        flex-wrap: wrap;
        align-content: center;
      
      
    }
    .box{
 
        width: 150px;
        height: 150px;
        
    }

    .box.one{
        background-color: red;
    }
    .box.two{
        background-color: lightpink;
    }
    .box.there{
        background-color: lightseagreen;
    }
    .box.four{
        background-color: maroon;
    }
    .box.five{
        background-color: orangered;
    }
  

    </style>
</head>
<body>
    <div class="container">
        <div class="box one"></div>
        <div class="box two"></div>
        <div class="box there"></div>
        <div class="box four"></div>
        <div class="box five"></div>
        <div class="box six"></div>
    </div>
</body>
</html>
```



#### 8、**flex-flow** **属性**

```css
CSS flex-flow 属性适用于伸缩容器元素，该属性是 flex-direction 和 flex-wrap 的简写。
flex-flow: <'flex-direction'> || <'flex-wrap'>

```



### 9、**flex** **属性**

```css
CSS flex 属性是一个简写属性，用于设置伸缩项目如何伸长或缩短以适应伸缩容器中的可用空间。
flex: auto | none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
auto：伸缩项目会根据自身的宽度和高度确定尺寸，相当于将该属性设置为“flex: 1 1 auto”。
none：伸缩项目会根据自身的宽度和高度确定尺寸，相当于将该属性设置为“flex: 0 0 auto” 。

```



### 10、**align-self** **属性**

```css
CSS align-self 属性适用于伸缩容器元素，用于设置伸缩项目自身元素在侧轴的对齐方式。
align-self: center | flex-start | flex-end | baseline | stretch
center：伸缩项目向侧轴的中间位置对齐。
flex-start：伸缩项目向侧轴的起点位置对齐。
flex-end：伸缩项目向侧轴的终点位置对齐。
baseline：伸缩项目根据伸缩项目的基线对齐。
stretch：默认值，伸缩项目拉伸填充整个伸缩容器。

```



### 11、**order** **属性**

```css
CSS order 属性适用于伸缩项目，用于设置伸缩项目在布局时的顺序。
order: <integer>
integer：表示当前伸缩项目所在的次序。
```





# 三、JavaScript



## 一、基础概念



### 1、概述

```css
JavaScript 语言是一门弱类型、基于原型的直译式脚本语言，运行于 JavaScript 解释器/引擎。JavaScript 解释器/引擎最早是浏览器核心的一部分，广泛地被用来支持客户端的脚本语言（不仅包含 JavaScript 语言），最早是支持 HTML 页面的运行。

JavaScript 语言内置了一个包含一系列对象的标准库，比如数组、日期、数学和一个语言元素集合包括操作符、流程控制及语句等语法内容。

JavaScript 解释器/引擎是作为 JavaScript 脚本代码的运行环境，目前主要的呈现方式有 2 种，如下所示：

独立安装的 JavaScript 解释器/引擎，例如 Node.js 就是利用 Chrome 浏览器的 JavaScript V8 版本引擎创建的 JavaScript 运行环境。
嵌入在各个浏览器内核中的 JavaScript 解释器/引擎，目前主流浏览器都支持该解释器/引擎，例如 Chrome、Firefox 等浏览器。
```

![image-20200330142030114](https://jine.oss-cn-beijing.aliyuncs.com/image/js.png)

```css
JavaScript 诞生于 1995 年，其主要的作用是用来替代之前由服务器端语言（如 Java 语言等）负责的一些输入验证等操作。但 JavaScript 的发展历史远不止于此，如下所示：

1992 年，Nombas 公司为自己的 CEnvi 软件开发了一款脚本语言 ScriptEase，可以嵌入在网页中。
1995 年， Netscape 公司为自己的 Navigator2.0 浏览器开发了另一种客户端脚本语言 Livescript，后来因为 Netscape 公司与 SUN 公司合作，NetScape 公司的管理层希望该语言看起来像 Java 语言，因此后改名为 JavaScript。
1996 年，Microsoft 公司为了取得技术上的优势，在 IE3 中加入了 JScript（为避开 JavaScript 的版权问题）。
1997 年，JavaScript 1.1 作为草案提交给 ECMA（全称为 European Computer Manufacturers Association，译为欧洲计算机制造商协会），完成了 ECMA-262 —— 定义了名为 ECMAScript 的脚本语言标准。
提示：JavaScript 注册商标是属于 Oracle （甲骨文）公司的。
```

```css
虽然大部分经常把 JavaScript 和 ECMAScript 划为同一个概念，但实际上 JavaScript 语言所包含的内容要比 ECMAScript 多得多。完整的 JavaScript 语言其实是由 3 个部分组成的，如下所示：

ECMAScript：JavaScript 语言的核心，是 ECMA-262 标准化的脚本语言的名称。
DOM：全称为 Document Object Model，译为文档对象模型，是用来 W3C 组织制定的标准接口规范。
BOM：全称为 Browser Object Model，译为浏览器对象模型，提供了一系列对象可以与浏览器窗口进行交互。
```

### 2、js核心

#### ECMAScript

```
ECMAScript 语言是一门由 ECMA 组织根据 ECMA-262 标准定制的脚本程序设计语言，该语言的内容包含了语法、类型、语句、关键字和操作符等内容。

**ECMA** 的全称为 European Computer Manufacturers Association，译为欧洲计算机制造商协会，后来更名为 ECMA 国际，是一家国际性会员制度的信息和电信标准组织。

很多脚本语言的核心都是 ECMAScript，JavaScript 语言只是众多脚本语言中的一种，例如 Adobe 公司的 ActionScript 同样实现了 ECMAScript。

在 2015 年之前，ECMAScript 的最新一个版本是第 5 版本，发布于 2009 年。在 2015 年发布了版本号为 2015 的新版本，俗称 ECMAScript 6。

与此同时，ECMA 国际对外宣布此后每年都会发布一个新版本，并且版本号使用年份命名。截止到目前（*2019 年*）已经发布了 2016、2017 以及 2018 等新版本，并且还会以每年一个新版本的速度进行迭代更新。
```



#### 文档对象模型（DOM）

**DOM** 是一个简写，其全称为 Document Object Model，译为文档对象模型，是针对 XML 但经过扩展用于 HTML 的应用程序编程接口。

DOM 会把整个 HTML 页面映射为一个多层的节点结构，HTML 页面中的每一个组成部分都是这个节点结构中的某种类型的节点。

如下示例代码展示了简单的 HTML 页面源代码：

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>HTML页面示例</title>
</head>

<body>
  <h1>这是一个示例页面.</h1>
</body>

</html>
html
```

DOM 映射上述 HTML 页面为一个节点结构如下所示：

![0101.png](http://changetm.oss-cn-beijing.aliyuncs.com/Temp/bc74cc0c-f8c0-4d6f-bfab-aa6b3414eab7.png)



#### 浏览器对象模型（BOM）

```
BOM 同样是一个简写，全称为 Browser Object Model，译为浏览器对象模型，是允许开发人员访问和修改浏览器窗口的对象集合。

BOM 经常导致出问题的原因是 BOM 作为 JavaScript 语言的组成部分之一，但是却没有相关标准。换句话讲，各个浏览器对 BOM 可能都支持，但是具体用法上可能存在差异。不过，在 HTML5 中已经得到了解决，HTML5 版本将 BOM 的很多内容都写进了标准规范中。

BOM 提供了一系列与浏览器窗口进行互动的对象，如下所示：

- window 对象：代表浏览器窗口，可以修改浏览器窗口显示的大小等功能。
- navigator 对象：该对象提供了当前浏览器的详细信息，包含了浏览器名称、浏览器版本、当前操作系统信息等。
- screen 对象：代表当前显示器，提供了用户显示器分辨率等信息。

上述所罗列的对象并不是 BOM 中包含的所有对象，在后续章节中再详细讲解 BOM 的内容。除了上述这些对象之外，还提供了 XMLHttpRequest 这种自定义对象。
```



### 3、JavaScript 应用

```
JavaScript 语言最初的作用是运行在浏览器中，完成浏览器窗口中输入验证的一些操作。但 JavaScript 发展到目前为止，已经远不止于此。
```



#### 客户端 JavaScript

```
这里的客户端主要还是指 Web 浏览器，这部分的 JavaScript 提供了 BOM 和 DOM 等对象集来扩展 JavaScript 核心。例如客户端版本直接支持应用将元素放在 HTML 表单中并且支持响应用户事件，比如鼠标点击、表单提交和页面导航等操作。
```

目前主流浏览器的内核都集成了 JavaScript 解释器/引擎，如下图所示：

![0102.png](http://changetm.oss-cn-beijing.aliyuncs.com/Temp/b8ee46e9-f6d3-4036-8f75-1d2f43af95c6.png)



#### 服务器端 JavaScript

```css
自从 Node.js 的面市，使得 JavaScript 同样可以完成传统服务器端语言完成的事情。Node.js 提供了一系列 API 扩展 JavaScript 核心。例如服务端版本直接支持应用和数据库通信，提供应用不同调用间的信息连续性，或者在服务器上执行文件操作。

Node.js 的介绍如下图所示：
```

![0103.png](http://changetm.oss-cn-beijing.aliyuncs.com/Temp/af1b79b9-74cc-483b-9157-eb9582016416.png)

![](https://jine.oss-cn-beijing.aliyuncs.com/image/nodejs.png)



#### 物联网 JavaScript

JavaScript 语言目前也可以应用于物联网领域，国产厂商推出的 Ruff.js 就是支持 JavaScript 开发应用的物联网操作系统。Ruff.js 同样提供了一系列 API 扩展 JavaScript 核心。

Ruff.js 的介绍如下图所示：

![0104.png](http://changetm.oss-cn-beijing.aliyuncs.com/Temp/445a480d-76f0-4814-bf0d-426f45fb2f3c.png)



#### 人工智能 JavaScript

人工智能领域被认为是未来十大趋势之一，JavaScript 语言有幸可以参与其中，这要归功于 Google 公司。Google 公司曾推出人工智能领域的 TensorFlow 开发框架，同样提供了 JavaScript 版本。TensorFlow.js 框架是基于 JavaScript 语言的机器学习库，允许使用 JavaScript 语言开发 ML，并运行在浏览器或者 Node.js 环境中。

TensorFlow.js 的介绍如下图所示：

![0105.png](http://changetm.oss-cn-beijing.aliyuncs.com/Temp/80fa7cfd-e052-4278-872c-2483b262af66.png)



#### 总结

```css
本小节主要讲解了 JavaScript 语言的概念、发展简史、组成部分以及目前主要的应用场景。需要关注的重点如下：

- JavaScript 是一种弱类型、基于原型的语言，这是 JavaScript 语言最为重要的特性。
- JavaScript 的组成部分是 3 个：ECMAScript、DOM 和 BOM，并不只是 ECMAScript。
- JavaScript 语言目前的应用已经不仅仅局限于 Web 浏览器客户端，还有很多新的应用场景。

JavaScript 的主流运行环境，包含了浏览器运行环境和独立解释器运行环境两种。无论是浏览器环境还是独立解释器环境，都是将来我们使用 JavaScript 语言的主流运行环境。

浏览器运行环境：各个浏览器的内核基本上都集成了 JavaScript 解释器/引擎。
独立解释器运行环境：目前比较场景的独立解释器环境是 Node.js 提供的运行环境。
```



## 二、语法



### 区分大小写

```css
JavaScript 语言是一种区分大小写的语言。也就是说，JavaScript 语言中的关键字、变量名、函数名，以及所有标识符采用了统一的大小写形式。

HTML不区分大小写
```



### 可选的分号

```css
一般情况下，JavaScript 语言会使用分号（;）作为一条语句的结束，这对 JavaScript 语言的可读性和整洁性是非常重要的。

例：
var sum = a + b;var diff = a - b;

但在 JavaScript 语言中的分号也并不是必不可少的。如果 JavaScript 语言中的每一条语句都独占一行的话，那么用来表示结束的分号就可以省略。

例:
var sum = a + b
var diff = a - b
（不在一行）

```



### 语句

```css
JavaScript 语言将多行代码组合成一个代码块。
一般情况下，每一个代码块的开始使用左花括号 {  结束使用右花括号 }

例：
if (test) {
  console.log('我在一个代码块中.')
}
```



### 注释

```css
单行注释：使用 // 表示注释的开始。
多行注释：使用 /* 作为注释的开始，使用 */ 作为注释的结束。
```



### 关键字

```css
所谓关键字，就是在 JavaScript 语言中具有特殊用途的一组标识符，这些标识符是不能被用作变量名或者函数名的。关键字是由 ECMA-262 标准定制的，不同版本的 ECMA-262 标准中的关键字可能会有差异。

如下图展示了 ECMA-262 第 5 版本中的关键字：
```

![](http://changetm.oss-cn-beijing.aliyuncs.com/Temp/72a56fa7-4354-4794-9597-493f1d8e3644.png)



### 保留字

```css
除了关键字，JavaScript 语言还定义了另一组同样不能用作变量名或者函数名的标识符，这就是保留字。所谓保留字，就是目前在 JavaScript 语言中还没有明确的特殊用途，将来可能会成为关键字的一组标识符。

保留字同样是由 ECMA-262 标准定制的，不同版本的 ECMA-262 标准中的保留字也可能会有差异。

如下图展示了 ECMA-262 中的一些保留字：
```

![0202.png](http://changetm.oss-cn-beijing.aliyuncs.com/Temp/5554a6ce-c635-46d4-9bc2-299705974c01.png)



### 变量

```javascript
变量是一个拥有名字的用来存储数据信息的容器。JavaScript 语言中的变量是弱类型/松散类型的，所谓弱类型/松散类型就是指一个变量可以存储任何类型的数据信息。换句话讲，JavaScript 语言中的变量只是一个占位符而已。

如下示例代码展示了 JavaScript 语言的变量是如何定义和使用的：

var message = '这是一个测试内容.' //变量的声明
console.log(message) //变量的调用

开发中通过使用变量要达到的目的具有 2 个：
存储数据信息：声明一个变量用来存储指定数据信息。
读取数据信息：调用一个变量从而得到其存储的数据信息。

可以只声明未初始化，也可既声明也初始化
```



### 命名规则

```css
必须以字母、下划线（_）、美元符号（$）开始。
不能以数字开头。
不能使用关键字和保留字作为名称。
由于 JavaScript 是区分大小写的，大写字母与小写字母并不冲突。
名称最好有明确的含义。
可以采用“匈牙利命名法”、“下划线命名法”、“小驼峰命名法”或“大驼峰命名法” 之一，在开发团队内进行协调统一。

如下示例代码展示了几种变量命名的方式：

var helloWorld = 'Hello World' //小驼峰命名法
var HelloWorld = 'Hello World' //大驼峰命名法
var hello_world = 'Hello World' //下划线命名法
```



### 重复的声明

```
在 JavaScript 语言中使用 `var` 关键字重复声明变量是允许的，并且不会有任何问题。只不过由于 JavaScript 语言中的变量只能存储一个数据信息，所以当重复声明变量并进行初始化的话，之前的数据信息将会被覆盖。如下示例代码所示：
```

```javascript
var msg = 'this is message' // 值为 this is message
var msg = 100 // 值为 100
```

```javascript
也可对变量的值进行修改:

var jine ="Hello World";
jine=3;
console.log(jine);

```



### 常量

```css
在 ECMAScript 5 版本之后，JavaScript 语言提供了声明常量的语法内容，即提供了 const 关键字来声明常量。如下示例代码所示：

const MY_CONSTANT = '这是一个常量'

注意：
1、常量在声明时必须要进行初始化操作，否则会报错！
2、常量声明一般是大写的
3、如果不使用 var 或者 const 关键字的话，则 JavaScript 默认会将其解释为变量
4、相同的常量不可重复声明，否则会报错！
```



### 数据类型

```css
JavaScript 语言是一种弱类型/松散类型的脚本语言。这就意味着，在声明变量是不需要指定数据信息的类型，在执行代码的时候，JavaScript 语言会自动确定数据类型。

在 ECMAScript 5 版本及之前的版本中，提供了 5 种基本类型（也称为原始类型）和 1 种复杂类型，如下所示：

5 种基本数据类型：boolean、null、undefined、number 和 string 类型
1 种复杂数据类型：Object 类型
```

```css
JavaScript 在 ECMAScript 5 版本及之前版本提供的 5 种基本数据类型，我们为了方便进行学习可以进一步划分为基本数据类型和特殊数据类型两种：

基本数据类型：boolean、number 和 string 类型
特殊数据类型：null 和 undefined 类型
而上述 3 种基本数据，在 JavaScript 语言中还提供了对应的全局对象，如下所示：

Boolean 对象
Number 对象
String 对象
为了更好地区分 3 种基本数据类型和 3 个全局对象，我们可以借鉴 Java 语言中的做法，如下所示：

将 3 种基本数据类型称为原始数据类型（英文中统一称为 primitive data types）
将 3 个全局对象称为包装类型
在 JavaScript 语言所提供的对象中，除了 Object 及上述 3 个包装类型之外还提供了一系列的全局对象，例如 Array、RegExp、Date 等，我们可以将其称为引用类型。

按照这样划分的话，JavaScript 语言的数据类型被进一步的划分为了如下几种：

原始类型：boolean、number 和 string 类型
包装类型：Boolean、Number 和 String 类型
特殊类型：Null 和 Undefined 类型
引用类型：Array、RegExp、Date、... ... 类型
```



### 原始类型

```css
原始类型又称为基本类型，在 JavaScript 语言的 ECMA-262 标准中指的是 boolean、number、string、null 和 undefined 类型。

我们为了方便学习，将 null 和 undefined 两个类型划分为特殊类型。所以，我们这里所说的原始类型指的是 boolean、number 和 string 这三种类型。

这三种原始类型，也可以称为原始值，是 JavaScript 语言中最底层的数据类型。声明变量或常量并初始化值为原始类型时，一般称为字面量/直接量方式声明变量。

如下示例代码展示了字面量/直接量方式声明变量的值为这三种原始类型：

var variable1 = true //该数据值为boolean类型
var variable2 = 100 //该数据值为number类型
var variable3 = '这是一个测试内容.' //该数据值为string类型
```

```
在实际开发中，JavaScript 语言经常会将其他数据类型自动转换为 boolean 类型使用。所以，我们更需要关注其他数据类型自动转换为 boolean 类型时是怎么样的情况。具体如下表所示：
```

|   数据类型   |        转换为 true 值        | 转换为 false 值 |
| :----------: | :--------------------------: | :-------------: |
| boolean 类型 |             true             |      false      |
| string 类型  |        任何非空字符串        | ""（空字符串）  |
| number 类型  | 任何非零数字值（包括无穷大） |  0、0.0 和 NaN  |
| object 类型  |           任何对象           |      null       |
|  undefined   |                              |    undefined    |

```css
如下示例代码展示了使用 if 语句来判断其他数据类型是如何转换为 boolean 类型的：

var message = '这是一个测试内容.'
if (message) {
	console.log('该变量的值为true.')
}
```



### number类型

```css
number 类型简单来说就是数字值类型，在 JavaScript 语言使用字面量/直接量声明变量并初始化为数字值时，就是 number 类型。

number 类型按照 IEEE754 格式表示的话，会分为整数类型和浮点数类型。但 JavaScript 语言中只提供 number 类型来表示数字值，而通过具体数字值来区分整数类型和浮点数类型。

整数类型：负整数、0 和正整数
浮点数类型：简单来说就是指小数（负小数和正小数）

由于 IEEE754 格式表示的数字值是二进制表示法。换句话讲，JavaScript 语言浮点数类型时，很可能只是一个近似值而已。这会导致在使用浮点数类型的数字值进行计算时出现误差，如下示例代码所示：

var x = .3 - .2
var y = .2 - .1
x == y //值为false，表示两值不相等
x == .1 //值为false，.3-.2不等于.1
y = .1 //值为true，.2-.1等于.1
javascript
提示：由于 JavaScript 语言的这个问题，在实际开发中，建议按照单位进行换算之后再进行计算。例如将元换算为分做单位。
```



### NaN

```css
在 JavaScript 语言的数字值中，还存在着一个比较特殊的值，就是 NaN。NaN 是一个简写形式，全称为 Not a Number，译为不是一个数字值，该值通常用来表示经计算之后的结果不是一个数字值（*这样不用抛出错误异常）。

NaN 本身存在着 2 个特点：

任何涉及 NaN 的操作都会返回 NaN，例如 10/NaN
NaN 与任何值都不相等，包括 NaN 自身
针对 NaN 本身的这 2 个特点，JavaScript 语言提供了 isNaN() 函数，其作用是判断计算后的结果是否为 NaN。该函数接受一个参数，返回的结果是一个 boolean 类型。

如果结果为 true 的话，表示计算的结果为 NaN
如果结果为 false 的话，表示计算的结果不为 NaN，而是数字值
如下示例代码展示了 isNaN() 函数使用的一些情况：

console.log(isNaN(10)) //输出false（10是一个数值）
console.log(isNaN("10")) //输出false（可以被转换成数值 10）
console.log(isNaN("blue")) //输出true（不能转换成数值）
console.log(isNaN(true)) //输出false（可以被转换成数值 1）
```



### 字符串字面量

```css
string 类型包含了一些特殊的字符字面量，也称为转义序列，用来表示非打印字符。这些字符字面量如下表所示：
```

| 转义字符 |                   含义                    |
| :------: | :---------------------------------------: |
|    \n    |                  换行符                   |
|    \t    |                  制表符                   |
|    \b    |                  退格符                   |
|    \r    |                  回车符                   |
|    \f    |                  换页符                   |
|    \     |                   斜杠                    |
|    '     | 单引号（'），在用单引号表示的字符串中使用 |
|    "     | 双引号（"），在用双引号表示的字符串中使用 |



### 字符串的特点

```css
ECMA-262 标准规范中定义的字符串是不可变的。也就是说，字符串一旦被创建，其值是不能被改变的。如果想要改变字符串的内容，则需要先销毁原来的字符串，再创建新的字符串进行存储才行。

如下示例代码展示了使用变量存储字符串，并修改其值为另一个字符串：

var str = 'Hello'
var result = str + 'World'
javascript
如上述示例代码所示，str 变量初始化时的值为 Hello，在第二行将 str 变量的值和 World 字符串组合在一起。而这个过程实际上是这样的：

创建一个可以容纳 10 个字符的新字符串
将组合后的 HelloWorld 进行存储
将原来的 Hello 和 World 两个字符串进行销毁。
```



### typeof 运算符

```css
由于 JavaScript 是弱类型/松散类型的脚本语言，因此需要一种手段来判断变量的数据类型是什么。而 JavaScript 语言中的 typeof 运算符的作用就是用来判断某个变量的数据类型是哪种原始类型的。

typeof 运算符的语法结构如下所示：

typeof operand
typeof(operand)


javascript operand 参数：typeof 运算符判断的变量名或对象名
如下示例代码展示了 typeof 运算符的用法：

var message = '这是一个测试内容.'
console.log(typeof message) //输出string
console.log(typeof(message)) //输出string

javascript typeof 运算符会返回一个字符串，该字符串是某个原始类型的名称。如下所示：

"boolean"：说明当前变量的值是 boolean 类型
"number"：说明当前变量的值是 number 类型
"string"：说明当前变量的值是 string 类型
值得注意的是，虽然 typeof 运算符的用法是支持 typeof() 这种用法，但 typeof 并不是一个函数，而是运算符。
```



### 包装类型

```css
原始类型是没有提供属性和方法的，包装类型其实就是将原始类型包装成了对象，这样就提供了相应的属性和方法。而 JavaScript 语言中的例如 boolean 类型和 Boolean 类型是相似的，Boolean 类型实际上是一个 JavaScript 对象，提供了属性和方法。

所以，包装类型中的数据类型是与原始类型一一对应的，如下所示：

Boolean 类型
Number 类型
String 类型
包装类型的使用是通过构造器方式声明变量并进行初始化操作，如下示例代码所示：

var variable1 = new Boolean(true)
var variable2 = new Number(100)
var variable3 = new String('这是一个测试内容.')
```



### Boolean 类型

```css
Boolean 类型在 JavaScript 语言中本质是创建一个 Boolean 类型对象的构造器。其语法结构如下所示：

new Boolean(value)
javascript
value 参数：可选项，用来初始化 Boolean 对象的值。
如下示例代码展示了 Boolean 类型的用法：

var bool = new Boolean(true)
javascript
因为 Boolean 类型是包装 boolean 类型的，所以 value 参数的最基本用法是 true 和 false。但 value 参数并不是只允许使用 true 和 false，如果 value 参数是其他值的话，则先自动转换为 boolean 类型。如下示例代码所示：

var bool = new Boolean('这是一个测试内容')
最终的结果为 true,所以 boolean 类型由 Boolean 类型包装，得到的是 Boolean {true} 的形式。

注意：不要将 boolean 类型的 true 和 false 与 Boolean 类型的 true 和 false 混淆在一起。
用Boolean构成的对象是object，而boolean还是boolean
```



### Number 类型

```css
Number 类型在 JavaScript 语言中本质是创建一个 Number 类型对象的构造器。其语法结构如下所示：

new Number(value)

value 参数：用来初始化 Number 对象的值。
如下示例代码展示了 Number 类型的用法：

var num = new Number(100)


如果 value 参数并不是数字值的话，JavaScript 语言则会先自动将其转换为数字值，再返回结果。如下示例代码所示：

var num = new Number('123')
console.log(num)

如果 value 参数不是数字值，并且无法转换为数字值时，new Number() 会返回 NaN 的结果。如下示例代码所示：

var num = new Number('这是一个测试内容.')
console.log(num)

注意：number和Number构造的也是不一样的，number还是number，而Number是object
```



### String 类型

```css
String 类型在 JavaScript 语言中本质是创建一个 String 类型对象的构造器。其语法结构如下所示：

new String(value)

value 参数：用来初始化 String 对象的值。
如下示例代码展示了 String 类型的用法：

var str = new String('这是一个测试内容.')

如果 value 参数并不是字符串的话，JavaScript 语言则会先自动将其转换为字符串，再返回结果。如下示例代码所示：

var str = new String(100)
console.log(str)


如果 value 参数并不是字符串的话，JavaScript 语言则会先自动将其转换为字符串，再返回结果。如下示例代码所示：

var str = new String(100)
console.log(str)

注意：
string 类型通过 typeof 运算符之后得到的结果是 string 
String 类型通过 typeof 运算符之后得到的结果是 object。
```



### instanceof 运算符

```css
由于包装类型种的所有数据类型，在 JavaScript 语言中本质上就是一个对象。使用 typeof 运算符之后得到的结果是 object，所以使用 typeof 运算符是无法准确判断包装类型的。

我们可以使用 JavaScript 语言中的 instanceof 运算符来判断包装类型中的具体数据类型。其语法结构如下所示：

object instanceof constructor

object 参数：表示需要 instanceof 运算符判断类型的变量或对象。
constructor 参数：表示需要 instanceof 运算符判断的数据类型。

如下示例代码展示了 instanceof 运算符的用法：

var str = new String('这是一个测试内容.')
console.log(str instanceof String)

instanceof 运算符返回一个 boolean 类型的结果：

如果结果为 true，则表示当前变量的类型是指定的包装类型。
如果结果为 false，则表示当前变量的类型不是指定的包装类型。
```



### 特殊类型

```css
在 ECMA-262 标准规范中并没有定义特殊类型，只是我们为了便于学习自行划分出来的数据类型。之所以称为特殊类型，是因为这种类型所包含 Undefined 类型和 Null 类型，都是用法比较特殊的数据类型。

undefined 类型和 null 类型在 ECMA-262 标准中是属于原始类型。在实际开发中，undefined 类型和 null 类型的用法是很容易出现错误的。其中，应用场景更多一些的是 undefined 类型。

```

```css
undefined 类型
undefined 类型中只有一个值，即 undefined。

undefined 是 JavaScript 语言的原始数据类型。一般情况下，是不会主动地将某一个变量的值赋值为 undefined 的。但是，ECMA-262 标准也并没有规定不能将一个变量的值赋值为 undefined。如下示例代码所示：

var variable1
var variable2 = undefined
console.log(variable1, variable2)

在 JavaScript 语言中的应用场景中会得到 undefined 的情况如下所示：

声明变量但未初始化值时，该变量的值为 undefined
声明变量并初始化值为 undefined 时，该变量的值为 undefined
函数中的 return 语句的默认返回值为 undefined
函数中的 return 语句的返回值设置为 undefined
访问某一个对象中不存在的属性时，得到的结果为 undefined
```

```css
使用全等号（===）来判断当前变量的值是否为 undefined
使用 typeof 运算符来判断当前变量的值是否为 undefined
如下示例代码展示了使用上述 2 种方法来判断当前值是否为 undefined：

var x
console.log(x === undefined)
console.log(typeof x === 'undefined')

=== 是来判断俩种需要判断的属性的值和类型都是否一样
```



### null类型

```css
Null 类型中也只有一个值，即 null。null 是 JavaScript 语言的原始数据类型。但值得注意的是，如果使用 typeof 运算符来判断 null 的类型的话，结果却为 object。如下

这是因为 null 值表示的是一个空对象指针，所以 typeof null 的结果才为 object。如果想要准确得到 null 的类型是什么的话，需要使用如下示例代码的方式才行：

Object.prototype.toString.call(null)
```

```css
当声明一个变量但不进行初始化的话，可以将该变量的值赋值为 null。这样做的好处是该变量不会占用内存空间。
当一个变量不再使用时，需要将该变量的值赋值为 null。这样做表示将该变量从内存空间进行释放出来。
实际上，undefined 值是派生于 null 值的。因此如果运行 null == undefined 这样的计算的话，结果为 true。

当然如果用=== 结果为false
```



### 类型转换

```css
JavaScript 语言目前提供的类型转换有 2 种，如下所示：

隐式类型转换：通过特定的表达式达到指定类型转换的目的。
显式类型转换：通过使用 JavaScript 语言提供的函数达到指定类型转换的目的。
```



#### 1、隐式类型转换

```css
所谓隐式类型转换，就是指 JavaScript 语言并没有提供特定的内容，而是通过特定的表达式以达到从某个数据类型转换为另一个数据类型的方式。

```

```css
转换为 boolean 类型
其他数据类型想要转换为 boolean 类型的话，只需要在其前面增加 2 个逻辑非运算符（!）即可。如下示例代码所示：

console.log(!!'这是一个测试内容.')

而其他数据类型转换为 boolean 类型，需要了解转换规则是怎么样的，如下表所示：
```

|   数据类型   |        转换为 true 值        | 转换为 false 值 |
| :----------: | :--------------------------: | :-------------: |
| boolean 类型 |             true             |      false      |
| string 类型  |        任何非空字符串        | ""（空字符串）  |
| number 类型  | 任何非零数字值（包括无穷大） |  0、0.0 和 NaN  |
| object 类型  |           任何对象           |      null       |
|  undefined   |                              |    undefined    |

```css
转换为 number 类型

其他数据类型想要转换为 number 类型的话，只需要在其前面增加加法运算符（+）即可。如下示例代码所示：

console.log(+'10')
console.log(+true)

其中 boolean 类型转换为 number 类型的情况如下：
true 转换为 number 类型的值为 1
false 转换为 number 类型的值为 0


值得注意的是，当 string 类型转换为 number 类型时，是可能无法成功转换为数字值的。如下示例代码所示：

console.log(+'这是一个测试内容')

当 string 类型无法成功转换为数字值时，得到的结果为 NaN。但注意的是，NaN 依旧是 number 类型的值。


如下面这个：
console.log(100 + '200') //结果为100200
使用这种方式将 string 类型转换为 number 类型时，必须要先执行 + 某个字符串 的表达式，再执行其他计算。



但 boolean 类型在使用这种方式转换为 number 类型时，就不存在 string 类型的这种情况。如下示例代码所示：

console.log(100 + true) //结果为101
```

```css
转换为 string 类型

其他数据类型想要转换为 string 类型，只需要使用连接运算符（+）拼接一个空字符串（''）即可。如下示例代码所示：

var str1 = '' + true
console.log(typeof str1)
var str2 = '' + 100
console.log(typeof str2)

这个拼接的空字符串出现在前后都是可以的
```



#### 2、显式类型转换

```
显示是官方明确给出的，隐式属于经验得出

隐式类型转换和显式类型转换的区别:
  * 隐式类型转换
    * 并不是JavaScript官方规范中的内容
    * 执行的效率更高/性能更好
    * 不易于使用(语法不明确)
  * 显式类型转换
    * 是JavaScript官方规范中的内容
    * 执行的效率不高/性能不太好
    * 易于使用(语法明确)
```

```css
转换为 boolean 类型
JavaScript 语言提供了 Boolean() 函数用来将其他数据类型转换为 boolean 类型。需要注意的是，这里所使用的是 Boolean() 函数，而不是包装类型创建 Boolean 类型的 new Boolean() 构造器的用法。

如下示例代码展示了如何使用 Boolean() 函数将其他数据类型转换为 boolean 类型：

console.log(Boolean('这是一个测试内容.'))
console.log(Boolean(100))
```

```css
转换为 number 类型
首先，JavaScript 语言提供了 Number() 函数用来将其他数据类型转换为 number 类型。如果无法成功了转换为数字值的话，结果则为 NaN。

如下示例代码展示了如何使用 Number() 函数将其他数据类型转换为 number 类型：

console.log(Number('123'))
console.log(Number(true))
console.log(Number('这是一个测试内容.'))

除了 Number() 函数可以将其他数据类型转换为 number 类型之外，JavaScript 语言还提供了如下 2 个函数实现同样的功能：

parseInt() 函数：用来将某个 string 类型的值转换为 number 类型，结果为一个整数或 NaN。
parentFloat() 函数：用来将某个 string 类型的值转换为 number 类型，结果为一个浮点数或 NaN。
值得注意的是：

无论 string 类型的值的内容是整数还是浮点数，parseInt() 函数都会将其转换为一个整数。
string 类型的值的内容如果是一个整数的话，parseFloat() 函数会将其转换为一个整数；但如果是一个浮点数的话，parseFloat() 函数会将其转换为一个浮点数。

```

```css
如下示例代码展示了 parseInt() 函数的用法：

var str1 = '100';
var str2 = '100.11';

console.log(parseInt(str1));// 100
console.log(parseInt(str2));// 100

如下示例代码展示了 parseFloat() 函数的用法：

var str1 = '100';
var str2 = '100.11';

console.log(parseFloat(str1));// 100
console.log(parseFloat(str2));// 100.11
```

```css
转换为 string 类型
JavaScript 语言提供了 String() 函数用来将其他数据类型转换为 string 类型。如下示例代码展示了如何使用 String() 函数将其他数据类型转换为 string 类型：

console.log(typeof String(100))
console.log(typeof String(true))


除了 String() 函数之外，JavaScript 还提供了 Object 对象的 toString() 方法同样可以将其他数据类型转换为 string 类型。如下示例代码所示：

var num = 100
console.log(typeof num.toString())
var bool = true
console.log(typeof bool.toString())
```



### 运算符

```css
JavaScript 语言中大部分的运算符是由标点符号表示的，例如 +、= 等。而还要一些运算符是由关键字表示的，例如 delete、typeof 等。JavaScript 语言中的运算符是由 ECMA-262 标准规范中描述的，这些运算符适用于很多值，例如字符串、数字值、布尔值，以及对象等。

如下示例代码展示了 JavaScript 运算符的用法：
console.log(2 + 3)
console.log(2 + 3 * 5)


条件语句和条件运算符区别：

1. 条件语句和条件运算符可以相互改写
2. 条件运算符的执行优先级别高于条件语句的
3. 条件运算符的效率更高
```



#### 1、分类

```css
一元运算符：只能操作一个操作数的运算符，例如自增运算符、typeof 运算符等。
二元运算符：只能操作两个操作数的运算符，例如加法运算符、逻辑与运算符等。
三元运算符：可以操作三个操作数的运算符，例如条件运算符等
除了可以按照其操作数的数量进行划分之外，还可以根据不同作用进行划分为如下几种：

算术运算符
比较运算符
逻辑运算符
赋值运算符
字符串运算符
条件运算符
特殊运算符
```



#### 2、优先级

![](http://changetm.oss-cn-beijing.aliyuncs.com/Temp/15ae9594-a8ed-4ae5-aecc-76c67cd9230c.png)



#### 3、算术运算符

```css
JavaScript 语言的算术运算符是使用数字值作为操作数，进行运算之后返回一个数字值。标准的算术运算符是加减乘除（+-*/），除了标准的算术运算符之外，JavaScript 语言还提供了如下表所示的算术运算符：
```

| 运算符             | 描述                                       | 案例                            |
| :----------------- | :----------------------------------------- | :------------------------------ |
| 求余运算符（`%`）  | 二元运算符，返回两个操作数相除之后的余数   | `12 % 5` 返回 2                 |
| 自增运算符（`++`） | 一元运算符，将操作数的值加 1               | `var x=3; console.log(++x) //4` |
| 自减运算符（`--`） | 一元运算符，将操作数的值减 1               | `var x=3; console.log(--x) //2` |
| 一元负值符（`-`）  | 一元运算符，返回操作数的负值               | `var x=3; console.log(-x) //-3` |
| 一元正值符（`+`）  | 一元运算符，返回操作数的正值               | `var x=3; console.log(+x); //3` |
| 指数运算符（`**`） | 计算底数的指数次方结果，表示为 baseexpoent | `console.log(2 ** 3)` //8       |

```css
上述算术运算符中，除了加法运算符（+）之外其他算术运算符，如果操作数存在非数字值的话，会先将其转换为 number 类型进行计算。

如果除加法运算符中的操作数是非数字值，并且无法正确的转换为数字值的话，则计算之后的结果为 NaN。如下示例代码所示：

console.log( 1 - 'a' ) //输出NaN
```



#### 4、加法运算符

```css
加法运算符（+）的作用就是用来计算两个操作数的加法计算。前提是这个两个操作数都是数字值（number 类型），如下示例代码所示：

console.log(2 + 3) //5

但如果其中一个或两个操作数是字符串（string 类型）的话，+ 符号则表示为字符串运算符。如下示例代码所示：

console.log(2 + '3') //23
console.log('2' + '3') //23

如果操作数只有一个，并且该操作数是一个非数字值的话，+ 则是隐式类型转换中转换 number 类型的作用。如下示例代码所示：

console.log(typeof + '123')
console.log(typeof + true)
```



#### 5、求余运算符

```css
求余运算符（%）的作用就是用来两个操作数进行相除运算之后的余数，如下示例代码所示：

console.log(5 % 2) //1

而求余运算符（%）在运算时，需要注意的是，两个操作数中存在负值的操作数。如下示例代码所示：
console.log( 10 % 3 ) //输出1
console.log( -10 % 3 ) //输出-1
console.log( 10 % -3 ) //输出1
console.log( -10 % -3 ) //输出-1
```



#### 4、自增运算符与自减运算符

```css
自增运算符
自增运算符是 ++ 符号，要和加法运算符（+）进行区分。按照具体的用法，自增运算符还可以划分为如下 2 种：

前置自增运算符：自增运算符在操作数的前面。运算时，会先进行自增操作，再返回运算结果。
后置自增运算符：自增运算符在操作数的后面。运算时，会先返回运算结果，再进行自增操作。
如下示例代码展示了 2 种自增运算符的不同：

var x = 3
console.log( x++ ) //输出3
console.log( x ) //输出4

var y = 3
console.log( ++y ) //输出4
console.log( y ) //输出4

自减运算符也一样
```



#### 5、NAN 与无穷大

```css
数字值（number 类型）中存在着两个比较特殊的值，即 NaN 和 Infinity：

NaN：全称为 Not a Number，译为不是一个数字值。
Infinity：表示为无穷大，分为正无穷大和负无穷大。
```

```css
加法运算符
加法运算符中的两个操作数如果存在 NaN 和 Infinity 的话，规则如下所示：

两个操作数中的任意一个为 NaN 的话，则结果为 NaN。
两个操作数都是 Infinity 的话，则结果为 Infinity。
两个操作数都是 -Infinity 的话，则结果为 -Infinity。
两个操作数如果一个为 Infinity 另一个为 -Infinity 的话，则结果为 NaN。
减法运算符
减法运算符中的两个操作数如果存在 NaN 和 Infinity 的话，规则如下所示：

两个操作数中的任意一个为 NaN 的话，则结果为 NaN。
两个操作数都是 Infinity 的话，则结果为 NaN。
两个操作数都是 -Infinity 的话，则结果为 NaN。
两个操作数如果前一个是 Infinity 后一个是 -Infinity 的话，则结果为 Infinity。
两个操作数如果前一个是 -Infinity 后一个是 Infinity 的话，则结果为 -Infinity。
乘法运算符
乘法运算符中的两个操作数如果存在 NaN 和 Infinity 的话，规则如下所示：

两个操作数中的任意一个为 NaN 的话，则结果为 NaN。
两个操作数都是 Infinity 的话，则结果为 Infinity。
两个操作数都是 -Infinity 的话，则结果为 Infinity。
两个操作数一个为 Infinity 另一个为 -Infinity 的话，则结果为 -Infinity。
除法运算符
除法运算符中的两个操作数如果存在 NaN 和 Infinity 的话，规则如下所示：

两个操作数中的任意一个为 NaN 的话，则结果为 NaN。
两个操作数无论是 Infinity 还是 -Infinity，则结果都为 NaN。
除了上述规则之外，我们还要注意的是，如果被除数为 0 的话，则结果为 Infinity。如下示例代码所示：

console.log(1 / 0) //Infinity
console.log(Infinity / 0) //Infinity
console.log(NaN / 0) //NaN
```



#### 6、比较运算符概述

| 运算符                 | 描述                                                        | 案例                  |
| :--------------------- | :---------------------------------------------------------- | :-------------------- |
| 等于运算符（`==`）     | 当两个操作数的值相等时，返回 true，否则返回 false           | `3 == '3'` 返回 true  |
| 不等于运算符（`!=`）   | 当两个操作数的值不等时，返回 true，否则返回 false           | `3 != 1` 返回 true    |
| 全等运算符（`===`）    | 当两个操作数的类型和值都相同时，返回 true，否则返回 false   | `3 === 3` 返回 true   |
| 不全等运算符（`!==`）  | 当两个操作数的类型或值不相同时，返回 true，否则返回 false   | `3 !== '3'` 返回 true |
| 大于运算符（`>`）      | 当左边操作数大于右边操作数时，返回 true，否则返回 false     | `3 > 2` 返回 true     |
| 大于等于运算符（`>=`） | 当左边操作数大于等于右边操作数时，返回 true，否则返回 false | `3 >= 2` 返回 true    |
| 小于运算符（`<`）      | 当左边操作数小于右边操作数时，返回 true，否则返回 false     | `2 < 3` 返回 true     |
| 小于等于运算符（`<=`） | 当左边操作数小于等于右边操作数时，返回 true，否则返回 false | `2 <= 3` 返回 true    |

```css
值得注意的是：

字符串使用比较运算符进行运算时，是基于标准字典的 Unicode 值来进行比较的。
Infinity 值比任何值都大，-Infinity 值比任何值都小。
```



#### 7、等于与不等于运算符

```css
等于运算符（==）与不等于运算符（!=）比较的都是其操作数的值，而不比较类型。换句话讲，只要是值是相等的，比较的结果为 true。如下示例代码所示：

console.log(2 == '2

NaN 与任何值都不相等（包括自身），如下示例代码所示：

console.log(NaN == NaN) //false
console.log(NaN != NaN) //true
```

```css
undefined 和 null 值的比较，undefined 与 null 是相等的。如下示例代码所示：

console.log(undefined == undefined) //true
console.log(null == null) //true
console.log(undefined == null) //true
```



#### 8、全等与不全等运算符

```css
比较运算符中除了等于运算符与不等于运算符之外，还提供了全等与不全等运算符。其区别在于全等与不全等运算符不仅比较值是否相等，还比较类型是否相同。

例如上述等于与不等于运算符的第一个示例代码，如果改为全等运算符的话，则结果会有所不同：

console.log(2 === '2') //false

使用全等运算符进行比较运算时，JavaScript 语言是不会先进行类型转换的。
```



#### 9、isNaN() 函数

```css
由于 NaN 与任何一个值都不同相等，包括自身。所以，我们是无法使用比较运算符来进行 NaN 和其他值之间的比较运算的。

JavaScript 语言提供了 isNaN() 函数专门用来判断某个变量的值是否为 NaN。如下示例代码所示：

console.log(isNaN(Number('这是一个测试内容.'))) //true

表示当前变量的类型为 NaN（不是一个数字值）
```



### 逻辑运算符

```css
javaScript 语言的逻辑运算符是先将两个操作数的类型转换为 boolean 类型，经过指定逻辑运算符进行运算，再返回其运算的结果。如果两个操作数都是 boolean 类型的话，返回运算的结果则也是 boolean 类型的值；如果两个操作数不是 boolean 类型的话，返回运算的结果则是操作数具体的值。

JavaScript 语言提供了如下表所示的逻辑运算符：
```

| 运算符               | 描述                                                         | 案例                           |
| :------------------- | :----------------------------------------------------------- | :----------------------------- |
| 逻辑与运算符（`&&`） | 如果左边操作数转换为 boolean 类型的值为 false，则返回左边操作数，否则返回右边操作数 | `true && false` 的结果为 false |
| 逻辑或运算符（`||`） | 如果左边操作数转换为 boolean 类型的值为 true，则返回左边操作数，否则返回右边操作数 | `false || true` 的结果为 true  |
| 逻辑非运算符（`!`）  | 将操作数转换为 boolean 类型的值，如果为 true 的话则返回 false，否则返回 true | `!true` 的结果为 false         |

```css
转换为 boolean 类型为 false 的值有 null、undefined、0、NaN 和 空字符串（""）。
```

```css
逻辑与运算符

逻辑与运算符最简单的用法，是两个操作数都是 boolean 类型的值。如果两个操作数都为 true，则运算的结果为 true；两个操作数中任意一个为 false，则运算的结果都为 false。如下表所示：
```

| 左边操作数 | 右边操作数 | 运算结果 |
| :--------: | :--------: | :------: |
|    true    |    true    |   true   |
|    true    |   false    |  false   |
|   false    |    true    |  false   |
|   false    |   false    |  false   |

```css
逻辑或运算符
逻辑或运算符是使用两个 | 符号，用来运算两个操作数并返回一个 boolean 类型的结果。这两个操作数可以是 boolean 类型的，也可以是其他数据类型的。

与逻辑与运算符类似，逻辑或运算符最简单的用法，是两个操作数都是 boolean 类型的值。如果两个操作数都为 false，则运算的结果为 false；两个操作数中任意一个为 true，则运算的结果都为 true。如下表所示：
```

| 左边操作数 | 右边操作数 | 运算结果 |
| :--------: | :--------: | :------: |
|    true    |    true    |   true   |
|    true    |   false    |   true   |
|   false    |    true    |   true   |
|   false    |   false    |  false   |

```css
逻辑非运算符

逻辑非运算符是一元运算符，这和逻辑与运算符、逻辑非运算符都不相同，因为逻辑与运算符和逻辑非运算符是二元运算符。

逻辑非运算符使用的是 ! 符号，该符号放置在操作数之前，表示取反。如果操作数的数据类型转换为 boolean 类型后的值为 true 的话，则返回 false；如果操作数的数据类型转换为 boolean 类型后的值为 false 的话，则返回 true。

如下示例代码展示了逻辑非运算符的用法：

console.log(!true) //false
console.log(!100) //false
console.log(!'') //true
```

```css
逻辑短路原则
所谓逻辑短路原则，主要是为了简化逻辑与运算符和逻辑或运算符的运算规则的。其是通过确定运算符左边操作数为 true 或 false，来确定运算结果返回的是 true 还是 false。具体原则如下：

逻辑与运算符
如果左边操作数的值为 false，则运算结果返回左边操作数。
如果左边操作数的值为 true，则运算结果返回右边操作数。
逻辑或运算符
如果左边操作数的值为 false，则运算结果返回左边操作数。
如果左边操作数的值为 true，则运算结果返回右边操作数。
```



### 赋值运算符

|         运算符          | 简写形式 |    含义    |
| :---------------------: | :------: | :--------: |
|  加赋值运算符（`+=`）   |  x += y  | x = x + y  |
|  减赋值运算符（`-=`）   |  x -= y  |  x= x - y  |
|  乘赋值运算符（`*=`）   |  x *= y  | x = x * y  |
|  除赋值运算符（`/=`）   |  x /= y  | x = x / y  |
| 求余赋值运算符（`%=`）  |  x %= y  | x = x % y  |
| 求幂赋值运算符（`**=`） | x **= y  | x = x ** y |

```
复合赋值运算符是一种简写形式，含义上与正常写法是没有什么区别的。但在执行代码时，复合赋值运算符的执行效率其实是要优于普通的正常写法的。
```



### 条件运算符

```css
条件运算符是 JavaScript 语言中唯一的三元运算符。也就是说，条件运算符的操作数需要 3 个。实际上，条件运算符是先运算一个表达式的计算结果，然后根据这个运算结果来决定执行另外两个中的哪一个表达式。其语法结构如下所示：

condition ? exprIfTrue : exprIfFalse

condition 参数：条件表达式，条件运算符是根据该表达式的计算结果来判断返回哪个操作数的。
exprIfTrue 参数：当 condition 表达式计算的结果为 true 或者可转换为 true 的其他数据类型值，则执行该表达式的运算。
exprIfFalse 参数：当 condition 表达式计算的结果为 false 或者可转换为 false 的其他数据类型值，则执行该表达式的运算。

除了 false 值之外，还有 null、undefined、0、NaN 和 空字符串（""）可以转换为 false 值。如果 condition 表达式计算后的结果为上述几个值的话，则将执行 exprIfFalse 表达式的运算。

—————————————————————————————————————————————————————————————————————————————————————————
如下示例代码展示了条件运算符的用法：

var age = 20
var result = age > 18 ? '成年人' : '未成年人'
console.log(result)

由于 age 变量的值为 20，条件运算符的条件表达式 age > 18 计算的结果为 true，所以将 成年人 结果赋值给 result 变量。
```

```css
条件运算符链
与其他运算符最大的不同在于条件运算符不仅是唯一一个三元运算符，还有就是条件运算符是右结合的。换句话讲，就是条件运算符的第三个表达式可以是另一个条件运算符，如此类推，形成一种链状。这种形式称为条件运算符链，其语法结构如下：

condition1 ? value1
: condition2 ? value2
: condition3 ? value3
: value4

如上述语法结构所示，第一个条件运算符的第三个表达式是第二个条件运算符，而第二个条件运算符的第三个表达式是第三个条件运算符。
—————————————————————————————————————————————————————————————————————————————————————————
如下示例代码展示了条件运算符链的用法：

var score = 85
var result = score >= 90 ? '优秀'
						: score >= 80 ? '良好'
						: score >= 60 ? '合格' : '不合格'
console.log(result)

如上述示例代码所示，使用小括号将第二个条件运算符和第三个条件运算符进行包裹，可以让条件运算符链的代码结构清晰一些。这种结构也可以称为条件运算符的嵌套结构。
```



### 条件语句

```css
if else语句：

var a=6,b=3;
if (a>b){
    console.log("我是a，我最大")
}
else{
    console.log("我是b我我最大")
}
```

```css
if和else嵌套语句：

var x = y = 1
var z = 2
if (x == y)
	if (x == z)
		console.log('x 等于 z.')
	else
		console.log('x 等于 y')
else
	console.log('x 不等于 y')
```

```css
else if 语句：

var x = y = 1
var z = 2
if (x == y) {
	console.log('x等于y')
} else if (x == z) {
	console.log('x等于z.')
} else {
	console.log('x与y、z都不相等. ')
}
```



#### switch 语句

```css
var num = 2
switch( num ){
	case 1:
		console.log('查询余额')
		break
	case 2:
		console.log('在线充值')
		break
	case 3:
		console.log('投诉建议')
		break
	default:
		console.log('转人工服务')
}

//输出结果：在线充值


若在case中缺省了break，便会向下一个case执行，直到break，或者 switch 语句完全执行完毕才会结束。
```

```css
var num=8;

switch( num ){
  default:
		console.log('转人工服务')
	case 1:
		console.log('查询余额')
		break
	case 2:
		console.log('在线充值')
		break
	case 3:
		console.log('投诉建议')
		break
}

//输出结果为：转人工服务、查询余额
case没有匹配到8，便会走default，因为后没有break，则继续下一case。

一般default放在最后
```



### **循环语句**


#### while语句
```css
var num = 0
while (num < 10) {
	console.log('num是一个小于10的数字.')
	num++
}

值得注意的是，while 语句用来判断的表达式运算的最终结果必须是 false，否则将一直反复执行指定的语句块。这种情况一般称为死循环。
```
#### do while 语句
```css
var num = 0
do {
	console.log('num是一个小于10的数字.')
	num++
} while (num < 10)

do...while 语句会先执行指定的语句块，再执行指定表达式的运算，如果表达式的运算结果为 true 则执行指定的语句块，以此类推。直到表达式的运算结果为 false，则跳出 while 语句。
```
#### 俩者区别

```css
do...while 语句：先执行，再判断。
while 语句：先判断，再执行。
```



#### fo循环

```css
for (var num = 0; num < 10; num++) {
	console.log('num的值为：' + num)
}

值得注意的是，for 语句中 3 个表达式之间的分号（;）是不能省略的。
```



### 跳转语句



#### break语句

```css
break 语句是终止语句。该语句会立即跳出当前的循环语句，并且强制执行该循环语句之后的语句。

var num = 0
while (num < 10) {
	if (num === 5) {
		break
	}
	console.log('num的值为：' + num)
	num++
}
console.log("我是while")

/*输出结果:
num的值为：0
VM9552:6 num的值为：1
VM9552:6 num的值为：2
VM9552:6 num的值为：3
VM9552:6 num的值为：4
VM9552:9 我是while
*/




```

```css
break 语句不仅可以在 while 语句中使用，还可以使用在任何一个循环语句中。break 语句除了可以使用在任何一个循环语句中之外，还可以在 switch 语句中使用。如下示例代码所示：

var num = 2
switch( num ){
	case 1:
		console.log('查询余额')
		break
	case 2:
		console.log('在线充值')
		break
	case 3:
		console.log('投诉建议')
		break
	default:
		console.log('转人工服务')
}



注意：break只可以在循环语句（嵌套if语句）或switch语句中使用，不可以单独在if语句中使用。
```



#### continue语句

```css
continue 语句的作用是结束循环语句中的本次循环，并开始下一次的循环。目前，continue 语句主要应用于循环语句。

continue label
label：可选项。为某个语句关联的标识符。当 continue 语句没有在循环语句中使用时，该选项是必需的。

for (var num = 0; num < 10; num++) {
	if (num === 5) {
		continue
	}
	console.log('num的值为：' + num)
}

/*输出结果：
num的值为：0
num的值为：1
num的值为：2
num的值为：3
num的值为：4
num的值为：6
num的值为：7
num的值为：8
num的值为：9
*/

由上可以看出，当num===5的时候，跳出了本次循环，继续以后的循环

！！！注意：continue 语句是不能使用在if条件语句中的。和break一样
```

```css
区别：

continue 语句与 break 语句最大的区别在于，break 语句的执行将终止循环语句，而 continue 语句并不会终止循环语句，也就是说，continue 语句即使执行，也依旧在循环语句的循环过程中。
```



#### label 语句

```css
label 语句的作用是为某一条语句的前面增加一个可以引用的标识符，通常配合 break 语句和 continue 语句一起使用。

如下示例代码展示了在 for 语句的嵌套结构中 label 语句与 continue 语句的配合用法：

var i, j

loop:
for (i = 0; i < 3; i++) {
   for (j = 0; j < 3; j++) {
      if (i === 1 && j === 1) {
         continue loop //使外循环i=1时，内循环没有执行
      }
      console.log('i = ' + i + ', j = ' + j)
   }
}

/*

		 i = 0, j = 0
VM9963:9 i = 0, j = 1
VM9963:9 i = 0, j = 2
VM9963:9 i = 1, j = 0
VM9963:9 i = 2, j = 0
VM9963:9 i = 2, j = 1
VM9963:9 i = 2, j = 2
*/


这说明 continue loop 语句是直接跳转到了外层 for 循环语句，而不是结束内层 for 循环语句的本次循环。
```

```css
outter_block: {
	inner_block: {
		console.log('这是内部语句块.')
		break outter_block
		console.log('这是break语句之后的内容.')
	}
	console.log('这是外部语句块.')
}
console.log('这是语句块之后的内容.')

/*
输出结果：
这是内部语句块
这是语句块之后的内容
*/

值得注意的是，在实际开发中，label 语句使用的场景是比较少的。如果需要使用 label 语句时可以用函数的调用来替代。
```



### 数组

```css
数组（Array）是一个有序是数据集合，可以通过数组的名称（name）或者索引（index）访问数组中的数据内容。数组中的每一项可以存储任何类型的数据，也就是说，一个数组中可以存储不同类型的数据。

如下示例代码展示了 JavaScript 语言中的数组：

var arr = ['这是一个测试内容.', 100, true]

需要注意的是，JavaScript 中没有明确的数组这种数据类型，但是提供了 Array 对象。换句话讲，JavaScript 语言操作数组主要是通过 Array 对象提供的属性和方法来完成。

JavaScript 语言中的数组是允许动态调整的，也就是说，可以动态地向数组增加新的数据，也可以动态地从该数组中删除某个具体的数据。当然，还包括很多更为复杂的操作。

再有就是，数组中存储的每一个数据内容所在的位置都是唯一的。这样，我们就可以通过数据所在的位置很方便地访问到该数据内容。
```



#### 索引数组

```css
索引数组是存储数据内容的位置通过数字值来表示的一种数组，该数字值一般称为索引值。索引数组也是 ECMA-262 标准规范中所定义的数组。如下所示：

var arr = [] //声明一个空数组
arr[0] = '这是一个测试内容'
arr[1] = 100
arr[2] = true

通过上述示例代码所示，我们可以发现可以先声明一个空数组，再通过索引值的方式为数组中增加数据内容。并且，上述示例代码与如下示例代码是相同的：

var arr = ['这是一个测试内容.', 100, true]

值得注意的是，数组的索引值一般情况下是从 0 开始的，并不是从 1 开始的。
```



#### 关联数组

```css
关联数组是存储数据内容的位置通过字符串来表示的一种数组，该字符串可以是名称（name）或者键名（key）。需要注意的是，ECMA-262 标准规范中并没有定义这种数组，但是我们声明一个这样的数组 JavaScript 语言并不会报错。如下所示：

var arr = []
arr['str'] = '这是一个测试内容'
arr['num'] = 100
arr['bool'] = true

如上述示例代码所示，我们可以发现索引数组与关联数组的区别在于索引数组的索引值使用数字值，而关联数组的索引值使用字符串。
```



#### 稀疏数组

```css
稀疏数组是索引数组在实际开发中所遇到的比较特殊的一种数组。简单来说，稀疏数组就是指索引值不连续的数组。如下示例代码所示：

var arr = new Array(10) //创建一个可以容纳10个数据内容的数组
arr[3] = '这是一个测试内容.'
arr[5] = 100
arr[8] = true

如上述示例代码所示，先创建了一个可以容纳 10 个数据内容的数组，但只在索引值为 3、5、8 存储了数据，其余位置都没有存储数据，这种数组就可以称为稀疏数组。

稀疏数组在实际开发中，会经常遇到一些问题。所以，无论在学习中还是开发中，都需要特别地留意这种数组的操作方式以及可能遇到的问题。
```



#### 数组的长度

```css
JavaScript 语言提供了 Array 对象，该对象提供了一个 length 属性，该属性可以用来表示数组的长度。所谓的数组长度，简单来说，就是数组可以存储多少数据内容。
```

```css
索引数组
一般情况下，索引数组的长度是等于索引数组存储数据内容的个数的，如下示例代码所示：

var arr = []
arr[0] = '这是一个测试内容'
arr[1] = 100
arr[2] = true
console.log(arr.length)

// 3

```

```css
由于 ECMA-262 标准规范中并没有定义关联数组，所以导致关联数组的 length 属性是无效的。换句话讲，无论在关联数组中存储了多少数据内容，其 length 属性的值始终为 0。如下示例代码所示：

var arr = []
arr['str'] = '这是一个测试内容'
arr['num'] = 100
arr['bool'] = true
console.log(arr.length)

// 0

我们可以清晰地看到在关联数组中存储了 3 个数据内容，但 length 属性的值依旧为 0。
```

```css
稀疏数组
由于稀疏数组是索引值不连续的数组，会导致稀疏数组存储的数据个数与 length 属性值不等的结果。如下示例代码所示：

var arr = new Array(10)
arr[3] = '这是一个测试内容.'
arr[5] = 100
arr[8] = true
console.log(arr.length)

// 10

我们可以看到 arr 数组中存储了 3 个数据内容，但该数组的 length 属性值为 10。
```



#### 一维数组

```css
一维数组指的就是 ECMA-262 标准规范中所定义的数组。简单来说，一维数组就是在存储数据时，这些数据内容不再会是另一个数组，这种情况下的数组称为一维数组。如下示例代码所示：

var arr = ['这是一个测试内容.', 100, true]


如下示例代码展示的就不是一个一维数组：

var arr = ['这是一个测试内容.', 100, [1,2,3,4,5]]
```

```css
Array（） 函数方式创建数组
例：
var arr = Array('这是一个测试内容.', 100, true)
console.log(arr)
—————————————————————————————————————————————————————————————————————————————————————————
值得注意的是，Array() 函数这种方式创建数组，如果传递的参数只有一个并且是数字值时，则表示创建了一个该数字值长度的空数组。如下示例代码所示：
var arr = Array(10)
console.log(arr)

如果使用 Array() 函数方式创建一个空数组的话，只需要不传递任何参数即可。如下示例代码所示：
var arr = Array()
```

```css
构造函数方式创建数组

值得注意的是，构造函数方式与 Array() 函数方式在语法结构上仅相差一个 new，但意义上完全不一样。因为使用 new 关键字是表示在 JavaScript 语言中创建一个对象。所以，这种方式表示创建了一个数组对象。如下示例代码所示：
var arr = new Array('这是一个测试内容.', 100, true)
console.log(arr)




与 Array() 函数方式类似，如果构造函数中的参数只有一个并且是数字值的话，则表示创建了一个该数字值长度的空数组。如下示例代码所示：
var arr = new Array(10)
console.log(arr)



如果使用构造函数方式创建一个空数组的话，只需要不传递任何参数即可。如下示例代码所示：
var arr = new Array()
```



#### 数组操作

```css
访问数组中的数据
console.log(arr[0]) //索引访问
console.log(arr['str']) //关联数组访问，通过键访问对应的值
—————————————————————————————————————————————————————————————————————————————————————————
修改数组中的数据

—————————————————————————————————————————————————————————————————————————————————————————
删除数组中的数据
var arr = ['这是一个测试内容.', 100, true]
delete arr[0]
console.log(arr)
console.log('arr数组的长度为：' + arr.length)
值得注意的是，当通过 delete 运算符删除数组中指定索引值的位置上的数据内容时，该数组的长度不变，只是将指定位置上的数据内容删除而已。（空间还保留）
```



#### 遍历数组

```css
由于数组中可以存储多个数据内容，有时我们需要将数组中每一个数据内容全部读取出来，这就需要通过遍历数组来完成。遍历数组的操作可以通过任意一种循环语句来实现，如下示例代码所示：

var arr = ['这是一个测试内容.', 100, true]
for (var i=0; i<arr.length; i++) {
	console.log(arr[i])
}

通过循环索引，遍历数组
```



#### for...in 语句

```css
除了我们已经掌握了的 3 种循环语句之外，ECMA-262 5 版本中新增了 for...in 循环语句。for...in 语句是通过一个指定的变量来循环一个对象中所有可枚举的属性。其语法结构如下：

for (variable in object) {
  statements
}

variable：用来在每一次循环时，该变量会被赋值为 object 对象在这一次循环所得到的属性。
object：一个具有可枚举属性被遍历的对象。
statement：for...in 语句循环中的语句块。
如下示例代码展示了 for...in 语句遍历数组的用法：

var arr = ['这是一个测试内容.', 100, true]
for (i in arr) {
	console.log(arr[i])
}

// 
            这是一个测试内容.
VM10396:3   100
VM10396:3   true
//
```

```css
虽然 for...in 语句可以用来遍历数组，但 for...in 语句原本的作用是用来遍历一个对象中所有可枚举的属性，所以 for...in 语句实际上是将数组作为 Array 对象进行遍历的，这时不仅可以得到数组中所有的数据内容，还可以得到为该 Array 对象自定义的属性。如下示例代码所示：

var arr = ['这是一个测试内容.', 100, true]

arr.name = '这是为该数组新增的name属性' //将arr数组作为Array对象使用，为该对象新增name属性

for (i in arr) {
	console.log(arr[i])
}

//

	        这是一个测试内容.
VM10402:6   100
VM10402:6   true
VM10402:6   这是为该数组新增的name属性

//

我们可以看到 for...in 语句不仅遍历得到 arr 数组中所有的数据内容，同时也得到了我们为 arr 这个 Array 对象新增的自定义 name 属性的值。

提示：在 EMCA-262 2015 版本的标准规范中新增了 for...of 语句和 forEach 语句可以更好地来遍历数组。
```

```css
遍历关联数组

由于关联数组并不是 EMCA-262 标准规范中的内容，所以导致关联数组的 length 属性失效，始终都是 0。这就导致了我们无法通过 while、do...while 或者 for 等循环语句来遍历关联数组，而目前只能通过 for...in 语句来遍历关联数组。如下示例代码所示：

var arr = []
arr['str'] = '这是一个测试内容'
arr['num'] = 100
arr['bool'] = true

for (i in arr) {
	console.log(arr[i])
}
```

```css
遍历稀疏数组

由于稀疏数组的 length 属性值与所存储数据的个数是不一致的，所以不能简单地使用 while、do...while 或者 for 语句来遍历稀疏数组。如下示例代码所示：

var arr = new Array(10)
arr[3] = '这是一个测试内容.'
arr[5] = 100
arr[8] = true

for (var i=0; i<arr.length; i++) {
	console.log(arr[i])
}
```



#### 二维数组

```css
由于 JavaScript 语言中的数组存储的数据类型可以是任何数据类型，所以数组中存储另一个数组也是允许的。这种数组的嵌套结构成为多维数组。

一个数组中嵌套另一个数组这种两层嵌套结构称为二维数组，如下示例代码所示：

var arr = [ [11,12,13], [21,22,23], [31,32,33] ]
javascript
一般情况下，在 JavaScript 语言中二维数组已经是比较复杂的数据结构了，很少会用到三维数组或更为复杂的数组嵌套结构。
```

```css
规整的二维数组
所谓规整的二维数组，就是指作为外层数组嵌套的内层数组中的数据个数是一致的。如下示例代码所示：

var arr = [[11,12,13], [21,22,23], [31,32,33]]

—————————————————————————————————————————————————————————————————————————————————————————
不规整的二维数组
所谓不规整的二维数组，就是指作为外层数组嵌套的内层数组中的数据个数是不一致的。如下示例代码所示：

var arr = [[101], [201, 202], [301, 302, 303]]
```

```css
操作二维数组中的数据
与一维数组类似的是，二维数组中的数据操作也划分为访问数组中的数据、修改数据中的数据以及删除数组中的数据。并且基本的操作都是类似的，而不同的是由于二维数组是数组的嵌套结构，导致真正的数据实际上是存储在内层数组中的，所以要通过两层数组的索引值才能真正访问到数据内容。

如下示例代码展示了如何访问一个二维数组中的数据内容：

var arr = [[11,12,13], [21,22,23], [31,32,33]]
console.log(arr[0][0])
```

```css
遍历二维数组
由于二维数组实际上是数组中嵌套另一个数组，所以遍历二维数组需要循环语句的嵌套结构来实现。外层循环语句遍历外层数组，内层循环语句遍历内层数组。如下示例代码所示：

var arr = [[11,12,13], [21,22,23], [31,32,33]]

for( var i = 0; i < arr.length; i++ ){
	for( var j = 0; j < arr[i].length; j++ ){
		console.log( arr[i][j] );
	}
}
```



### 函数

```css
JavaScript 语言中的函数就是一段可以重复执行的代码块。简单来说，函数只需要定义一次，但可以调用一次或多次。如下示例代码所示：

//定义一个fun函数
function fun(){
	console.log('这是一个函数.')
}
//调用fun函数
fun()
```



#### 定义函数

```
与变量类似，函数同样需要先声明再使用的。定义函数，也称为声明函数，共具有如下 3 种方式：

函数声明方式
函数表达式方式
构造函数方式
```

```css
函数声明方式
使用函数声明方式来定义函数，实际上是通过 JavaScript 语言提供的相关语法来定义函数。其语法结构如下所示：

function name() {
	statement
}

name：表示为定义函数的函数名称。命名规则与声明变量的命名规则是一致的。
statement：表示定义函数时的内部将要执行的语句块，一般称为函数体。
根据上述语法结构，如下示例代码展示了如何通过函数声明方式来定义一个函数：

function fun(){
	console.log('这是一个用于测试的函数内容.')
}
```

```css
函数表达式方式
函数表达式方式是一种类似于声明变量的方式，区别在于赋值运算符的右边是一个函数结构而并不是一个值。其语法结构如下所示：

var name = function(){
	statement
}

name：表示为定义函数的函数名称。命名规则与声明变量的命名规则是一致的。
statement：表示定义函数时的内部将要执行的语句块，一般称为函数体。
根据上述语法结构，如下示例代码展示了如何通过函数表达式方式来定义一个函数：

var fun = function(){
	console.log('这是一个用于测试的函数内容.')
}

如上述示例代码所示，赋值运算符的右边内容就是称为函数表达式。我们可以发现在函数表达式中并没有指定函数名称，因为函数名称是由赋值运算符右边的变量名来代表的。


—————————————————————————————————————————————————————————————————————————————————————————
当然，这种函数表达式方式定义一个函数时，也允许为该函数定义函数名。这样赋值运算符右边的语法结构类似于函数声明方式定义函数的语法结构。如下示例代码所示：

var fun = function fn(){
	console.log('这是一个用于测试的函数内容.')
}

```



#### 形参和实参特例

```css
形参的个数多于实参的个数
当一个函数的形参的个数多于实参的个数时，那么多余的形参就相当于声明了一个变量但没有进行初始化值。如下示例代码所示：

function add(a, b){
	console.log(a, b)
}
add(1)

没有对应实参的形参 b 的值为 undefined。这与声明了一个变量但没有进行初始化值的情况是一致的。
```

```css
形参的个数少于实参的个数
当一个函数的形参的个数少于实参的个数时，那么将不会有任何形参来接收多余的实参的值。如下示例代码所示：

function add(a, b){
	console.log(a, b)
}
add(1, 2, 3)

//结果为： 1 2
3因为没有对应的形参而被丢弃
```



#### return 语句

```css
函数的函数体中还包含了一个 return 语句，该语句的作用是将函数体的计算结果作为返回值。该语句并不是必需的，默认情况下返回值为 undefined。

如下示例代码所示：
function fun(){
	console.log('这是一个用于测试的函数内容.')
}
var f = fun() //将调用fun函数的计算结果赋值给f变量
console.log(f)

—————————————————————————————————————————————————————————————————————————————————————————
如下示例代码展示了为函数的函数体定义 return 语句：
function fun(){
	console.log('这是一个用于测试的函数内容.')
	return '这是函数的返回值'
}
var f = fun() //将调用fun函数的计算结果赋值给f变量
console.log(f)
```



#### 内置函数

|     函数     |                           描述                            |
| :----------: | :-------------------------------------------------------: |
|    eval()    |         对一串字符串形式的JavaScript代码字符求值          |
|   uneval()   |           创建的一个Object的源代码的字符串表示            |
|  isFinite()  |               判断传入的值是否是有限的数值                |
|   isNaN()    |                 判断一个值是否不是数字值                  |
|  parseInt()  |             解析字符串参数，并返回指定的整数              |
| parseFloat() |             解析字符串参数，并返回一个浮点数              |
| decodeURI()  | 对已编码的统一资源标识符(URI)进行解码，并返回其非编码形式 |
| encodeURI()  |  对统一资源标识符(URI)进行编码，并返回编码后的URI字符串   |

```css
eval() 函数

eval() 函数的作用是将传入到该函数中的字符串当做 JavaScript 语言的代码进行执行。

console.log(eval('4 + 4'))
//结果为8

当 eval() 函数接收的参数不是一个字符串的话，eval() 函数会将该参数的类型原封不动的返回。
```

```css
encodeURI() 函数与 decodeURI() 函数


encodeURI() 函数与 decodeURI() 函数是一对逆操作函数。其中，encodeURI() 函数的作用是对一个特定字符串进行编码，而 decodeURI() 函数的作用是对一个特定字符串进行解码。

如下示例代码展示了 encodeURI() 函数和 decodeURI() 函数的用法：

var uri = 'http://www.example.com/前端开发工程师'

var encode = encodeURI(uri)
console.log(encode)

var decode = decodeURI(encode)
console.log(decode)


/*输出结果：
http://www.example.com/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88
http://www.example.com/前端开发工程师
undefined
*/
```

```css
encodeURIComponent() 函数与 decodeURIComponent() 函数

encodeURIComponent() 函数和 decodeURIComponent() 函数与 encodeURI() 函数和 decodeURI() 函数的区别在于 encodeURIComponent() 函数和 decodeURIComponent() 函数不仅对字符串中的中文进行编码和解码，同时也对字符串中的标点符号进行编码和解码。

如下示例代码展示了 encodeURIComponent() 函数和 decodeURIComponent() 函数的用法：

var uri = 'http://www.example.com/前端开发工程师'

var encode = encodeURIComponent(uri)
console.log(encode)

var decode = decodeURIComponent(encode)
console.log(decode)

/*	http%3A%2F%2Fwww.example.com%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%
http://www.example.com/前端开发工程师
undefined
*/
```



### 作用域

```css
JavaScript 语言中的**作用域（scope）**就是指变量、函数或者对象的可访问范围。也就是说，作用域控制着变量、函数或者对象的可见性和生命周期。
```



#### 可访问范围

```css

所谓的可访问范围，就是指某个变量、函数或者对象在一个特定的执行环境中可以被访问，但一旦超出这个执行环境就无法被访问。例如每一个函数都有自己的执行环境，也就是说，在一个函数中如果声明一个变量的话，就只能在该函数才能访问。如下示例代码所示：

function fun(){
	var v = '这是声明在函数中的变量'
	console.log('在函数中访问v变量：' + v)
}
fun()
/*这个可以访问v变量*/


console.log('在函数外访问v变量：' + v)
/*这个因为是外部，不可直接访问，会报错*/
```



#### 生命周期

```
所谓的生命周期，就是指指某个变量、函数或者对象从被创建到被销毁的过程。如果以变量为例的话，一般情况下，声明变量就是变量的生命周期的开始，而当前执行环境中所有代码全部执行完毕之后，也就是变量被销毁的时候。
```



#### 词法作用域

```
JavaScript 语言的作用域采用的是词法作用域。所谓词法作用域，也称为静态作用域，就是指在编写 JavaScript 代码时已经决定了变量、函数或者对象的作用域，而不是在执行 JavaScript 代码时才决定变量、函数或者对象的作用域。如下示例代码所示：
```

```javascript
var v = 100

function fun(){
	var v = 200
	return v
}

var result = fun()
console.log(result) //200
```

```
上述示例代码中，我们可以看到在 fun 函数外部和内部分别声明并初始化值了一个 v 变量。由于 JavaScript 语言的作用域是词法作用域，所以在编写这段 JavaScript 代码时，就已经决定了 fun 函数的函数体内部存在一个执行环境，从而 `return v` 语句访问的是 fun 函数的函数体内部的 v 变量。

所以，上述示例代码运行的最终结果是打印 200，而不是 100。

可以理解成全局作用域和局部作用域
```



#### 作用域的分类

```css
全局作用域：指的是所有函数外部的执行环境。在全局作用域定义的变量、函数或者对象在任意位置都可以访问。
函数作用域：指的是某一个函数内部的执行环境。在函数作用域定义的变量、函数或者对象只能在当前函数作用域访问。

因为 ECMA-262 第 2015 版本之后新增了块级作用域，导致作用域出现了变化，如下所示：

全局作用域(全局变量是允许在 JavaScript 代码的任意位置都可以访问到的。)
局部作用域：函数作用域和块级作用域
(局部只能在当前函数作用域中访问，在当前函数作用域外（无论是全局作用域还是其他函数作用域）都是无法访问的。)
```



#### 变量作用域

```css
在 JavaScript 语言中还存在一种比较特殊的情况，就是在非严格模式下，在某一个函数的函数体中声明一个变量，但是省略了 var 关键字的话，该变量会自动提升为全局变量。如下示例代码：

function fun(){
	//声明变量时没有使用var关键字
	msg = 'this is message'
	//在当前函数作用域访问msg变量
	console.log(msg) //输出 this is message
}
fun();  //输出 this is message

// 在全局作用域访问msg变量
console.log(msg) //输出 this is message
```

```css
需要注意的是 ECMA-262 第 5 版本以及之前的版本中没有块级作用域，所以在语句块中声明的变量依旧是全局变量，并不是局部变量。如下示例代码所示：

if (true) {
	var v = 100
}
console.log(v) //100
```



#### 变量提升

```css
对于 JavaScript 语言比较常规的理解应该逐行解析并执行的，也就是说，变量是需要先声明再使用的。但实际上，JavaScript 语言并不是这样的，它是允许先使用再声明的。这种情况称为变量提升，如下示例代码所示：

console.log(v)
var v = 100

这样的结果为undefined
—————————————————————————————————————————————————————————————————————————————————————————
这是因为 JavaScript 语言在运行代码时，实际上是存在 2 个阶段：编译代码、执行代码
而在编译代码阶段，JavaScript 语言会将代码中所有需要声明的变量进行声明操作。
然后，在执行代码阶段再按照代码的先后顺序进行执行。
—————————————————————————————————————————————————————————————————————————————————————————
JavaScript 语言中这种变量提升的情况，不仅出现在全局变量，局部变量同样会有这样情况存在。
```



#### 按值传递

```css
所谓按值传递，就是利用 JavaScript 语言中的作用域实现的一种比较特殊的应用场景。具体来说，就是将全局变量作为实参传递给函数的形参。但如果改变函数作用域中的形参值的话，不会影响到全局变量的值。这种情况称为按值传递，如下示例代码所示：

var v = 100

function fun(v){
	v -= 10
	console.log(v) //打印fun函数的参数v的值
}
fun(v)

console.log(v) //打印全局变量v的值


//
90
100
//
```



#### 函数作用域

```css
function fun(){
	console.log('这是fun函数.')

	function fn(){
		console.log('这是fn函数.')
	}
	fn();
}
fun()
/*这个结果为：
  这是fun函数
  这是fun函数
*/

fn()
/*
这是是报错的，因为fn函数是局部函数，所以在外面不能访问
*/

—————————————————————————————————————————————————————————————————————————————————————————
其他的都和变量相同、也有函数提升，内部函数只能在当前函数作用域中访问，而全局函数可以在任何位置都可以访问


！！！注意：函数提升是优先于变量提升的。
```

```css
值得注意的是，如果使用函数声明方式声明了一个函数与变量同名时，函数会被优先提升。如下示例代码所示：

console.log(fun)

var fun = 100
function fun(){
	console.log('这是fun函数.')
}

// 结果为：

这是fun函数

//
```



### 对象

```css
对象是 ECMA-262 第 5 版本以及之前版本的标准规范中唯一一个复杂数据类型，即 Object。简单来说，一个对象就是一系列属性或方法的集合。Object 是 JavaScript 语言中所有引用类型的父级。无论是使用 Object() 还是 new Object() 是等价的。简单来说，我们可以通过 Object() 函数或者 Object() 构造函数来创建对象。

—————————————————————————————————————————————————————————————————————————————————————————
由于 Object 是 JavaScript 语言中的一个构造函数，所以 Object 本身提供了一系列方法。这一系列方法可以划分为 2 种，如下所示：
1、自有方法：例如 keys() 方法是用来得到当前对象中所有自有可枚举的属性名称。
2、原型方法：例如 hasOwnProperty() 方法是用来判断当前对象是否包含指定某个属性。

—————————————————————————————————————————————————————————————————————————————————————————
JavaScript 语言中的对象根据作用以及应用场景不同，可以划分为如下 3 种分类：
1、内建对象：又称为原生对象，是 JavaScript 语言预定义的对象。ECMA-262 标准规范定义的，由 JavaScript 解释器/引擎具体实现并提供的。
2、宿主对象：是由 JavaScript 语言的运行环境所提供的。例如浏览器环境提供了 DOM 和 BOM 等一系列对象。
3、自定义对象：是由开发者根据需求自行创建的对象。
```



#### 创建对象

```css
我们在开发工作中，除了可以使用 JavaScript 语言的内建对象和宿主对象之外，还可以根据需求来自行创建对象。JavaScript 语言提供了 3 种方式来创建对象，如下所示：

对象初始化器创建对象
构造函数方式创建对象
Object.create() 方法创建对象
```

```css
1、对象初始化器创建对象

使用对象初始化器方式创建对象，也称为字面量方式或者直接量方式创建对象。

如下示例代码展示了使用对象初始化器方式来创建一个对象：

var people={
    name:"小x",
    age:20,
    angle:function(){
        console.log("喜欢莫名的生气...")
    }
}

console.log(people) //打印输出对象
```

```css
2、构造函数方式创建对象


使用构造函数方式创建对象这种方式，其中的构造函数在 JavaScript 语言中存在 2 种情况，如下所示：

预定义构造函数：就是所有的引用类型，例如 Number、String 和 Boolean 等，当然还包含了 Object。
自定义构造函数：根据实际需求，使用构造函数的语法结构来创建自定义构造函数。

—————————————————————————————————————————————————————————————————————————————————————————
如果使用 JavaScript 语言的预定义构造函数来创建对象的话，那么可以直接创建相应类型的对象。如下示例代码所示：

var num = new Number(100)
console.log(num)
console.log(num instanceof Number) //结果为true

—————————————————————————————————————————————————————————————————————————————————————————

如果使用自定义构造函数来创建对象的话，实际上是需要两步来创建对象，如下所示：

自定义构造函数：根据 JavaScript 语言的构造函数语法结构来创建。一般情况下，构造函数的名称是首字母大写的。
通过自定义构造函数创建对象：通过 new 关键字创建对象。
创建一个自定义构造函数的语法结构是通过 function 关键字声明的


如下示例代码展示了如何通过自定义构造函数来创建对象：

function People(name,age){
    this.name=name
    this.age=age
}

var people=new People("小x",20)
console.log(people)

—————————————————————————————————————————————————————————————————————————————————————————
function People(name,age){
    this.namer="aaa"
    this.ager=age
}

var people=new People("小x")
console.log(people)

/*VM3069:7 People {namer: "aaa", ager: undefined}*/

上述代码，namer只是一个存储对象的空间名字可以随意写，而“aaa”是定义好的默认值
从输出结果可得知，ager是undefined，因为是对象初始化时只有一个对象值"小x"，便对应的对象name，而age没人和其对应的对象值，便为undefined。

—————————————————————————————————————————————————————————————————————————————————————————
function People(name,age){
    this.namer="aaa"
    this.ager=age   
}

var people=new People("小x",3,4)
console.log(people)
/*VM3129:10 People {namer: "aaa", ager: 3}*/

这段代码，当初始化对象值时，传入的对象值比原有的对象值多出一个，那么4便被丢弃。
```

```css
3、Object.create() 方法创建对象（和第一个方法一样，只不过是多了一步这个）

Object 提供的 create() 方法同样可以用来创建对象，并且使用这种方式创建对象允许为该对象选择其原型对象，而不是定义构造函数。

例：
//定义一个作为原型的对象
var people={
    name:"小x",
    age:20
}
//使用Object.create()创建对象，并将people作为原型对象
var person=Object.create(people)
console.log(person)
/*
VM3361:6 {}__proto__: name: "小x"age: 20__proto__: Objectconstructor: ƒ Object()__defineGetter__: ƒ __defineGetter__()__defineSetter__: ƒ __defineSetter__()hasOwnProperty: ƒ hasOwnProperty()__lookupGetter__: ƒ __lookupGetter__()__lookupSetter__: ƒ __lookupSetter__()isPrototypeOf: ƒ isPrototypeOf()propertyIsEnumerable: ƒ propertyIsEnumerable()toString: ƒ toString()valueOf: ƒ valueOf()toLocaleString: ƒ toLocaleString()get __proto__: ƒ __proto__()set __proto__: ƒ __proto__()
*/


可以看出第三种方法创建对象，其实就是比 1、对象初始化器创建对象，这个方法多了一步Object.creat()。
```



#### 创建空对象

```css
在创建对象时，JavaScript 语言是允许创建一个没有任何属性和方法的空对象的。上述 3 种方式都可以用来创建空对象，如下所示：

对象初始化器方式：var obj = {}
构造函数方式：var obj = new Object()
Object.create() 方法方式：var obj = Object.create(Object.prototype)
上述 3 种方式创建的空对象是等价的。
```



#### 对象之间的比较

```css
在 JavaScript 语言中，由于 Object 是一种引用类型，导致两个独立创建的对象永远也不会相等的，即使这两个对象具有相同的属性和方法。如下示例代码所示：

var obj1 = {
	name: 'apple'
}
var obj2 = {
	name: 'apple'
}

console.log(obj1 == obj2)
console.log(obj1 === obj2)

/*
false
false
*/

我们可以看到两个结果都为 false。因为等于运算符比较的是值是否相等，而全等运算符比较的是值和类型是否相等。两个对象之间的比较是引用的比较，如果引用（内存地址）不同则不会相等。
```



#### 对象中增属性

```css
通过点符号（.）访问某个对象的属性
通过方括号（[]）访问某个对象的属性
例如我们现在创建一个空对象，并且为该对象新增一些属性。如下示例代码所示：

var car = {}
car.name = 'ford' //通过点符号为该对象新增属性
car['year'] = 1984 //通过方括号为该对象新增属性

console.log(car)

/*
{name;"ford",year:1984}
*/

需要注意的是，访问对象的属性之所以可以使用方括号的形式的原因在于，JavaScript 语言中的对象也可以称为关联数组。也就是说，一个对象的属性名称可以是一个任何有效的字符串。
```



#### 访问对象的属性

```css
创建一个对象时会拥有一个或多个属性，可以通过对象的某个属性名称来访问该属性中所存储的数据内容。具体的方式有 2 种，如下所示：

通过点符号（.）访问某个对象的属性
通过方括号（[]）访问某个对象的属性
如下示例代码展示了上述 2 种方式来访问对象的属性：

var user = {
	name: '李雷',
	age: 18
}
console.log(user.name)
console.log(user['age'])

！！！注意：通过点符号访问对象的属性是一种比较常见的方式，但是通过方括号访问对象的属性是一种更为通用的方式。例如某个对象中存在比较复杂的属性名称时，通过点符号访问可能会出现问题，但通过方括号访问就不会。
```



#### 检测对象属性

```css
JavaScript 语言提供了 4 种方式来判断某个对象中是否存在指定属性，如下所示：

1、将属性值通过全等运算符与 undefined 进行比较（===）：
	
如果使用这种方式来判断一个属性是否存在的话，可能得到的结果并不准确。
如下示例代码所示：

function User(name) {
	this.name = name
}
var user = new User()
console.log(user.name)
访问 user 对象的 name 属性得到的结果为 undefined，但这是因为我们在创建 user 对象时没有传递 name 参数的值导致的，并不是因为 name 属性不存在。

-----------------------------------------------------------------------------------------
2、通过 if 语句来判断对象的属性是否存在

如下示例代码所示：

var obj = {}
if (!obj.msg) {
	console.log('obj对象不存在msg属性.')
}
我们已经知道在转换为 Boolean 类型时，可以为 false 的值有 undefined、0、NaN 以及空字符串等。所以单凭转换为 false 来判断一个属性是否存在也是存在问题的。

-----------------------------------------------------------------------------------------
3、使用 in 运算符来判断对象的属性是否存在

in 运算符的作用是用来判断指定属性是否为某个对象的自有或者原型上的属性，如果是则为 true，否则为 false。如下示例代码所示：

var obj = {}
console.log('msg' in obj)

-----------------------------------------------------------------------------------------
4、使用 Object.hasOwnProperty() 方法来判断对象的属性是否存在

object 提供了 hasOwnProperty() 方法用来判断指定属性是否为某个对象的自有属性，如果是则为 true，否则为 false。如下示例代码所示：

var obj = {}
console.log(obj.hasOwnProperty('msg'))
```



#### 删除对象的属性

```css
通过 delete 运算符我们可以实现删除某个对象的自有属性。如下示例代码所示：

var user = {
	name: '李雷',
	age: 18
}
delete user.age
console.log(user)
```



#### 遍历对象的属性

```css
由于一个对象的属性可以是一个或者多个，并且还可以划分为自有属性和原型属性。有时我们是需要得到某一个对象的所有属性的，所以需要通过遍历的方式来实现。如下所示：

for...in 循环语句：该方法依次访问一个对象及其原型链中所有可枚举的属性

如下示例代码所示：

var person = {
	name: '李雷',
	age: 28,
	job: '售货员',
	sex: '男'
}
for (attr in person) {
  console.log(attr + ': ' + person[attr])
}
/*
name: 李雷
VM4017:8 age: 28
VM4017:8 job: 售货员
VM4017:8 sex: 男
*/

上面这个代码中的：person[attr]这是调person对象，然后那个attr作为参数key当作属性，方便每次得到对象中的属性值

-----------------------------------------------------------------------------------------
Object.keys(object) 方法：该方法返回一个数组，该数组包含了对象所有的自有可枚举属性的名称。

如下示例代码展示了 Object.keys() 方法的用法：

var person = {
	name: '李雷',
	age: 28,
	job: '售货员',
	sex: '男'
}
var attrNames = Object.keys(person)
for (var i=0; i<attrNames.length; i++) {
	var attrName = attrNames[i]
	console.log(attrName + ': ' + person[attrName])
}

/*
name: 李雷
VM4093:10 age: 28
VM4093:10 job: 售货员
VM4093:10 sex: 男
*/
与 for...in 语句遍历之后的结果是一致的。


-----------------------------------------------------------------------------------------
Object.getOwnPropertyNames(object) 方法：该方法返回一个数组，该数组包含了对象所有的属性名称。

Object.getOwnPropertyNames() 方法是 JavaScript 语言中的 Object 提供的一个方法，该方法返回一个数组，该数组包含了该对象中所有属性名称。

如下示例代码展示了 Object.getOwnPropertyNames() 方法的用法：

var person = {
	name: '李雷',
	age: 28,
	job: '售货员',
	sex: '男'
}
var attrNames = Object.getOwnPropertyNames(person)
for (var i=0; i<attrNames.length; i++) {
	var attrName = attrNames[i]
	console.log(attrName + ': ' + person[attrName])
}
/*
name: 李雷
VM4093:10 age: 28
VM4093:10 job: 售货员
VM4093:10 sex: 男
*/
```

```css
3 种方式的区别
遍历对象的属性的 3 种方式，经过上述示例代码测试之后，我们看到的结果是没有任何区别的。但实际上如下所示：

for..in 语句：可以得到某个对象的自有及原型上的可枚举的属性。
Object.keys() 方法：可以得到某个对象的自有可枚举的属性。
Object.getOwnPropertyNames() 方法：可以得到某个对象的所有的自有属性。
为了更清晰地展示这 3 种遍历方式的区别，我们首先创建一个具有原型属性和不可枚举属性的对象，如下示例代码所示：

//创建一个对象，具有name和age属性
var person = {
	name: '李雷',
	age: 28
}
//以person为原型对象来创建一个新对象
var user = Object.create(person, {
  // 为user定义一个可枚举的属性
	sex: {
    value: '男',
		writable: true,
    configurable: true,
    enumerable: true
	},
	// 为user定义一个不可枚举的属性
	job: {
    value: '售货员',
		writable: true,
    configurable: true,
    enumerable: false
	}
})
------------------------------------------
for (attr in user) {
  console.log(attr + ': ' + user[attr])
}
//for...in 语句得到了 user 对象的自有可枚举属性 sex，以及原型可枚举属性 name 和 age，但是没有得到自有不可枚举属性 job。

-------------------------------------------
var attrNames = Object.keys(user)
for (var i=0; i<attrNames.length; i++) {
	var attrName = attrNames[i]
	console.log(attrName + ': ' + user[attrName])
}
//Object.keys() 方法只能得到 user 对象的自有可枚举属性 sex，而原型可枚举属性 name 和 age 以及自有不可枚举属性 job 都得不到

------------------------------------------------
var attrNames = Object.getOwnPropertyNames(user)
for (var i=0; i<attrNames.length; i++) {
	var attrName = attrNames[i]
	console.log(attrName + ': ' + user[attrName])
}
//ObjectgetOwnPropertyNames() 方法得到了 user 对象的自有可枚举属性 sex 和不可枚举属性 job，但没有得到原型对象上的属性 name 和 age。
```



#### 对象的方法

```css
在 JavaScript 语言中，一个对象可以拥有很多个方法，一个方法描述了对象的一个行为。简单来说，一个对象的方法就是附加在该对象上的函数。也就是说，方法和函数的区别仅在于方法是属于某个对象的。

实际上，一个已存在的函数也可以通过新增方法的方式，来绑定在某一个对象上。如下示例代码所示：

function fun(){
	console.log('这是一个函数.')
}
var obj = {}
obj.fn = fun
obj.fn()
我们可以看到通过 obj.fn = fun 赋值语句，将 fun 函数绑定到 obj 对象上，并命名为 fn 方法

-----------------------------------------------------------------------------------------
function fun(){
    console.log("我在大笑")
}
var people={
    name:"小x",
    age:20
}

people.funn=fun()

//VM4545:3 我在大笑
```

```
对象新增方法、对象方法的访问、删除对象的方法、对象的方法的遍历与原来写的操作属性是一样的
```



### 引用类型

```css
JavaScript 语言中的引用类型是一种数据结构，用来将数据和功能集中在一起，这种一般情况称为类。但是，在 ECMA-262 第 5 版本以及之前版本中是不存在类和接口等概念的。因为 JavaScript 语言并不是一种基于类的面向对象语言，而是基于原型的面向对象语言。

-----------------------------------------------------------------------------------------
例如之前我们已经掌握的数组内容，创建的每一个数组都是 Array 类型的对象。数组可以用来存储数据，Array 类型同时提供了一系列属性和方法来完成某些功能，所以说引用类型将数据和功能集中在一起。

引用类型和类比较相似的一点是它们都可以用来创建一个该类型的对象，如下示例代码所示：
var obj = new Object()

上述示例代码创建了一个 Object 类型的 obj 对象。obj 对象就可以说是 Object 类型的一个实例，Object 也可以称为构造函数。
```



#### 引用类型分类

```css
JavaScript 语言预定义了很多引用类型，这些引用提供了一系列的属性和方法，我们使用这些引用类型可以完成很多功能。如下表所示展示了 JavaScript 语言中的引用类型：
```

| 引用类型      | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| Date 类型     | 获取和设置当前日期时间                                       |
| Math 类型     | 用于数学计算                                                 |
| Global 类型   | 全局对象，提供全局属性和全局方法                             |
| Array 类型    | 用于有序的存储多个值                                         |
| RegExp 类型   | 用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具 |
| Error 类型    | 用于匹配代码错误并提供对应提示内容                           |
| Function 类型 | 用于定义 JavaScript 中的函数                                 |
| Object 类型   | 用于定义 JavaScript 中的对象                                 |

```css
当然，除了上述表中的引用类型之外，我们已经掌握了的引用类型还有 Boolean 类型、Number 类型和 String 类型。
```



### Global 类型

```css
Global 类型

Global 对象译为全局对象，是 JavaScript 语言中最为特殊的一个对象。之所以这么说，是因为我们不能像其他引用类型一样直接使用 Global 对象的。

如下示例代码展示了直接打印 Global 类型的情况：
console.log(Global)
/*结果报错*/

之所以不能直接访问 Global 对象的原因在于，在不同的宿主环境中 Global 对象的具体表现是不同。我们以如下 2 种宿主环境为例来讲解：
Node.js 运行环境：Node.js API 提供了一个全局对象为 global 对象。
浏览器运行环境：BOM 提供了一个全局对象为 window 对象。

-----------------------------------------------------------------------------------------
如下示例代码展示了直接打印 Array 类型的情况：
console.log(Array)
结果为 Array(){ [native code] }，其中 native code 表示 JavaScript 语言的原生代码，默认情况下是不允许查看的
```



#### Global 类型的属性

```css
一些我们之前已经掌握了的特殊值，实际上是 Global 对象的属性。
这些全局属性，在 JavaScript 语言中的任何位置都可以直接使用。
如下表所示：
```

| 属性名称  | 描述             |
| :-------- | :--------------- |
| Infinity  | 正的无穷大的数值 |
| NaN       | 某个值不是数字值 |
| undefined | 未定义的值       |



#### Global 类型的方法

```css
我们之前已经掌握了的预定义函数，实际上同样是 Global 对象的方法，
在 JavaScript 语言中的任何位置都可以直接使用。
如下表所示：
```

| 函数         | 描述                                                      |
| :----------- | :-------------------------------------------------------- |
| eval()       | 对一串字符串形式的JavaScript代码字符求值                  |
| uneval()     | 创建的一个Object的源代码的字符串表示                      |
| isFinite()   | 判断传入的值是否是有限的数值                              |
| isNaN()      | 判断一个值是否不是数字值                                  |
| parseInt()   | 解析字符串参数，并返回指定的整数                          |
| parseFloat() | 解析字符串参数，并返回一个浮点数                          |
| decodeURI()  | 对已编码的统一资源标识符(URI)进行解码，并返回其非编码形式 |
| encodeURI()  | 对统一资源标识符(URI)进行编码，并返回编码后的URI字符串    |



### Date 类型

```css
console.log(Date())

/*Wed Apr 08 2020 15:22:53 GMT+0800 (中国标准时间)*/
```



#### 创建 Date 对象

 ```css
  JavaScript 语言中的 Date 类型提供了一系列的属性和方法允许我们可以在开发中获取、设置以及格式化日期，但这一切都需要创建一个 Date 类型的对象来实现。
  
  创建一个 Date 类型的对象，可以有如下 3 种方式：
  
  - 初始化为当前系统时间
  - 初始化为指定的年月日
  - 初始化为距离 1970 年1月1日指定毫秒数的时间
 ```

```css
1、初始化为当前系统时间

JavaScript 语言中的 Date 类型不仅是一个构造函数，还是一个函数。所以，既可以通过 Date 创建一个对象，也可以直接调用 Date() 函数。

如下示例代码展示了如何通过 Date 类型初始化时间为当前系统时间：

var date1 = new Date()
var date2 = new Date
var date3 = Date()
console.log('new Date()初始化时间为: ' + date1)
console.log('new Date初始化时间为: ' + date2)
console.log('Date()初始化时间为: ' + date3)
/*以上者三种输出结果都是一样的*/

-----------------------------------------------------------------------------------------
除此之外，还有 Date 类型提供了 now() 方法可以得到一个从 1970 年1月1日 00:00:00 至当前系统时间的毫秒数值。如下示例代码所示：
console.log(Date.now())

-----------------------------------------------------------------------------------------
2、初始化为指定的年月日

例如：
var date1 = new Date(2008, 7, 8)
var date2 = new Date(2008, 7, 8, 20, 18, 18)
console.log(date1)
console.log(date2)

/*
VM306:3	Fri Aug 08 2008 00:00:00 GMT+0800 (中国标准时间)
VM306:4 Fri Aug 08 2008 20:18:18 GMT+0800 (中国标准时间)
*/

-----------------------------------------------------------------------------------------
除了上述方式之外，Date 类型还可以接收一个 String 类型的日期格式的信息，Date 构造函数是可以将其进行解析的。
如下示例代码展示了如何创建一个指定年月日的 Date 对象：

var date = new Date('2008/8/8')
console.log(date)
/*Fri Aug 08 2008 00:00:00 GMT+0800 (中国标准时间)*/

-----------------------------------------------------------------------------------------
3、初始化为指定毫秒数

var date1 = new Date(0);
var date2 = new Date(1000*3600*24*365); 
console.log(date1)Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间)
console.log(date2)
/*Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间)
VM425:4 Fri Jan 01 1971 08:00:00 GMT+0800 (中国标准时间)*/
```



#### 获取日期方法

```css
Date 类型提供了一系列方法用来获取日期和时间，具体方法如下表所示：
```

| 方法              | 描述                                                         |
| :---------------- | :----------------------------------------------------------- |
| getDate()         | 返回 Date 对象“日期”部分数值（1 ~ 31）                       |
| getDay()          | 返回 Date 对象“星期”部分的数值（0 ~ 6）                      |
| getFullYear()     | 返回 Date 对象“年份”部分的实际数值                           |
| getHours()        | 返回 Date 对象“小时”部分的数值（0 ~ 23）                     |
| getMilliseconds() | 返回 Date 对象“毫秒”部分的数值（0 ~ 999）                    |
| getMinutes()      | 返回 Date 对象“分钟”部分的数值（0 ~ 59）                     |
| getMonth()        | 返回 Date 对象“月份”部分的数值（0 ~ 11）                     |
| getSeconds()      | 返回 Date 对象“秒”部分的数值（0 ~ 59）                       |
| getTime()         | 返回 Date 对象与 UTC 时间 1970 年 1 月 1 日午夜之间相差的毫秒数 |

```css
1、获取日期

Date 类型获取日期信息提供了 2 个方法，如下所示：

getDate() 方法：该方法是用来获取一个月中的第几天，值的范围为 1 ~ 31。
getDay() 方法：该方法时用来获取一个星期中的第几天，值的范围为 0 ~ 6。
上述这 2 两个方法都是用来获取日期，不过一个是一个月中的第几天，一个是一个星期中的第几天。如下示例代码所示：

var date = new Date().getDate()
var day = new Date().getDay()

console.log('今天是这个月的第 ' + date + ' 天，这个星期的第 ' + day + ' 天')
/*今天是这个月的第 8 天，这个星期的第 3 天*/

-----------------------------------------------------------------------------------------
2、获取年份

Date 类型获取年份信息可以通过 getFullYear() 方法实现，如下示例代码所示：
var year = new Date().getFullYear()
console.log(year)
/*2020*/

除了 getFullYear() 方法之外，Date 类型还提供了 getYear() 方法，该方法同样可以获取年份信息。如下示例代码所示：
console.log(new Date().getYear())
/*120*/
--getYear() 方法得到的是距离 1900 年的年份信息。
--getYear() 方法已经从 EMCA-262 标准规范中删除。也就是说，将来的某一天可能 JavaScript 语言的宿主环境不会再支持。建议不要使用！

-----------------------------------------------------------------------------------------
3、获取毫秒数

getTime() 方法算是一个比较特殊的方法。原因在于 getTime() 方法是用来获取距离 1970 年 1 月 1 日 00:00:00 的毫秒数值。如下示例代码所示：
console.log(new Date().getTime())

由于 getTime() 方法得到的是毫秒数，所以该方法经常用来做时间戳。所谓的时间戳，就是指一个能表示一份数据是在某个特定时间之前已经存在的、 完整的、 可验证的数据。时间戳通常是一个字符序列，唯一地标识某一刻的时间。
Date 类型提供的方法中，可以用来做时间戳的方法有 2 个，如下所示：
getTime() 方法
Date.now() 方法
```



#### 设置日期方法

```css
Date 类型除了提供了一系列获取日期和时间的方法之外，同样提供了一系列设置日期和时间的方法，如下表所示：
```

| 方法              | 描述                                                       |
| :---------------- | :--------------------------------------------------------- |
| setDate()         | 设置 Date 对象中“日期”部分的数值（1 ~ 31）                 |
| setFullYear()     | 设置 Date 对象中“年份”部分的实际数值                       |
| setHours()        | 设置 Date 对象中“小时”部分的数值（0 ~ 23）                 |
| setMilliseconds() | 设置 Date 对象中“毫秒”部分的数值（0 ~ 999）                |
| setMinutes()      | 设置 Date 对象中“分钟”部分的数值（0 ~ 59）                 |
| setMonth()        | 设置 Date 对象中“月份”部分的数值（0 ~ 11）                 |
| setSeconds()      | 设置 Date 对象中“秒”部分的数值（0 ~ 59）                   |
| setTime()         | 通过距离 1970 年 1 月 1 日 00:00:00 的毫秒是设置 Date 对象 |

```javascript
如下示例代码展示了以 `setDate()` 方法为例的一系列设置日期和时间的方法的用法：

var date = new Date()
console.log('当前时间: ' + date)

date.setDate(24)
console.log('修改后的时间: ' + date)
/*这样的结果是修改了一个月中的日*/
```



#### 日期格式化方法

```css
Date 类型除了提供了获取和设置日期和时间的一系列方法之外，还提供了将日期和时间格式化指定格式的一系列方法。如下表所示：
```

| 方法                 | 描述                                                         |
| :------------------- | :----------------------------------------------------------- |
| toString()           | 返回 Date 对象的字符串形式                                   |
| toDateString()       | 返回 Date 对象“日期”部分（*年月日*）的字符串形式             |
| toTimeString()       | 返回 Date 对象“时间”部分（*时分秒*）的字符串形式             |
| toLocaleString()     | 基于本地时间格式，返回 Date 对象的字符串形式                 |
| toLocaleDateString() | 基于本地时间格式，返回 Date 对象“ 日期”部分（*年月日*）的字符串形式 |
| toLocaleTimeString() | 基于本地时间格式，返回 Date 对象“时间”部分（*时分秒*）的字符串形式 |
| toGMTString()        | 基于 GMT 时间格式，返回 Date 对象的字符串形式                |
| toUTCString()        | 基于 UTC 时间格式，返回 Date 对象的字符串形式                |

```css
如下示例代码展示了以 toString() 方法为例的一系列格式化日期和时间的方法的用法：

var date = new Date().toString()
console.log('toString()方法得到的时间为:'+ date + ',类型为: ' + typeof date)
```



### Math 类型

```css
JavaScript 语言中的 Math 类型，提供了一系列有关数学常数的属性和数学计算的方法。Math 类型与 JavaScript 语言中的其他引用类型不同的是，Math 并不是一个构造函数。换句话讲，我们无法通过 Math 类型创建一个对象。如下示例代码所示：

var math = new Math()

/*当通过 new Math() 来创建一个对象时，JavaScript 语言报错为 Math is not a constructor 表示 Math 类型并不是一个构造函数。*/

而 Math 类型提供的属性和方法都是静态的。也就是说，我们可以通过 Math 类型直接调用即可。例如访问 Math 类型的 PI 属性的话，则为 Math.PI 即可。
```



#### Math 类型的属性

Math 类型提供了有关数学常数的一系列属性，具体如下表所示：

| 属性           | 描述                                           |
| :------------- | :--------------------------------------------- |
| `Math.E`       | 欧拉常数，自然对数的底数, 约等于 2.718         |
| `Math.LN2`     | 2 的自然对数, 约等于 0.693                     |
| `Math.LN10`    | 10 的自然对数, 约等于 2.303                    |
| `Math.LOG2E`   | 以 2 为底 E 的对数, 约等于 1.443               |
| `Math.LOG10E`  | 以 10 为底 E 的对数, 约等于 0.434              |
| `Math.PI`      | 圆周率，一个圆的周长和直径之比，约等于 3.14159 |
| `Math.SQRT1_2` | 1/2 的平方根, 约等于 0.707                     |
| `Math.SORT2`   | 2 的平方根,约等于 1.414                        |

值得注意的是，上述 Math 类型提供的一系列属性都是只读属性，不能修改。如下示例代码所示：

```javascript
Math.PI = Math.PI - 3
console.log(Math.PI)

/*结果虽然不会报错，但最终依然打印的依然是Math.PI的值*/
```



#### Math 类型的方法

Math 类型提供了用于数学计算的一系列方法，如下表所示：

| 方法      | 描述                       |
| :-------- | :------------------------- |
| abs(x)    | 返回 x 的绝对值            |
| exp(x)    | 返回 e 的指数              |
| log(x)    | 返回数的自然对数（底为 e） |
| pow(x, y) | 返回 x 的 y 次幂           |
| ceil(x)   | 对数进行向上取整           |
| floor(x)  | 对数进行向下取整           |
| round(x)  | 把数四舍五入为最接近的整数 |
| max(x, y) | 返回 x 和 y 中的最高值     |
| min(x, y) | 返回 x 和 y 中的最低值     |

如下示例代码以 `max()` 方法为例展示了上述 Math 类型提供的方法的用法：

```javascript
console.log('1和2之间的最大值为: ' + Math.max(1, 2))
```



#### 三角函数

Math 类型除了提供了一系列用于数学计算的方法之外，还提供了一系列有关三角函数的方法。如下表所示：

| 方法     | 描述                                                        |
| :------- | :---------------------------------------------------------- |
| cos(x)   | 返回数的余弦                                                |
| sin(x)   | 返回数的正弦                                                |
| tan(x)   | 返回角的正切                                                |
| acos(x)  | 返回数的反余弦值                                            |
| asin(x)  | 返回数的反正弦值                                            |
| atan(x)  | 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值      |
| atan2(x) | 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间） |

```css
需要注意的是，上述三角函数的计算结果是以弧度为返回值的。也就是说，我们需要通过 `Math.PI/180` 方式将弧度转换为角度再进行计算。
```



#### 生成随机数

```css
Math 类型提供了 `random()` 方法专门用来生成一个值范围为 0 ~ 1 之间的伪随机数。生成的这个随机数是包含 0 但不包含 1 的。

如下示例代码展示了 Math 类型的 `random()` 方法的用法：

console.log(Math.random())
```



### Array类型

```css
无论是一维数组还是二维数组，都是可以直接使用 Array 类型提供的属性和方法的。但我们需要注意的是创建数组的几种方式，如下示例代码所示：

//字面量方式创建数组
var arr1 = [1,2,3,4,5]
//构造函数方式创建数组
var arr2 = new Array([1,2,3,4,5])

-----------------------------------------------------------------------------------------
无论使用哪一种方式创建数组，它们都是 Array 类型的。这一点需要和 JavaScript 语言的基本数据类型进行区分，因为基本数据类型的创建变量方式类似。如下示例代码所示：

//字面量方式创建字符串
var str1 = '这是一个字符串.'
//构造函数方式创建字符串
var str2 = new String('这是一个字符串.')

如上示例代码所示，基本数据类型的两种方式创建变量，得到的结果并不一致。上述示例代码使用字面量方式创建的字符串是 string 类型，而使用构造函数方式创建的字符串是 String 类型。
```



```css
Array 类型提供的比较常见的数组操作如下列表所示：

检测数组
转换方法
进出栈方法
队列方法
排序方法
连接方法
操作方法
位置方法
递归方法
归并方法
```



#### 检测数组

```css
在操作数组之前，如果可以先确定操作的一定是数组的话，会减少很多不必要的错误。之前我们已经掌握的判断数据类型的方式是利用 typeof 或者 instanceof 运算符实现。但 typeof 运算符只能判断出 JavaScript 语言中的基本数据类型，Array 是引用类型，通过 typeof 运算符只能得到 object 的结果。

所以，使用 instanceof 运算符来判断是否为 Array 类型相较 typeof 运算符更为准确。如下示例代码所示：

console.log([1,2,3,4,5] instanceof Array)

-----------------------------------------------------------------------------------------
除了使用 instanceof 运算符来判断是否为数组之外，ECMA-262 第 5 版本为 Array 类型新增了 isArray() 方法，该方法用来判断当前变量是否为一个数组。如下示例代码所示：

console.log(Array.isArray([1,2,3,4,5]))

-----------------------------------------------------------------------------------------
支持 Array.isArray() 方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 10.5+ 和 Chrome。换句话讲，还有一些浏览器版本是不支持 Array.isArray() 方法的。在这些不支持 Array.isArray() 方法的浏览器中，我们可以使用 Object.prototype.toString.call() 方法来替代。如下示例代码所示：

console.log(Object.prototype.toString.call([1,2,3,4,5]))

-----------------------------------------------------------------------------------------除了上述方法之外，Object 类型提供了一个 isPrototypeOf() 方法，该方法用来检测一个对象是否在另一个对象的原型链上。由于 Object 是所有引用类型的父级，所以 Object 提供的方法所有引用类型都可以直接使用。如下示例代码所示：

console.log(Array.prototype.isPrototypeOf([1,2,3,4,5]))
```



#### 转换方法

```css
在讲解数据类型转换的时候，我们掌握了 toString() 方法可以将其他数据类型转换为 String 类型。
而 Array 除了提供了 toString() 方法之外，还提供了 valueOf() 方法，如下所示：

toString() 方法：将一个数组转换为字符串，数组中的元素之间使用逗号（,）进行分隔。

如下示例代码展示了 toString() 方法将数组转换为字符串的情况：

var arr = [100, true, '这是一个字符串']
console.log(arr.toString())
/*100,true,这是一个字符串*/

-----------------------------------------------------------------------------------------
valueOf() 方法：得到当前对象的原始值。如果是 Array 的话，则得到数组对象本身。

例如：
var arr = [100, true, '这是一个字符串']
console.log(arr.valueOf() === arr)
由于数组的原始值就是数组对象本身，所以 arr.valueOf() === arr 计算的结果为 true。
```



#### 进出栈方法

```css
栈是一种 LIFO（Last In First Out，后进先出）的数据结构。
栈是一种用来限制添加和删除数据内容的数据结构。

Array 类型提供了如下 2 个方法来实现类似栈的进栈和出栈的操作：

push() 方法：该方法将一个或多个数据内容添加到指定数组的末尾，并返回该数组的新长度。
pop() 方法：该方法将从指定数组的末尾删除一个数据内容，并返回被删除的数据内容。该方法会改变数组的长度。
如下示例代码展示了 Array 提供的 push() 方法和 pop() 方法的用法：

var arr = [100, true, '这是一个字符串']

var count = arr.push(200)
console.log('添加新元素之后的数组长度为: ' + count, arr)

var result = arr.pop()
console.log('数组删除的元素为: ' + result, arr)
/*
添加新元素之后的数组长度为: 4 (4) [100, true, "这是一个字符串", 200]
数组删除的元素为: 200 (3) [100, true, "这是一个字符串"]
*/
```



#### 队列方法

```css
队列就是一种 FIFO（First In First Out，先进先出）的数据结构。
队列与栈类似，都是一种用来限制添加和删除数据内容的数据结构。

Array 提供了如下 2 组方法来实现队列的：

push() 方法和 shift() 方法
unshift() 方法和 pop()方法
如下示例代码展示了 push() 方法和 shift() 方法的用法：

var arr = [100, true, '这是一个字符串']

var count = arr.push(200)
console.log('添加新元素之后的数组长度为: ' + count, arr)

var result = arr.shift()
console.log('数组删除的元素为: ' + result, arr)
/*
添加新元素之后的数组长度为: 4 (4) [100, true, "这是一个字符串", 200]
数组删除的元素为: 100 (3) [true, "这是一个字符串", 200]
*/
```



#### 排序方法

```css
Array 提供了 2 个方法来实现数组中元素的重排序效果，如下所示：

reverse() 方法：该方法将数组中元素的位置进行颠倒，并将颠倒后的数组返回。

sort() 方法：该方法按照升序排列方式将数组中的元素进行重新排序，并将重新排序的数组返回。
sort() 方法是将数组中所有的元素转换为字符串，然后再按照这些字符串的 UTF-16 码单元值序列进行排序的。

----------------------------------------------------------------------------
对数字使用sort（）也会按照UTF-16 码单元值序列进行排序的。

如果想要将数组中的所有元素按照数字值有小到大的顺序进行排序的话，可以通过 sort() 方法提供的参数来完成。

如下示例代码展示了如何实现将数组中的元素按照数字值有小到大的顺序进行排序：

var arr = [1, 21, 10, 5, 2]
var result = arr.sort(function(a, b){
	if (a < b) {
		return -1
	} else if (a > b) {
		return 1
	} else {
		return 0
	}
})
console.log(result)
```



#### 反转数组顺序

```javascript
Array 提供的 `reverse()` 方法是用来将某个数组中所有元素的顺序进行颠倒，并且得到颠倒后的数组。需要注意的是该方法会改变原有数组，如下示例代码所示：

var arr = [100, true, '这是一个字符串']
var result = arr.reverse()

console.log(arr, result)

/*
(3) ["这是一个字符串", true, 100] (3) ["这是一个字符串", true, 100]

结果可知使用 reverse() 方法不仅颠倒了数组中元素的顺序，并改变了原有数组。所以，如果使用 reverse() 方法颠倒某个数组时，记得先将原有数组进行备份，以便后续的操作。*/
```



#### 合并连接方法

```css
Aarray 提供了 concat() 方法用来合并两个或者多个数组。该方法不会改变原有数组，返回合并后的新数组。

如下示例代码展示了使用 concat() 方法合并两个数组的用法：
var arr = [1, 2, 3, 4, 5]
var result = arr.concat([6, 7, 8, 9, 10])
console.log(result, arr)

/*
(10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] (5) [1, 2, 3, 4, 5]
*/

--------------------------------------------------------------------
也可以将一个数组和一个或多个值进行合并。
如下示例代码所示：

var arr = [1, 2, 3, 4, 5]
console.log(arr.concat(6, 7))

/*[1, 2, 3, 4, 5, 6, 7]*/
```



#### 操作方法

```css
slice() 方法：该方法可以根据开始位置和结束位置从某个数组中截取指定的数据内容，并将其返回。
splice() 方法：该方法可以实现对某个数组的新增、修改以及删除等操作。
```

```css
1、slice() 方法

用来从某个数组中截取指定的数据内容，并将其进行返回。
begin 参数：可选项，表示截取开始的位置（从 0 开始）。
end 参数：可选项，表示截取结束的位置。截取的数据内容不包含 end 位置的数据内容。

例如：
var arr = ['ant', 'bison', 'camel', 'duck', 'elephant']
var result = arr.slice(1, 3)
console.log(result, arr)

/*
(2) ["bison", "camel"] (5) ["ant", "bison", "camel", "duck", "elephant"]
*/
slice() 方法并没有改变原有数组，并且 slice(1, 3) 截取的是从索引1开始到索引2结束的数据内容。

如果省略结束end，则会一直截取到数组的末尾最后一个。
```

```css
2、splice() 方法

用来删除某个数组的元素、修改某个数组的元素或者向某个数组新增元素等操作，并将改变后的数组返回。
其语法结构如下所示：

var arr = array.splice(start[, deleteCount[, item1[, item2[, ...]]]])

start 参数：表示修改数组的开始位置（从 0 开始）。
deleteCount 参数：可选项，表示要删除数组中元素的个数。
item1，item2，... 参数：可选项，表示从 start 指定的位置之前添加新元素。
返回值：由删除的元素组成的数组。如果只删除一个元素，则返回一个只有一个元素的数组。如果没有删除元素，则返回一个空数组。

如果将 deleteCount 参数的值设置为 0 的话，则表示 splice() 方法只向某个数组的 start 位置新增元素，不会删除原数组任何元素。如下示例代码所示：

var arr = ['ant', 'bison', 'camel']
var result = arr.splice(1, 0, 'duck', 'elephant')

console.log(result, arr)
/*
[]
["ant", "duck", "elephant", "bison", "camel"]
*/

结果可得到：没有删除 arr 数组中任何一个元素，所以 splice() 方法返回的结果为空数组。并且 splice() 方法会改变原有数组。

-------------------------------------------------------------------------------
如果省略 item1、item2 ... 等参数的话，则表示 splice() 方法从某个数组的 start 位置开始删除 deleteCount 个元素。如下示例代码所示：

var arr = ['ant', 'bison', 'camel', 'duck', 'elephant']
var result = arr.splice(1, 2)

console.log(result, arr)

/*
["bison", "camel"] 
["ant", "duck", "elephant"]
*/

结果可看出：arr原数组的内容索引值1和2被删除了，而result则是接受splice方法返回的内容

-------------------------------------------------------------------------------------
如果 deleteCount 参数的值大于 array.length-start 值的话，则是会将 start 位置之后的所有元素删除（包含 start 位置）。如下示例代码所示：

var arr = ['ant', 'bison', 'camel', 'duck', 'elephant']
var result = arr.splice(2, 4)

console.log(arr)

/*
["ant", "bison"]
*/

-----------------------------------------------------------------------------------------
如果 deleteCount 参数被省略的话，同样也会将 start 位置之后的所有元素删除（包含 start 位置）。如下示例代码所示：

var arr = ['ant', 'bison', 'camel', 'duck', 'elephant']
var result = arr.splice(2)

console.log(arr)

/*
["ant", "bison"]
*/

-----------------------------------------------------------------------------------------
如果 start 参数、deleteCount 参数和 item1、item2 ... 等参数全部传递的话，则表示 splice() 方法将某个数组从 start 位置开始的 deleteCount 个元素替换为 item1、item2 ... 等新的元素。如下示例代码所示：

var arr = ['ant', 'bison', 'camel', 'duck', 'elephant']
var result = arr.splice(2, 2, 'dog', 'cat', 'pig')

console.log(arr)

/*
["ant", "bison", "dog", "cat", "pig", "elephant"]
*/
```



#### 位置方法

```css
ECMA-262 第 5 版本为 Array 新增了两个有关位置的方法。
这两个方法都接收 2 个参数：一个是要查找的元素，一个是开始查找的位置。如下所示：

indexOf() 方法：在某个数组中查找指定元素的第一个索引值。如果存在则返回索引值，如果不存在则返回 -1。
lastIndexOf() 方法：在某个数组中查找指定元素的最后一个索引值。如果存在则返回索引值，如果不存在则返回 -1。

如下示例代码展示了 indexOf() 方法和 lastIndexOf() 方法的用法：

var arr = ['ant', 'bison', 'duck', 'camel', 'elephant', 'duck']

var searchResult1 = arr.indexOf('duck')
var searchResult2 = arr.lastIndexOf('duck')

console.log('查找duck的第一个索引值为 ' + searchResult1 + ',最后一个索引值为 ' + searchResult2)

/*
查找duck的第一个索引值为 2,最后一个索引值为 5
*/
```



#### 迭代方法

```css
ECMA-262 第 5 版本为 Array 新增了 5 个迭代数组的方法，也就是遍历数组中元素的方法。如下所示：

forEach() 方法：遍历数组中每一个元素时，会执行一个给定的函数。该方法没有返回值。

every() 方法：遍历数组中每一个元素，判断每一个元素是否满足给定函数的条件。如果满足则返回 true，否则返回 false。

filter() 方法：遍历数组中每一个元素，将满足给定函数条件的每一个元素组成一个新数组，并返回。

map() 方法：遍历数组中每一个元素，在给定函数中对每一个元素进行处理，并创建一个新数组进行返回。

some() 方法：遍历数组中每一个元素，如果有一个元素满足给定函数的条件，则返回 true，否则返回 false。
------------------------------------------------------------------------------------
上述 5 个迭代方法都是接收 2 个参数，一个是给定的函数，一个是调用给定函数时的 this 值（可选项）。而给定的函数还接收 3 个参数，如下所示：

currentValue 参数：当前遍历数组所得到的元素。
index 参数：当前遍历数组得到的元素所在的索引值。
array 参数：正在遍历的数组。

-----------------------------------------------------------------------------------------
如下示例代码展示了以 forEach() 方法为例的用法：

var arr = ['ant', 'bison', 'camel', 'duck', 'elephant']

arr.forEach(function(currentValue, index, array){
	console.log('当前元素的索引值为 ' + index + ', 元素为 ' + currentValue)
})

/*
当前元素的索引值为 0, 元素为 ant
当前元素的索引值为 1, 元素为 bison
当前元素的索引值为 2, 元素为 camel
当前元素的索引值为 3, 元素为 duck
当前元素的索引值为 4, 元素为 elephant
*/
```



#### 归并方法

```css
ECMA-262 第 5 版本为 Array 新增了 2 个归并方法。所谓的归并，就是指遍历数组中每一个元素，并调用给定的函数，将最终的结果进行返回。

这 2 个归并方法如下所示：

reduce() 方法：从左至右地遍历数组中每一个元素，调用给定的函数，并将最终的结果返回。
reduceRight() 方法：从右至左地遍历数组中每一个元素，调用给定的函数，并将最终的结果返回。

上述 2 个归并方法都是接收 2 个参数，
一个是给定的函数，
一个是第一次调用给定函数传递的给定函数的第一个参数值（可选项）。


而给定的函数接收 4 个参数，如下所示：
accumulator 参数：上一次调用给定函数得到的结果。
currentValue 参数：当前遍历数组所得到的元素。
index 参数：当前遍历数组得到的元素所在的索引值。
array 参数：正在遍历的数组。


如下示例代码展示了以 reduce() 方法为例，省略了第二个参数（initialValue）时的情况：

var arr = [0, 1, 2, 3, 4, 5]

var result = arr.reduce(function(accumulator, currentValue, currentIndex, array){
	return accumulator + currentValue
})

console.log(result)

/*15*/

-----------------------------------------------------------------------------------------
可用下例代码验证过程：
var arr = [0, 1, 2, 3, 4, 5]

var result = arr.reduce(function(accumulator, currentValue, currentIndex, array){
    
    console.log(accumulator, currentValue, currentIndex, array)
	return accumulator + currentValue
})
上述示例代码实际的执行流程如下所示：
```

| callback   | accumulator | currentValue | index | array              | return value |
| :--------- | :---------- | :----------- | :---- | :----------------- | :----------- |
| 第一次调用 | 0           | 1            | 1     | [0, 1, 2, 3, 4, 5] | 1            |
| 第二次调用 | 1           | 2            | 2     | [0, 1, 2, 3, 4, 5] | 3            |
| 第三次调用 | 3           | 3            | 3     | [0, 1, 2, 3, 4, 5] | 6            |
| 第四次调用 | 6           | 4            | 4     | [0, 1, 2, 3, 4, 5] | 10           |
| 第五次调用 | 10          | 5            | 5     | [0, 1, 2, 3, 4, 5] | 15           |

```css
如果不省略 reduce() 函数的第二个参数（initialValue）的话，那么 accumulator 参数第一次得到的值则为 initialValue 参数的值。如下示例代码所示：

var arr = [0, 1, 2, 3, 4, 5]

var result = arr.reduce(function(accumulator, currentValue, currentIndex, array){
	return accumulator + currentValue
}, 10)

console.log(result)

/*25*/
```



### RegExp类型

```css
javaScript 语言提供了 RegExp 类型，该类型的全称为 Regular Expression，译为正则表达式。正则表达式是由一些普通字符和特殊字符组成的，用来描述一种特定的字符规则的表达式。

正则表达式常用于在一段文本中搜索、匹配或替换特定形式的文本。如：词语出现频率统计、验证字符串是否符合邮箱格式、屏蔽一篇帖子中的限制性词语等。
```



#### 创建正则表达式

```css
与创建数组类似，创建正则表达式同样具有字面量方式、构造函数方式和 RegExp() 函数方式 3 种，并且这三种方式创建的正则表达式没有任何区别。

-----------------------------------------------------------------------------------------
1、字面量方式

字面量/直接量方式创建正则表达式指的是根据 ECMA-262 标准规范中定义的正则表达式的结构来创建正则表达式。JavaScript 语言中的正则表达式的基本语法结构如下：

/pattern/flags

pattern 参数：表示正则表达式的文本内容，可以包含字符类、限定符、分组、向前查找以及反向引用等内容。
flags 参数：可选项，用来表明正则表达式的行为。该参数支持如下 3 个值的匹配模式：
g：表示全局搜索
i：表示忽略大小写
m：表示多行匹配
根据上述的语法结构，如下示例代码展示了如何使用字面量方式定义一个正则表达式：

var pattern = /[bc]at/i
console.log(pattern)

上述示例代码的正则表达式表示匹配某个字符串中的第一个 bat 或 cat，并且不区分大小写。

-----------------------------------------------------------------------------------------
2、构造函数方式

JavaScript 语言中提供了 RegExp() 构造函数用来创建一个 RegExp 类型的对象，该类型提供了一系列的属性和方法完成某些特定的功能。其语法结构如下所示：

new RegExp(pattern [, flags])

如下示例代码展示了如何使用构造函数方式定义一个正则表达式：

var pattern1 = new RegExp('[bc]at', 'i')
var pattern2 = new RegExp(/[bc]at/, 'i')

console.log(pattern1, pattern2)

---------------------------------------------------------------------------------------
3、RegExp() 函数方式

JavaScript 语言中同样提供了 RegExp() 函数来创建一个正则表达式，其语法结构如下所示：

RegExp(pattern [, flags])
如下示例代码展示了如何使用 RegExp() 函数方式定义一个正则表达式：

var pattern1 = RegExp('[bc]at', 'i')
var pattern2 = RegExp(/[bc]at/, 'i')

console.log(pattern1, pattern2)
```



#### 正则表达式的模式

```css
正则表达式提供了一套独立的语法和规则。想要在 JavaScript 语言中应用正则表达式来解决实际问题，需要先掌握正则表达式的语法内容。

我们会从如下几个方面来学习正则表达式的语法内容：

字面量字符
字符集合
数量词
边界与断言
修饰符
```



#### 字面量字符

正则表达式是由一些普通字符和特殊字符组成的，其中所有字母和数字都是按照字面含义进行匹配的，而其他字符的匹配需要通过反斜线（`\`）作为前缀进行转义。如下表所示：

| 字符       | 匹配                                                         |
| :--------- | :----------------------------------------------------------- |
| 字母和数字 | 自身                                                         |
| `\0`       | 匹配 NULL（U+0000）字符， 不要在这后面跟其它小数，因为 `\0` 是一个八进制转义序列 |
| `\t`       | 匹配一个水平制表符（U+0009）                                 |
| `\n`       | 匹配一个换行符（U+000A）                                     |
| `\v`       | 匹配一个垂直制表符（U+000B）                                 |
| `\r`       | 匹配一个回车符（U+000D）                                     |
| `\xhh`     | 与代码 hh 匹配字符（两个十六进制数字）                       |
| `\uhhhh`   | 与代码 hhhh 匹配字符（四个十六进制数字）                     |



#### 字符集合

如果将正则表达式的字面量字符放置在一个方括号 [ ] 内的话就组成了字符集合。一个字符类可以匹配它所包含的任意字符，同时正则表达式提供了一系列转义字符来表示一些比较常用的字符。如下表所示：

| 字符   | 匹配                                                         |
| :----- | :----------------------------------------------------------- |
| `[…]`  | 一个字符集合。匹配方括号的中任意字符，包含转义字符。         |
| `[^…]` | 一个反向字符集                                               |
| `.`    | 默认匹配除换行符之外的任何单个字符                           |
| `\w`   | 匹配一个单字字符（字母、数字或者下划线）。等价于 `[A-Za-z0-9_]` |
| `\W`   | 匹配一个非单字字符。等价于 `[^A-Za-z0-9_]`                   |
| `\s`   | 匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于 `[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]` |
| `\S`   | 匹配一个非空白字符。等价于 `[^\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]` |
| `\d`   | 匹配一个数字。等价于 `[0-9]`                                 |
| `\D`   | 匹配一个非数字字符。等价于 `[^0-9]`                          |

```css
例如：
var str = 'abc9test'
var result = /[0123456789]/.test(str)

console.log(result)
/*true*/

 正则表达式表示只要匹配 0123456789 中的任意一个即可，由于 abc9test 字符串中包含 9，所以最终的结果为 true，表示匹配。
```



#### 数量词

正则表达式经常需要来匹配某个字符或者某些字符是重复出现，例如 `/\d\d/` 表示数字连续出现两次。这种匹配重复出现的情况，可以使用正则表达式提供的指定字符重复的标记。如下表所示：

| 字符    | 匹配                                                |
| :------ | :-------------------------------------------------- |
| `{n,m}` | n 和 m 都是整数，匹配前面的字符至少 n 次，最多 m 次 |
| `{n}`   | n 是一个正整数，匹配了前面一个字符刚好出现了 n 次   |
| `{n,}`  | n 是一个正整数，匹配前一个字符至少出现了 n 次       |
| `?`     | 匹配前面一个表达式 0 次或者 1 次。等价于 `{0,1}`    |
| `+`     | 匹配前面一个表达式 1 次或者多次。等价于 `{1,}`      |
| `*`     | 匹配前一个表达式 0 次或多次。等价于 `{0,}`          |

```css
上述标记以 {n,m} 为例进行学习，如下示例代码所示：

var str = 'abc89test'
var result = /[\d]{1,2}/.test(str)

console.log(result)
/*true*/

我们可以看到 /[\d]{1,2}/ 正则表达式表示数字至少出现 1 次最多出现 2 次，而 abc89test 字符串中包含 89 两个数字，最终结果为 true。
```



#### 边界与断言

匹配某些字符串时，可能需要完全匹配，或者是以某些字符开始，亦或者是以某些字符结束等。想要满足这些需求，可以通过正则表达式提供的有关指定匹配位置的标记来实现。如下表所示：

| 字符     | 匹配                                                         |
| :------- | :----------------------------------------------------------- |
| `^`      | 匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置 |
| `$`      | 匹配输入的结束。如果多行标示被设置为 true，那么也匹配换行符前的位置 |
| `\b`     | 匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置 |
| `\B`     | 匹配一个非单词边界                                           |
| `x(?=y)` | 匹配 x 仅仅当 x 后面跟着 y，这种叫做先行断言                 |
| `x(?!y)` | 仅仅当 x 后面不跟着 y 时匹配 x，这被称为正向否定查找         |

```css
例如：
var str = 'JavaScript'
var result = /^JavaScript$/.test(str)

console.log(result)
/*true*/
我们可以看到 /^JavaScript$/ 正则表达式表示的是以 JavaScript 开始的，并且以 JavaScript 结束的。换句话讲，就是某个字符串是否完全匹配 JavaScript，如果匹配则返回 true，否则返回 false。
```



#### 修饰符

正则表达式的修饰符，可以实现正则表达式的高级匹配模式的规则。在 JavaScript 语言中支持的修饰符有 3 个，如下表所示：

| 字符 | 匹配             |
| :--- | :--------------- |
| `i`  | 不区分大小写搜索 |
| `g`  | 全局搜索         |
| `m`  | 多行搜索         |

```css
上述标记以 i 为例进行学习，如下示例代码所示：

var str = 'JavaScript'
var reg = /^javascript$/i
var result = reg.test(str)

console.log(result)
/*true*/

我们可以看到虽然 JavaScript 字符串中既有大写字符也有小写字符，但因为 /^javascript$/i 正则表达式中使用了 i 修饰符表示不区分大小写的匹配，最终的结果为 true。
```



#### RegExp 对象

```
JavaScript 语言中的 RegExp 类型同样是一个构造函数，除了可以用来创建一个 RegExp 类型的对象之外，RegExp 类型还提供了一些属性和方法供使用。
```

#### RegExp 对象的属性

RegExp 类型提供了 5 个常用属性，其中 4 个属性是只读属性。如下表所示：

| 属性名     | 描述                                     |
| :--------- | :--------------------------------------- |
| global     | 只读属性，RegExp 对象是否具有 `g` 修饰符 |
| ignoreCase | 只读属性，RegExp 对象是否具有 `i` 修饰符 |
| multiline  | 只读属性，RegExp 对象是否具有 `m` 修饰符 |
| lastIndex  | 用于设置/获取下次匹配的起始位置          |
| source     | 只读属性，返回模式匹配所使用的文本       |

```css
上述属性以 ignoreCase 为例进行学习，如下示例代码所示：

var reg = /^javascript$/i
console.log(reg.ignoreCase)
/*true*/
```



#### RegExp 对象的方法

```css
RegExp 类型仅提供了 2 个方法以供使用，但这两个方法在正则表达式的使用频率还是很高的。如下所示：

- `test()` 方法：用来查看正则表达式与指定的字符串是否匹配。如果匹配返回 true，否则返回 false。
- `exec()` 方法：在一个指定字符串中执行一个搜索匹配。返回结果为数组或 null。

如下示例代码所示：

console.log(/^JavaScript$/.test('JavaScript'))
/*true*/

----------------------------------------------------
使用时 exec() 方法的作用与 test() 方法的作用是一致的，只不过如果匹配的话 exec() 方法返回的结果为一个数组，如果不匹配的话则返回 null。如下示例代码所示：

var matches = /(hello \S+)/.exec('This is a hello world!');
console.log(matches);
/*
(2) ["hello world!", "hello world!", index: 10, input: "This is a hello world!", groups: undefined]
0: "hello world!"
1: "hello world!"
index: 10
input: "This is a hello world!"
groups: undefined
length: 2
__proto__: Array(0)
*/
```

如上结果所示，我们可以看到 `exec()` 方法返回的数组中所包含的内容时比较丰富的，其中具体的含义如下：

| 属性/索引   | 描述                                        |
| :---------- | :------------------------------------------ |
| `[0]`       | 匹配的全部字符串                            |
| `[1]...[n]` | 括号中的分组捕获                            |
| `index`     | 匹配到的字符位于原始字符串的基于 0 的索引值 |
| `input`     | 原始字符串                                  |



### String类型

```css
javaScript 语言中的 String 类型可以用来定义字符串，通过创建 String 类型的对象。基本数据类型 string 同样可以定义字符串，不同的是 string 类型是通过字面量方式定义字符串的。如下示例代码所示：

var str1 = '这是一个字符串'
var str2 = new String('这是另一个字符串')

console.log((typeof str1) === 'string')
console.log(str2 instanceof String)
/*true*/
/*true*/

无论是 string 基本数据类型，还是 String 引用类型，都可以使用 String 类型提供的属性和方法。
```



#### 常见操作

```css
String 类型提供了一系列方法可以完成各种各样的功能，大体可以划分为如下几种：

- 大小写转换
- 获取指定位置的字符串
- 检索字符串
- 截取子字符串
- 分隔字符串
- 连接字符串
```



#### 大小写转换

```
在 JavaScript 语言的字符串中，经常遇到例如英语这种对大小写有特别需求的情况。String 类型提供了 4 个与大小写转换有关的方法，如下表所示：
```

| 方法                  | 描述                                         |
| :-------------------- | :------------------------------------------- |
| `toUpperCase()`       | 将字符串转换成大写并返回                     |
| `toLowerCase()`       | 将字符串转换成小写并返回                     |
| `toLocaleUpperCase()` | 根据当前区域设置，将字符串中的字符转换成大写 |
| `toLocaleLowerCase()` | 根据当前区域设置，将符串中的字符转换成小写   |

```css
toLocaleLowerCase()和toLocaleUpperCase()方法是针对特定地区的实现。
对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言(如土耳其语言)会为Unicode大小写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换

其中，toLowerCase()和toUpperCase()是两个经典的方法，借鉴自java.lang.String中的同名方法。
如下示例代码展示了 `toUpperCase()` 方法和 `toLowerCase()` 方法的用法：

var msg = 'Hello World'

var lowerMsg = msg.toLowerCase()
var upperMsg = msg.toUpperCase()

console.log( msg );// Hello World
console.log( lowerMsg );// hello world
console.log( upperMsg );// HELLO WORLD

需要注意的是，中文是不需要区分大小写的。所以，上述有关大小写转换的方法应该用于除中文以外的需要大小写形式的字符中。
```



#### 获取指定位置的字符串

```css
String 类型提供了 3 个根据索引值获取某个字符串中对应位置上的字符的方法。这些方法常用来取出指定字符之后进行逻辑判断等应用场景。具体方法如下表所示：
```

| 方法            | 描述                                         |
| :-------------- | :------------------------------------------- |
| `charAt()`      | 返回特定位置的字符                           |
| `charCodeAt()`  | 返回表示给定索引的字符的 Unicode 值          |
| `codePointAt()` | 返回使用 UTF-16 编码的给定位置的值的非负整数 |

```css
var str = 'Hello World!'

var charAt = str.charAt(2)
var charCodeAt = str.charCodeAt(2)
var codePointAt = str.codePointAt(2)

console.log(charAt, charCodeAt, codePointAt)

/*l 108 108*/
我们可以看到 Hello World 字符串中索引值为 2 的是 l 字符，其 Unicode 值为 108。
```



#### 检索字符串

```css
String 类型提供了 2 个根据字符或子字符串来查找对应的索引值。如果在某个字符串中并不存在指定的字符或子字符串的话，则查找的结果为 -1。这两个方法如下表所示：
```

| 方法            | 描述                                                         |
| :-------------- | :----------------------------------------------------------- |
| `indexOf()`     | 从字符串中查找首个与给定值一致的首字母的索引值，如果没有找到则返回 -1 |
| `lastIndexOf()` | 从字符串中查找最后一个与给定值一致的首字母的索引值，如果没有找到则返回 -1 |

```javascript
上述两个方法都接收 2 个参数，具体含义如下所示：

- searchValue 参数：一个字符串，表示被查找的值
- fromIndex 参数：可选项，表示开始查找的位置，默认值为 0。

如下示例代码展示了上述方法的具体用法：

var email = 'tom@163@sohu.com'

console.log(email.indexOf('tom'))
console.log(email.indexOf('@', 5))

console.log(email.lastIndexOf('@'))
console.log(email.lastIndexOf('@', 5) )

console.log(email.indexOf('Mary'))

/*
0
7
7
3
-1
*/
```



#### 截取子字符串

```css
String 类型提供了 3 个用来截取某个字符串的方法，这 3 个方法会返回按照规则截取的子字符串，并且不会改变原有字符串的内容。如下表所示：
```

| 方法          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| `slice()`     | 截取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串 |
| `substring()` | 返回一个字符串在开始索引到结束索引之间的一个子字符串         |
| `substr()`    | 返回一个字符串中从指定位置开始到指定字符数的子字符串         |

```javascript
`slice()` 方法会根据开始截取的位置和结束截取的位置来截取某个字符串的内容，并将截取的子字符串作为一个新的字符串返回。其语法结构如下：

var new_str = str.slice(beginIndex[, endIndex])

- beginIndex 参数：表示开始截取的索引值。如果为负数的话，会被当做字符串的 `length + beginIndex` 计算值看待。
- endIndex 参数：可选项，表示结束截取的索引值。如果为负数的话，会被当做字符串的 `length + endIndex` 计算值看待。
```

```css
1、根据上述语法结构，如下示例代码展示了 `slice()` 方法的用法：

var str = 'javascript'

var result1 = str.slice(1, 3)
var result2 = str.slice(-9, -7)

console.log(result1, result2)

/*
av av
*/

我们可以看到 2 种截取的方式最终得到的结果是一样。这是因为 javascript 的 length 属性值为 10，而 str.slice(-9, -7) 中的 -9 就相当于 10 + -9 结果为 1，-7 就相当于 10 + -7 结果为 3，与第一种写法一致。

-----------------------------------------------------------------------------------------
2、substring() 方法

会根据开始截取的位置和结束截取的位置来截取某个字符串的内容，并将截取的子字符串作为一个新的字符串返回。其语法结构如下：

var new_str = str.substring(indexStart[, indexEnd])

indexStart 参数：表示开始截取的索引值。
indexEnd 参数：可选项，表示结束截取的索引值。
substring() 方法与 slice() 方法的区别在于 slice() 方法的参数允许为负数，而 substring() 方法的参数为负数时会被当做 0。如下示例代码所示：

var str = 'javascript'

var result1 = str.substring(1, 3)
var result2 = str.substring(-9, -7)

console.log(result1, result2)
/*av*/

我们可以看到第一次的截取与 slice() 方法相同的参数的结果是一致的。但第二次截取时，由于 -9 和 -7 都是为负数，会被当做 0 来处理。而当两个参数值相同时，则返回空字符串

需要注意的是，substring() 方法有关两个参数的情况，如下所示：

如果 indexStart 等于 indexEnd，substring() 方法返回一个空字符串。
如果省略 indexEnd，substring() 方法提取字符一直到字符串末尾。
如果任一参数小于 0 或为 NaN，则被当作 0。
如果任一参数大于 stringName.length，则被当作 stringName.length。
如果 indexStart 大于 indexEnd，则 substring() 方法的执行效果就像两个参数调换了一样。

-----------------------------------------------------------------------------------------
3、substr() 方法会根据开始截取的位置截取指定长度的子字符串，并将截取的子字符串作为一个新的字符串返回。其语法结构如下：

var new_str = str.substr(start[, length])

start 参数：表示开始截取的索引值。如果为负数的话，会被当做字符串的 length + start 计算值看待。
length 参数：可选项，表示截取的长度。
substr() 方法与 slice() 方法和 substring() 方法不同的是 substr() 方法是根据指定的字符数来截取子字符串的。如下示例代码所示：

var str = 'javascript'

var result1 = str.substr(1, 2)
var result2 = str.substr(-9, 2)

console.log(result1, result2
/*
av av
*/

需要注意的是，substr() 方法虽然并没有从 EMCA-262 标准规范中废除，但被作为遗留的方法还是尽量不要使用，可以使用另两个方法进行替代。
```



#### 分隔字符串

```javascript
String 类型提供了 `split()` 方法用来按照指定分割符来将某个字符串分割为一个数组。其语法结构如下所示：

var str_arr = str.split([separator[, limit]])
```

```css
- separator 参数：表示分割字符串的分割符，可以是一个字符串或正则表达式。
- limit 参数：表示限定返回分割片段的数量。

根据上述语法结构，如下示例代码展示了 `split()` 方法的用法：

var str = 'Lucy,Mary,Lily,Aoni'

var result1 = str.split(',')
var result2 = str.split(',', 2)

console.log(result1, result2)
/*
(4) ["Lucy", "Mary", "Lily", "Aoni"] 
(2) ["Lucy", "Mary"]
*/

-----------------------------------------------------------------------------------------
如果某个字符串中的字符之间没有任何分隔符的话，那么使用 split() 方法进行分隔时可以传递一个空字符串。如下示例代码所示：

var str = 'javascript'
console.log(str.split(''))
/*
["j", "a", "v", "a", "s", "c", "r", "i", "p", "t"]
*/

-----------------------------------------------------------------------------------------
需要注意的是，当字符串为空时，split() 方法返回一个包含一个空字符串的数组，而不是一个空数组。如果字符串和分隔符都是空字符串，split() 则返回一个空数组。

例：
var str = ''
console.log(str.split(''))
/*VM140:2 []*/

var str = ' '
console.log(str.split(''))
/*VM140:3 [" "]*/
```



#### 连接字符串

```css
String 类型提供了 `concat()` 方法用来将一个或多个字符串与原有字符串连接合并在一起，形成一个新的字符串并返回。其语法结构如下所示：

var new_str = str.concat(string1, string2[, ..., stringN])
```

```css
- string1...stringN 参数：表示要与原有字符串连接合并的字符串。

根据上述语法结构，如下示例代码展示了 `concat()` 方法的用法：

var hello = 'Hello, '
var result = hello.concat('Kevin', ' have a nice day.')
console.log(result)
/*
Hello, Kevin have a nice day.
*/

建议尽量使用字符串连接运算符，而不是 concat() 方法。因为字符串连接运算符的性能要优于 concat() 方法。
```



#### 模式匹配

```javascript
由于在 JavaScript 语言中正则表达式主要是配合字符串来使用的，而 String 类型提供了 3 个与正则表达式有关的方法，这些方法称为模式匹配方法。如下所示：

- `search()` 方法：在某个字符串中查找与指定正则表达式匹配的子字符串，并返回首次匹配的字符的索引值。
- `match()` 方法：在某个字符串中检索与指定正则表达式匹配的子字符串，并返回匹配的结果。
- `replace()` 方法：在某个字符串中检索与指定正则表达式匹配的子字符串，将匹配的子字符串进行替换，并返回替换的新字符串。

-----------------------------------------------------------------------------------------
1、`search()` 方法用来在某个字符串中查找是否存在与指定正则表达式的子字符串。如果存在则返回首次匹配的索引值，如果不存在则返回 -1。如下示例代码所示：

var data = 'Microsoft is a big Company, Microsoft’s color is red and has MICROSOFT logo like Microsoft'

console.log(data.search(/microsoft/))
console.log(data.search(/microsoft/i))
/*
-1
0
*/
```

```javascript
2、`match()` 方法与 `search()` 方法的区别在于 `match()` 方法返回的不是索引值，而是将匹配的结果进行返回。如下示例代码所示：

var data = 'Microsoft is a big Company, Microsoft’s color is red and has MICROSOFT logo like Microsoft'

console.log(data.match(/microsoft/))
console.log(data.match(/microsoft/i))

/*
null

["Microsoft", index: 0, input: "Microsoft is a big Company, Microsoft’s color is red and has MICROSOFT logo like Microsoft", groups: undefined]
*/
```

```css
如上图的结果所示，我们可以看到如果 `match()` 方法最终没有任何匹配的话，则返回 null 值。如果匹配的话，则返回一个数组。该数组中所包含的内容时比较丰富的，其中具体的含义如下：
```

| 属性/索引 | 描述                                        |
| :-------- | :------------------------------------------ |
| `[0]`     | 匹配的全部字符串                            |
| `index`   | 匹配到的字符位于原始字符串的基于 0 的索引值 |
| `input`   | 原始字符串                                  |

```css
3、replace() 方法是用来在某个字符串中根据指定正则表达式进行检索，并将其匹配的进行替换，最终将替换后的新字符串进行返回。如下示例代码所示：

var data = 'Microsoft is a big Company, microsoft’s color is red and has MICROSOFT logo like microsoft';

console.log(data.replace(/microsoft/ig, 'oracle'))

/*
oracle is a big Company, oracle’s color is red and has oracle logo like oracle
*/

这样匹配不区分大小写，并且把全局的把所有的Microsoft替换为oracle
```





# 三、DOM



## 一、基础概念



### 导入JavaScript脚本

```css
<script>元素: 引入脚本
    * type属性: 设置当前引入的脚本语言
    * language属性: 设置当前引入的脚本语言
    * src属性: 设置引入脚本文件的路径
   -->
<script>
```

```css
浏览器解析HTML页面时: 自上向下的顺序，若将js放在<head>元素中，会导致js无效果。
这是因为<body>元素中的内容还没加载，就读了js。

俩种解决方法：

1、将JavaScript脚本放在<body>元素中的最后
2、继续放在<head>元素中，但要在<JavaScript>元素中引入window.onload=function(){}

例如以下写法：
<head>
<script>
    /*表示HTML页面加载完毕后, 做什么*/
    window.onload = function () {
      /*所有的javascript代码编写在这里*/
    } 
</script>
</head>

-----------------------------------------------------------------------------------------
扩充：

head内的js会阻塞页面的传输和页面的渲染。head 内的 JavaScript 需要执行结束才开始渲染 body，所以尽量不要将 JS 文件放在 head 内。可以选择在 document 完成时，或者特定区块后引入和执行 JavaScript。

所以在head内的js一般要先执行完后，才开始渲染body页面。为了避免head引入的js脚本阻塞浏览器中主解析引擎对dom的解析工作，对dom的渲染，一般原则是，样式在前面，dom文档，脚本在最后面。遵循先解析再渲染再执行script这个顺序。
```



### DOM概述

```css
DOM（Document Object Model——文档对象模型）
是用来呈现以及与任意 HTML 或 XML文档交互的API。DOM 是载入到浏览器中的文档模型，以节点树的形式来表现文档，每个节点代表文档的构成部分（例如:页面元素、字符串或注释等等）。

DOM 是万维网上使用最为广泛的API之一，因为它允许运行在浏览器中的代码访问文件中的节点并与之交互。
节点可以被创建，移动或修改。事件监听器可以被添加到节点上并在给定事件发生时触发。

DOM 并不是天生就被规范好了的，它是浏览器开始实现JavaScript时才出现的。
这个传统的 DOM 有时会被称为 DOM 0。现在， WHATWG维护DOM现存标准。

--------------------------------------------------------------------
D表示Document，就是DOM将HTML页面解析为一个文档。同时提供了document对象。
O表示Object，就是DOM将HTML页面中每个元素解析为一个对象。
M表示Model,就是DOM中表示各个对象之间的关系。


-------------------------------------------------------------------------
DOM是一个独立于任何语言和平台的接口，允许任何语言或脚本动态地访问和更新HTML文档的内容、结构和样式。对该HTML页面可以进一步处理，并且该处理的结果可以被合并到所呈现的HTML页面中。

```



### DOM作用

```css
DOM被设计用于解析HTML页面文档，方便JavaScript语言通过DOM访问和操作HTML页面中的内容。

DOM是由W3C组织定义标准规范，并且由各大浏览器厂商支持。严格意义上来讲，DOM并非属于JavaScript语言。

我们之所以可以在JavaScript语言中使用DOM，是因为各大浏览器将DOM的标准规范内容封装成了JavaScript语言所支持的形式。

对DOM中的对象，我们只有调用的权限，没有修改的权限，也说明了这个问题。

浏览器加载并运行HTML页面后，会创建DOM结构。由于DOM中的内容被封装成了JavaScript语言中的对象，所以我们可以使JavaScript语言通过DOM结构来访问和操作HTML页面中的内容。

```



### DOM 树结构

```css
DOM可以访问和更新HTML页面中的内容、结构和样式，是因为DOM将HTML页面解析为一个树结构。

如下图所示：
```



![image-20200411165621665](C:\Users\10796\AppData\Roaming\Typora\typora-user-images\image-20200411165621665.png)

```css
节点(Node)原本是网络术语，表示网络中的连接点。一一个网络是由一些节点构成的集合。
在DOM树结构中，节点也是很重要的一一个概念。
简单来说，节点作为DOM树结构中的连接点，最终构成了完整的DOM树结构。
```

|         常量         |  值  |                             描述                             |
| :------------------: | :--: | :----------------------------------------------------------: |
| Node.DOCUMENT_ NODE  |  9   |        文档节点，表示整个HTML页面(相当于document对象)        |
|  Node.ELEMENT_ NODE  |  1   |       元素节点，表示HTML页面中的标签(即HTML页面的结构)       |
| Node.ATTRIBUTE _NODE |  2   | 属性节点，表示HTML页面中的开始标签包含的属性。在DOM4规范里Node接口将不再实现这个元素属性 |
|   Node.TEXT_ NODE    |  3   |       文本节点， 表示HTML页面中的标签所包含的文本内容        |

